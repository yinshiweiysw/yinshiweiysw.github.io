

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="进程进程本质上就是程序数据从硬盘中读取到内存中运行，从而形成一个进程。 进程运行三种状态： 1、就绪状态。某些进程“万事俱备”(必要资源)，只差CPU。（就绪队列）        2、执行状态。某进程占有CPU并在CPU上执行其程序。        3、阻塞状态。某些进程由于某种原因不能继续运行下去，等待处 理问题。也称为等待状态或封锁状态。如：请求I&#x2F;O。（多个等待队列）       进程状态转">
<meta property="og:type" content="article">
<meta property="og:title" content="进程与线程">
<meta property="og:url" content="http://example.com/2021/11/18/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_hexo/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="进程进程本质上就是程序数据从硬盘中读取到内存中运行，从而形成一个进程。 进程运行三种状态： 1、就绪状态。某些进程“万事俱备”(必要资源)，只差CPU。（就绪队列）        2、执行状态。某进程占有CPU并在CPU上执行其程序。        3、阻塞状态。某些进程由于某种原因不能继续运行下去，等待处 理问题。也称为等待状态或封锁状态。如：请求I&#x2F;O。（多个等待队列）       进程状态转">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhbmdoYW9kcmVhbQ==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109103747341.png">
<meta property="og:image" content="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109104132647.png">
<meta property="og:image" content="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111009514.png">
<meta property="og:image" content="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111117503.png">
<meta property="og:image" content="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211111094637428.png">
<meta property="article:published_time" content="2021-11-18T09:24:47.000Z">
<meta property="article:modified_time" content="2021-11-19T03:54:23.560Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhbmdoYW9kcmVhbQ==,size_16,color_FFFFFF,t_70.png">
  
  
  <title>进程与线程 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="进程与线程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-18 17:24" pubdate>
        November 18, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      95 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">进程与线程</h1>
            
            <div class="markdown-body">
              <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程本质上就是程序数据从硬盘中读取到内存中运行，从而形成一个进程。</p>
<h2 id="进程运行三种状态："><a href="#进程运行三种状态：" class="headerlink" title="进程运行三种状态："></a>进程运行三种状态：</h2><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhbmdoYW9kcmVhbQ==,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>1、就绪状态。某些进程“万事俱备”(必要资源)，只差CPU。（就绪队列）      </p>
<p> 2、执行状态。某进程占有CPU并在CPU上执行其程序。      </p>
<p> 3、阻塞状态。某些进程由于某种原因不能继续运行下去，等待处 理问题。也称为等待状态或封锁状态。如：请求I/O。（多个等待队列）      </p>
<h3 id="进程状态转换的原因："><a href="#进程状态转换的原因：" class="headerlink" title="进程状态转换的原因："></a>进程状态转换的原因：</h3><p>1）就绪-→执行：</p>
<p>对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p>
<p>2）执行-→阻塞：</p>
<p>正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态。</p>
<p>如：进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；</p>
<p>3）阻塞-→就绪：</p>
<p>处于阻塞状态的进程，在其等待的事件已经完成，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p>
<p>4）执行-→就绪：</p>
<p>正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞是用来定义程序的运行状态：</p>
<p>​    阻塞:阻塞态<br>​            非阻塞:就绪态、运行态</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a><strong>同步和异步</strong></h3><p>正常情况下，一个进程运行首先进入就绪态，因一个cpu不能同时调度多个作业，所以需要排队等待进入运行态。进入运行态时，此时的进程正在被cpu调度运行。当进程进入i/o状态时，此时该进程就会从运行态变为阻塞态（系统此时会把cpu分给其他进程）。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;&quot;&quot;描述的是任务的提交方式&quot;&quot;&quot;</span><br>同步:任务提交之后，原地等待任务的返回结果，等待的过程中不做任何事(干等)<br>  	程序层面上表现出来的感觉就是卡住了<br><br>异步:任务提交之后，不原地等待任务的返回结果，直接去做其他事情<br>  	我提交的任务结果如何获取？<br>    任务的返回结果会有一个异步回调机制自动处理<br></code></pre></td></tr></table></figure>



<h2 id="开启进程的两种方式"><a href="#开启进程的两种方式" class="headerlink" title="开启进程的两种方式"></a>开启进程的两种方式</h2><p>定心丸:代码开启进程和线程的方式，代码书写基本是一样的，你学会了如何开启进程就学会了如何开启线程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s is running&#x27;</span>%name)<br>    time.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s is over&#x27;</span>%name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 1 创建一个对象</span><br>    p = Process(target=task, args=(<span class="hljs-string">&#x27;jason&#x27;</span>,))<br>    <span class="hljs-comment"># 容器类型哪怕里面只有1个元素 建议要用逗号隔开</span><br>    <span class="hljs-comment"># 2 开启进程</span><br>    p.start()  <span class="hljs-comment"># 告诉操作系统帮你创建一个进程  异步</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主&#x27;</span>)<br>    <br>    <br><span class="hljs-comment"># 第二种方式 类的继承</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcess</span>(<span class="hljs-params">Process</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello bf girl&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;get out!&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = MyProcess()<br>    p.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">创建进程就是在内存中申请一块内存空间将需要运行的代码丢进去</span><br><span class="hljs-string">一个进程对应在内存中就是一块独立的内存空间</span><br><span class="hljs-string">多个进程对应在内存中就是多块独立的内存空间</span><br><span class="hljs-string">进程与进程之间数据默认情况下是无法直接交互,如果想交互可以借助于第三方工具、模块</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>join是让主进程等待子进程代码运行结束之后，再继续运行。不影响其他子进程的执行</p>
<p>下面的代码当主进程P.start执行运行子进程代码后，主进程并不会等子进程运行完再往下运行，所以正常情况下程序输出‘主进程已经结束这句话不会再最后面’，如果想让主进程等待子进程执行完字节代码再往下执行就在再需要等待子进程执行完再执行的主代码前面加上join方法</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109103747341.png" srcset="/img/loading.gif" lazyload alt="image-20211109103747341"></p>
<p>方法如下，此时主进程会等待子进程执行完再打印’主进程已经结束’。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109104132647.png" srcset="/img/loading.gif" lazyload alt="image-20211109104132647"></p>
<h2 id="管理进程pid"><a href="#管理进程pid" class="headerlink" title="管理进程pid"></a>管理进程pid</h2><p>​    方法: os.getpid,os.getppid,进程对象.terminate,进程对象.is_alive</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">一台计算机上面运行着很多进程，那么计算机是如何区分并管理这些进程服务端的呢？</span><br><span class="hljs-string">计算机会给每一个运行的进程分配一个PID号 </span><br><span class="hljs-string">如何查看</span><br><span class="hljs-string">	windows电脑 </span><br><span class="hljs-string">		进入cmd输入tasklist即可查看</span><br><span class="hljs-string">		tasklist |findstr PID查看具体的进程</span><br><span class="hljs-string">	mac电脑 </span><br><span class="hljs-string">		进入终端之后输入ps aux</span><br><span class="hljs-string">		ps aux|grep PID查看具体的进程 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, current_process<br>current_process().pid  <span class="hljs-comment"># 查看当前进程的进程号</span><br><br><span class="hljs-keyword">import</span> os<br>os.getpid()  <span class="hljs-comment"># 查看当前进程进程号</span><br>os.getppid()  <span class="hljs-comment"># 查看当前进程的父进程进程号</span><br><br><br>p.terminate()  <span class="hljs-comment"># 杀死当前进程</span><br><span class="hljs-comment"># 是告诉操作系统帮你去杀死当前进程 但是需要一定的时间 而代码的运行速度极快</span><br>time.sleep(<span class="hljs-number">0.1</span>)<br><span class="hljs-built_in">print</span>(p.is_alive())  <span class="hljs-comment"># 判断当前进程是否存活</span><br></code></pre></td></tr></table></figure>

<h3 id="僵尸进程与孤儿进程-了解"><a href="#僵尸进程与孤儿进程-了解" class="headerlink" title="僵尸进程与孤儿进程(了解)"></a>僵尸进程与孤儿进程(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 僵尸进程</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">死了但是没有死透</span><br><span class="hljs-string">当你开设了子进程之后 该进程死后不会立刻释放占用的进程号</span><br><span class="hljs-string">因为我要让父进程能够查看到它开设的子进程的一些基本信息 占用的pid号 运行时间。。。</span><br><span class="hljs-string">所有的进程都会步入僵尸进程</span><br><span class="hljs-string">	父进程不死并且在无限制的创建子进程并且子进程也不结束</span><br><span class="hljs-string">	回收子进程占用的pid号</span><br><span class="hljs-string">		父进程等待子进程运行结束</span><br><span class="hljs-string">		父进程调用join方法</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 孤儿进程</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">子进程存活，父进程意外死亡</span><br><span class="hljs-string">操作系统会开设一个“儿童福利院”专门管理孤儿进程回收相关资源</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>在python中，当子进程设置守护进程以后，如果主进程结束，此时子进程也会立即结束，主进程不会在等待子进程运行完毕。这里设置守护进程必须在子进程启动以前设置，否则报错。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> multiprocessing import Process<br>import time<br><br>def ceshi():<br>	<span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;子进程正在运行&#x27;</span>)<br>	time.sleep(3)<br>	<span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;子进程已经结束&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	P = Process(<span class="hljs-attribute">target</span>=ceshi,)<br>	<span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;主进程正在运行&#x27;</span>)<br>	P.daemon = <span class="hljs-literal">True</span><br>	P.start()<br>	<span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;主进程已经结束&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111009514.png" srcset="/img/loading.gif" lazyload alt="image-20211109111009514"></p>
<p>这里甚至子进程都没有运行出来就结束了（主进程运行速度太快了，子进程刚创建还没来得及运行，主进程就结束了，并直接结束了子进程。）</p>
<p>如果这里主进程sleep1秒的话，则子进程就开始运行了。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111117503.png" srcset="/img/loading.gif" lazyload alt="image-20211109111117503"></p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>多个进程操作同一份数据的时候，会出现数据错乱的问题</p>
<p>针对上述问题，解决方式就是加锁处理:<strong>将并发变成串行，牺牲效率但是保证了数据的安全</strong></p>
<h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">from</span> multiprocessing import Process<br>def write(<span class="hljs-selector-tag">i</span>):<br>	with <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) as f:<br>		f.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">str</span>(i))<br>def <span class="hljs-built_in">read</span>():<br>	with <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) as f:<br>		i=f.<span class="hljs-built_in">read</span>()<br>		return i<br>#定义读和写两个函数<br>def <span class="hljs-built_in">ceshi</span>():<br>	i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">read</span>())<br>	if i == <span class="hljs-number">1</span>:<br>		i -= <span class="hljs-number">1</span><br>		<span class="hljs-built_in">write</span>(i)<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试1判断i=1，则将i-1&#x27;</span>)<br><br>def <span class="hljs-built_in">ceshi2</span>():<br>	i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">read</span>())<br>	if i == <span class="hljs-number">1</span>:<br>		i -= <span class="hljs-number">1</span><br>		<span class="hljs-built_in">write</span>(i)<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试2判断i=1，则将i-1&#x27;</span>)<br>		<br>#两个测试函数分别判断i是否等于<span class="hljs-number">1</span>，如果为<span class="hljs-number">1</span>则修改<br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	i=<span class="hljs-number">1</span><br>	<span class="hljs-built_in">write</span>(i)<br>	#读取文件时先将<span class="hljs-number">1</span>设置为<span class="hljs-number">1</span><br>	P = <span class="hljs-built_in">Process</span>(target=ceshi,)<br>	P2 = <span class="hljs-built_in">Process</span>(target=ceshi2,)<br>	P.<span class="hljs-built_in">start</span>()<br>	P2.<span class="hljs-built_in">start</span>()<br>	P.<span class="hljs-built_in">join</span>()<br>	P2.<span class="hljs-built_in">join</span>()<br>	i = <span class="hljs-built_in">read</span>() #等两个文件操作完再读取文件<br>	<span class="hljs-built_in">print</span>(f<span class="hljs-string">&#x27;主进程已经结束,i的值为&#123;i&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>两个子进程运行时，都会读取判断文件ceshi.txt里面的值是否为1，如果某一个文件先读取，那么只有一个文件能修改到值，那程序无任何问题，但当两个子进程同时读取文件时，就会出现两个进程都判断其值为1且对其进行修改值操作，显然对于程序来说，不应如此。例如火车抢票，此时票数为1，抢到票时火车的票就-1，如果两个人都同时抢票发现这个时候票为1，于是就都会抢票成功，显然这是一个bug，此时应该在上面加上锁。</p>
<p><strong>改为：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process,Lock<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">i</span>):</span><br>	<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>		f.write(<span class="hljs-built_in">str</span>(i))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>():</span><br>	<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>		i=f.read()<br>		<span class="hljs-keyword">return</span> i<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ceshi</span>(<span class="hljs-params">lock</span>):</span><br>		l=run(lock)<br>		<span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>			<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试1判断i=1，则将i-1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ceshi2</span>(<span class="hljs-params">lock</span>):</span><br>		l=run(lock)<br>		<span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>			<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试2判断i=1，则将i-1&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">lock</span>):</span><br>	lock.acquire()<br>	i = <span class="hljs-built_in">int</span>(read())<br>	<span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>		i -= <span class="hljs-number">1</span><br>		write(i)<br>		lock.release()<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>	<span class="hljs-keyword">else</span>:<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	i=<span class="hljs-number">1</span><br>	write(i)<br>	lock = Lock()<br>	P = Process(target=ceshi,args=(lock,))<br>	P2 = Process(target=ceshi2,args=(lock,))<br>	P.start()<br>	P2.start()<br>	P.join()<br>	P2.join()<br>	i = read()<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;主进程已经结束,i的值为<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>从run函数可以看到，此时读和写都从并发改为串行了，此时只能一个一个读然后再写，真正再项目环境可以把读写分开，以免一个人在读数据时其他人都要等着，应该是一个人在写数据时再上锁。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h4 id="队列Queue模块"><a href="#队列Queue模块" class="headerlink" title="队列Queue模块"></a>队列Queue模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">管道:subprocess </span><br><span class="hljs-string">	stdin stdout stderr</span><br><span class="hljs-string">队列:管道+锁</span><br><span class="hljs-string"></span><br><span class="hljs-string">队列:先进先出</span><br><span class="hljs-string">堆栈:先进后出</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Queue<br><br><span class="hljs-comment"># 创建一个队列</span><br>q = Queue(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 括号内可以传数字 标示生成的队列最大可以同时存放的数据量</span><br><br><span class="hljs-comment"># 往队列中存数据</span><br>q.put(<span class="hljs-number">111</span>)<br>q.put(<span class="hljs-number">222</span>)<br>q.put(<span class="hljs-number">333</span>)<br><span class="hljs-comment"># print(q.full())  # 判断当前队列是否满了</span><br><span class="hljs-comment"># print(q.empty())  # 判断当前队列是否空了</span><br>q.put(<span class="hljs-number">444</span>)<br>q.put(<span class="hljs-number">555</span>)<br><span class="hljs-comment"># print(q.full())  # 判断当前队列是否满了</span><br><br><span class="hljs-comment"># q.put(666)  # 当队列数据放满了之后 如果还有数据要放程序会阻塞 直到有位置让出来 不会报错</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">存取数据 存是为了更好的取</span><br><span class="hljs-string">千方百计的存、简单快捷的取</span><br><span class="hljs-string"></span><br><span class="hljs-string">同在一个屋檐下</span><br><span class="hljs-string">差距为何那么大</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 去队列中取数据</span><br>v1 = q.get()<br>v2 = q.get()<br>v3 = q.get()<br>v4 = q.get()<br>v5 = q.get()<br><span class="hljs-comment"># print(q.empty())</span><br><span class="hljs-comment"># V6 = q.get_nowait()  # 没有数据直接报错queue.Empty</span><br><span class="hljs-comment"># v6 = q.get(timeout=3)  # 没有数据之后原地等待三秒之后再报错  queue.Empty</span><br><span class="hljs-keyword">try</span>:<br>    v6 = q.get(timeout=<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(v6)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一滴都没有了!&#x27;</span>)<br><br><span class="hljs-comment"># # v6 = q.get()  # 队列中如果已经没有数据的话 get方法会原地阻塞</span><br><span class="hljs-comment"># print(v1, v2, v3, v4, v5, v6)</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">q.full()</span><br><span class="hljs-string">q.empty()</span><br><span class="hljs-string">q.get_nowait()</span><br><span class="hljs-string">在多进程的情况下是不精确</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Queue, Process<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">研究思路</span><br><span class="hljs-string">    1.主进程跟子进程借助于队列通信</span><br><span class="hljs-string">    2.子进程跟子进程借助于队列通信</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">q</span>):</span><br>    q.put(<span class="hljs-string">&#x27;我是23号技师 很高兴为您服务&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">q</span>):</span><br>    <span class="hljs-built_in">print</span>(q.get())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = Queue()<br>    p = Process(target=producer,args=(q,))<br>    p1 = Process(target=consumer,args=(q,))<br>    p.start()<br>    p1.start()<br></code></pre></td></tr></table></figure>

<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">生产者:生产/制造东西的</span><br><span class="hljs-string">消费者:消费/处理东西的</span><br><span class="hljs-string">该模型除了上述两个之外还需要一个媒介</span><br><span class="hljs-string">	生活中的例子做包子的将包子做好后放在蒸笼(媒介)里面，买包子的取蒸笼里面拿</span><br><span class="hljs-string">	厨师做菜做完之后用盘子装着给你消费者端过去</span><br><span class="hljs-string">	生产者和消费者之间不是直接做交互的，而是借助于媒介做交互</span><br><span class="hljs-string">	</span><br><span class="hljs-string">生产者(做包子的) + 消息队列(蒸笼) + 消费者(吃包子的)</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue, JoinableQueue<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">name,food,q</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        data = <span class="hljs-string">&#x27;%s生产了%s%s&#x27;</span>%(name,food,i)<br>        <span class="hljs-comment"># 模拟延迟</span><br>        time.sleep(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-comment"># 将数据放入 队列中</span><br>        q.put(data)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">name,q</span>):</span><br>    <span class="hljs-comment"># 消费者胃口很大 光盘行动</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        food = q.get()  <span class="hljs-comment"># 没有数据就会卡住</span><br>        <span class="hljs-comment"># 判断当前是否有结束的标识</span><br>        <span class="hljs-comment"># if food is None:break</span><br>        time.sleep(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s吃了%s&#x27;</span>%(name,food))<br>        q.task_done()  <span class="hljs-comment"># 告诉队列你已经从里面取出了一个数据并且处理完毕了</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># q = Queue()</span><br>    q = JoinableQueue()<br>    p1 = Process(target=producer,args=(<span class="hljs-string">&#x27;大厨egon&#x27;</span>,<span class="hljs-string">&#x27;包子&#x27;</span>,q))<br>    p2 = Process(target=producer,args=(<span class="hljs-string">&#x27;马叉虫tank&#x27;</span>,<span class="hljs-string">&#x27;泔水&#x27;</span>,q))<br>    c1 = Process(target=consumer,args=(<span class="hljs-string">&#x27;春哥&#x27;</span>,q))<br>    c2 = Process(target=consumer,args=(<span class="hljs-string">&#x27;新哥&#x27;</span>,q))<br>    p1.start()<br>    p2.start()<br>    <span class="hljs-comment"># 将消费者设置成守护进程</span><br>    c1.daemon = <span class="hljs-literal">True</span><br>    c2.daemon = <span class="hljs-literal">True</span><br>    c1.start()<br>    c2.start()<br>    p1.join()<br>    p2.join()<br>    <span class="hljs-comment"># 等待生产者生产完毕之后 往队列中添加特定的结束符号</span><br>    <span class="hljs-comment"># q.put(None)  # 肯定在所有生产者生产的数据的末尾</span><br>    <span class="hljs-comment"># q.put(None)  # 肯定在所有生产者生产的数据的末尾</span><br>    q.join()  <span class="hljs-comment"># 等待队列中所有的数据被取完再执行往下执行代码</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    JoinableQueue 每当你往该队列中存入数据的时候 内部会有一个计数器+1</span><br><span class="hljs-string">    没当你调用task_done的时候 计数器-1</span><br><span class="hljs-string">    q.join() 当计数器为0的时候 才往后运行</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 只要q.join执行完毕 说明消费者已经处理完数据了  消费者就没有存在的必要了</span><br><br></code></pre></td></tr></table></figure>

<h1 id="线程理论"><a href="#线程理论" class="headerlink" title="线程理论"></a>线程理论</h1><ul>
<li><p>什么是线程</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">进程:资源单位</span><br><span class="hljs-string">线程:执行单位</span><br><span class="hljs-string"></span><br><span class="hljs-string">将操作系统比喻成一个大的工厂</span><br><span class="hljs-string">那么进程就相当于工厂里面的车间</span><br><span class="hljs-string">而线程就是车间里面的流水线</span><br><span class="hljs-string"></span><br><span class="hljs-string">每一个进程肯定自带一个线程</span><br><span class="hljs-string"></span><br><span class="hljs-string">再次总结:</span><br><span class="hljs-string">	进程:资源单位(起一个进程仅仅只是在内存空间中开辟一块独立的空间)</span><br><span class="hljs-string">	线程:执行单位(真正被cpu执行的其实是进程里面的线程，线程指的就是代码的执行过程，执行代码中所需要使用到的资源都找所在的进程索要)</span><br><span class="hljs-string">	</span><br><span class="hljs-string">进程和线程都是虚拟单位，只是为了我们更加方便的描述问题</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>为何要有线程</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">开设进程</span><br><span class="hljs-string">	1.申请内存空间	耗资源</span><br><span class="hljs-string">	2.“拷贝代码”   耗资源</span><br><span class="hljs-string">开线程</span><br><span class="hljs-string">	一个进程内可以开设多个线程，在用一个进程内开设多个线程无需再次申请内存空间操作</span><br><span class="hljs-string"></span><br><span class="hljs-string">总结:</span><br><span class="hljs-string">	开设线程的开销要远远的小于进程的开销</span><br><span class="hljs-string">	同一个进程下的多个线程数据是共享的!!!</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>我们要开发一款文本编辑器<br>	获取用户输入的功能<br>  实时展示到屏幕的功能<br>  自动保存到硬盘的功能<br>针对上面这三个功能，开设进程还是线程合适？？？<br>	开三个线程处理上面的三个功能更加的合理<br></code></pre></td></tr></table></figure></li>
<li><p>如何使用</p>
</li>
</ul>
<h2 id="开启线程的两种方式"><a href="#开启线程的两种方式" class="headerlink" title="开启线程的两种方式"></a>开启线程的两种方式</h2><h3 id="导入模块式"><a href="#导入模块式" class="headerlink" title="导入模块式"></a>导入模块式</h3><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211111094637428.png" srcset="/img/loading.gif" lazyload alt="image-20211111094637428"></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import Thread<br>duxiangming=<span class="hljs-constructor">Thread(<span class="hljs-params">target</span>=<span class="hljs-params">ceshi</span>,<span class="hljs-params">args</span>=(<span class="hljs-params">i</span>,)</span>)<br></code></pre></td></tr></table></figure>

<h3 id="集成类式"><a href="#集成类式" class="headerlink" title="集成类式"></a>集成类式</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-class"><span class="hljs-keyword">class</span> ceshi(<span class="hljs-type">Thread</span>):</span><br><span class="hljs-class">    def run(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        print(&#x27;<span class="hljs-title">g&#x27;</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">if __name__ == &#x27;__main__&#x27;:</span><br><span class="hljs-class">    for i in range(5):</span><br><span class="hljs-class">        cs = ceshi()</span><br><span class="hljs-class">        cs.start()</span><br></code></pre></td></tr></table></figure>

<h2 id="线程与进程区别"><a href="#线程与进程区别" class="headerlink" title="线程与进程区别"></a>线程与进程区别</h2><p>在使用方法上，例如join，互斥锁，join方法，queue消息队列都与进程一致。两者的区别在于线程无需开辟新的内存空间，进程的创建需要开启新的内存空间，因此线程相较于进程来讲，其创建的开销要小很多，但是由于cpython（python用的最多的解释器）的GIL解释器锁的原因，python线程无法实现真正的多线程（利用多核），只能单核使用，但由于其线程创建开销少，所以还是适用于密集型i/o程序，如果是密集型运算程序，还是需要使用多进程。</p>
<h3 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">python解释器其实有多个版本<br>	Cpython<br>	Jpython<br>	Pypypython<br>但是普遍使用的都是CPython解释器<br><br>在CPython解释器中GIL是一把互斥锁，用来阻止同一个进程下的多个线程的同时执行<br>	同一个进程下的多个线程无法利用多核优势！！！<br>	疑问:python的多线程是不是一点用都没有？？？无法利用多核优势<br>	<br>因为cpython中的内存管理不是线程安全的<br>内存管理(垃圾回收机制)<br>	<span class="hljs-number">1</span>.应用计数<br>	<span class="hljs-number">2</span>.标记清楚<br>	<span class="hljs-number">3</span>.分代回收<br>	<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>重点:<br>	<span class="hljs-number">1</span>.GIL不是python的特点而是CPython解释器的特点<br>	<span class="hljs-number">2</span>.GIL是保证解释器级别的数据的安全<br>	<span class="hljs-number">3</span>.GIL会导致同一个进程下的多个线程的无法同时执行即无法利用多核优势(******)<br>	<span class="hljs-number">4</span>.针对不同的数据还是需要加不同的锁处理 <br>	<span class="hljs-number">5</span>.解释型语言的通病:同一个进程下多个线程无法利用多核优势<br></code></pre></td></tr></table></figure>

<h3 id="GIL与普通互斥锁的区别"><a href="#GIL与普通互斥锁的区别" class="headerlink" title="GIL与普通互斥锁的区别"></a>GIL与普通互斥锁的区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread,Lock<br><span class="hljs-keyword">import</span> time<br><br><br>mutex = Lock()<br>money = <span class="hljs-number">100</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>():</span><br>    <span class="hljs-keyword">global</span> money<br>    <span class="hljs-comment"># with mutex:</span><br>    <span class="hljs-comment">#     tmp = money</span><br>    <span class="hljs-comment">#     time.sleep(0.1)</span><br>    <span class="hljs-comment">#     money = tmp -1</span><br>    mutex.acquire()<br>    tmp = money<br>    time.sleep(<span class="hljs-number">0.1</span>)  <span class="hljs-comment"># 只要你进入IO了 GIL会自动释放</span><br>    money = tmp - <span class="hljs-number">1</span><br>    mutex.release()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        t = Thread(target=task)<br>        t.start()<br>        t_list.append(t)<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> t_list:<br>        t.join()<br>    <span class="hljs-built_in">print</span>(money)<br><br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">100个线程起起来之后  要先去抢GIL</span><br><span class="hljs-string">我进入io GIL自动释放 但是我手上还有一个自己的互斥锁</span><br><span class="hljs-string">其他线程虽然抢到了GIL但是抢不到互斥锁 </span><br><span class="hljs-string">最终GIL还是回到你的手上 你去操作数据</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="进程池与线程池"><a href="#进程池与线程池" class="headerlink" title="进程池与线程池"></a>进程池与线程池</h3><p>先回顾之前TCP服务端实现并发的效果是怎么玩的</p>
<p>每来一个人就开设一个进程或者线程去处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">无论是开设进程也好还是开设线程也好 是不是都需要消耗资源</span><br><span class="hljs-string">只不过开设线程的消耗比开设进程的稍微小一点而已</span><br><span class="hljs-string"></span><br><span class="hljs-string">我们是不可能做到无限制的开设进程和线程的 因为计算机硬件的资源更不上！！！</span><br><span class="hljs-string">硬件的开发速度远远赶不上软件呐</span><br><span class="hljs-string"></span><br><span class="hljs-string">我们的宗旨应该是在保证计算机硬件能够正常工作的情况下最大限度的利用它</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 池的概念</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">什么是池?</span><br><span class="hljs-string">	池是用来保证计算机硬件安全的情况下最大限度的利用计算机</span><br><span class="hljs-string">	它降低了程序的运行效率但是保证了计算机硬件的安全 从而让你写的程序能够正常运行</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-comment"># pool = ThreadPoolExecutor(5)  # 池子里面固定只有五个线程</span><br><span class="hljs-comment"># 括号内可以传数字 不传的话默认会开设当前计算机cpu个数五倍的线程</span><br>pool = ProcessPoolExecutor(<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 括号内可以传数字 不传的话默认会开设当前计算机cpu个数进程</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">池子造出来之后 里面会固定存在五个线程</span><br><span class="hljs-string">这个五个线程不会出现重复创建和销毁的过程</span><br><span class="hljs-string">池子造出来之后 里面会固定的几个进程</span><br><span class="hljs-string">这个几个进程不会出现重复创建和销毁的过程</span><br><span class="hljs-string"></span><br><span class="hljs-string">池子的使用非常的简单</span><br><span class="hljs-string">你只需要将需要做的任务往池子中提交即可 自动会有人来服务你</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">print</span>(n,os.getpid())<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> n**n<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_back</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call_back&gt;&gt;&gt;:&#x27;</span>,n.result())<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">任务的提交方式</span><br><span class="hljs-string">    同步:提交任务之后原地等待任务的返回结果 期间不做任何事</span><br><span class="hljs-string">    异步:提交任务之后不等待任务的返回结果 执行继续往下执行</span><br><span class="hljs-string">        返回结果如何获取？？？</span><br><span class="hljs-string">        异步提交任务的返回结果 应该通过回调机制来获取</span><br><span class="hljs-string">        回调机制</span><br><span class="hljs-string">            就相当于给每个异步任务绑定了一个定时炸弹</span><br><span class="hljs-string">            一旦该任务有结果立刻触发爆炸</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># pool.submit(task, 1)  # 朝池子中提交任务  异步提交</span><br>    <span class="hljs-comment"># print(&#x27;主&#x27;)</span><br>    t_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <span class="hljs-comment"># 朝池子中提交20个任务</span><br>        <span class="hljs-comment"># res = pool.submit(task, i)  # &lt;Future at 0x100f97b38 state=running&gt;</span><br>        res = pool.submit(task, i).add_done_callback(call_back)<br>        <span class="hljs-comment"># print(res.result())  # result方法   同步提交</span><br>        <span class="hljs-comment"># t_list.append(res)</span><br>    <span class="hljs-comment"># 等待线程池中所有的任务执行完毕之后再继续往下执行</span><br>    <span class="hljs-comment"># pool.shutdown()  # 关闭线程池  等待线程池中所有的任务运行完毕</span><br>    <span class="hljs-comment"># for t in t_list:</span><br>    <span class="hljs-comment">#     print(&#x27;&gt;&gt;&gt;:&#x27;,t.result())  # 肯定是有序的</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">程序有并发变成了串行</span><br><span class="hljs-string">任务的为什么打印的是None</span><br><span class="hljs-string">res.result() 拿到的就是异步提交的任务的返回结果</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor<br>pool = ProcessPoolExecutor(<span class="hljs-number">5</span>)<br>pool.submit(task, i).add_done_callback(call_back)<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/python/">python</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/python/">python</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/23/%E5%A2%9E%E5%8A%A0Swap%E5%88%86%E5%8C%BA_hexo/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">增加Swap分区</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/18/IO%E6%A8%A1%E5%9E%8B_hexo/">
                        <span class="hidden-mobile">IO模型</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
