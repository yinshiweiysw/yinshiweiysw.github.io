<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2021/12/23/HTTP_hexo/"/>
    <url>/2021/12/23/HTTP_hexo/</url>
    
    <content type="html"><![CDATA[<p>一、http访问过程：</p><p>1.客户端(用户)通过浏览器输入网站的url</p><p>2.客户端通过dns解析到网站的ip地址。</p><p>3.客户端向服务端发起tcp连接（三次握手）</p><p>4.客户端发起http请求</p><p>5.服务端响应http请求</p><p>6.客户端发起断开tcp连接（四次挥手）</p><p>二、DNS解析过程：</p><ol><li>在浏览器中输入<a href="http://www.qq.com域名,操作系统会先检查自己本地的hosts文件是否有这个网址映射关系,如果有,就先调用这个ip地址映射,完成域名解析./">www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a></li><li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机./">www.qq.com主机。</a></li><li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。<br> 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</li></ol><p>递归于迭代：</p><p><strong>（1）递归查询</strong><br>递归查询是一种DNS 服务器的查询模式，在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。<br><strong>（2）迭代查询</strong><br>DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果</p><p>三、tcp连接</p><p>三次握手</p><p>客户端 -》请求包连接syn=1 seq=x 服务端<br>服务端 -》响应客户端syn=1 ack=x+1 seq=y 客户端<br>客户端 —》 建立连接 ack=y+1 seq=x+1 服务端</p><p>三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p><p>第一次握手：客户端将SYN请求包（位码为SYN=1、随机值seq=x）发送给服务器端。客户端进入SYN_SENT状态，等待服务器端确认。</p><p>第二次握手：服务器端收到SYN请求包后由位码SYN=1知道客户端请求建立连接，并将SYN请求包(SYN=1)+ACK确认包（位码ACK=1，响应值ack=x+1，随机值seq=y）发送给客户端以确认连接请求。服务器端进入SYN_RCVD状态。</p><p>第三次握手：客户端收到确认后检查确认包（ack是否为x+1，ACK是否为1），如果正确则将ACK确认包(位码ACK=1,响应值ack=y+1)发送给服务器端。服务器端检查确认，如果正确则连接建立成功。客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231043697.jpeg" alt="image.png"></p><p>四次挥手</p><p>客户端 -》断开请求 fin=1 seq=x -》服务端<br>服务端 -&gt; 响应断开 fin=1 ack=x+1 seq=y -&gt;客户端<br>服务端 -》断开连接 fin=1 ack=x+1 seq=z -&gt;客户端<br>客户端 -》确认断开 fin=1 ack=z+1 seq=n -&gt; 服务端</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231043280.jpeg" alt="image.png"></p><p><strong>第一次挥手</strong></p><p>TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。</p><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），</p><p>此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p><p><strong>第二次</strong>挥手</p><p>服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。</p><p>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器</p><p>通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个</p><p>状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p><p><strong>第三次</strong>挥手</p><p>服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。</p><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，</p><p>此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p><p><strong>第四次</strong>挥手</p><p>客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。</p><p>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时</p><p>TCP连接还没有释放，必须经过2**MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p><p>用户访问网站整体流程：<br>1.客户端发起http请求，请求会先抵达前端的防火墙<br>2.防火墙识别用户身份，通过内部交换机将正常的请求通过tcp连接负载均衡，传递用户的http请求<br>3.负载接收到请求，会根据请求的内容进行下发任务，通过tcp连接web服务器，发送用户的http请求<br>4.web接收到用户的http请求后，会根据用户请求的内容进行解析，解析分为如下：<br>静态请求:由web服务器向nfs建立tcp连接，获取对应的图片，最后返回给负衡（负载均衡-&gt;防火墙-&gt;用户)<br>动态请求:有web向后端的动态程序建立Tcp连接，将用户的动态http请求传递态程序-&gt;由动态程序进行解析<br>5.动态程序在解析的过程中，如果碰到查询数据库的请求，则优先和缓存建立tcp接，然后缓存服务发起http的查询<br>6.如果缓存没有对应的数据，动态程序再次向数据库建立tcp的连接，然后发起查作。<br>7.由数据库返回-&gt;动态程序-&gt;缓存-&gt;web服务-&gt;负载均衡-&gt;防火墙-&gt;用户。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NFS</title>
    <link href="/2021/12/23/NFS_hexo/"/>
    <url>/2021/12/23/NFS_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>network file system<br>通过局域网络让不同的主机系统之间可以共享文件和目录，主要通过linux系统进行共享，NFS服务可以提供远程存储服务，一般应用于用于内网小型集群架构中，其远程传输基于RPC（远程过程调用）。其作用为实现多台服务器存储共享以及实现多台服务器之间数据一致性。</p><h1 id="2-实现原理："><a href="#2-实现原理：" class="headerlink" title="2.实现原理："></a>2.实现原理：</h1><p>NFS守护进程<br>RPC.nfsd<br>守护进程,管理NFS服务<br>RPC.mount<br>管理nfs的文件系统<br>本地文件操作方式<br>1.当用户执行mkdir命令，该命令会通过shell解释器翻译给内核，由内核解析完成后驱动硬件，完成相应的操作。<br>NFS实现原理<br>1.用户进程访问NFS客户端，使用不同的函数对数据进行处理<br>2.NFS客户端通过TCP/IP的方式传递给NFS服务端<br>3.NFS服务器端收到请求后，会先调用portmap进程进行端口映射<br>4.nfsd进程用于判断NFS客户端是否拥有权限连接NFS服务器端<br>5.RPC.mount进程判断客户端是否有对应的权限进行验证<br>6.idmap进程实现用户映射和压缩<br>7.最后NFS服务端会将对应请求的函数转换为本地能识别的命令，传递到内核，由内核驱动硬件。<br>rpc是一个远程过程调用，那么使用nfs必须有rpc服务</p><h1 id="3-nfs组件"><a href="#3-nfs组件" class="headerlink" title="3.nfs组件"></a>3.nfs组件</h1><p>安装NFS服务，需要安装两个软件，分别是：</p><ul><li><strong>RPC主程序：rpcbind</strong><br>  NFS 其实可以被视为一个 RPC 服务，因为启动任何一个 RPC 服务之前，我们都需要做好 port 的对应 (mapping) 的工作才行，这个工作其实就是『 rpcbind 』这个服务所负责的！也就是说， 在启动任何一个 RPC 服务之前，我们都需要启动 rpcbind 才行！ (在 CentOS 5.x 以前这个软件称为 portmap，在 CentOS 6.x 之后才称为 rpcbind 的！)。</li><li><strong>NFS主程序：nfs-utils</strong><br>  就是提供 rpc.nfsd 及 rpc.mountd 这两个 NFS daemons 与其他相关 documents 与说明文件、执行文件等的软件！这个就是 NFS 服务所需要的主要软件。</li><li></li></ul><p><strong>NFS的相关文件：</strong></p><ul><li>主要配置文件：/etc/exports<br>  这是 NFS 的主要配置文件了。该文件是空白的，有的系统可能不存在这个文件，主要手动建立。NFS的配置一般只在这个文件中配置即可。</li><li>NFS 文件系统维护指令：/usr/sbin/exportfs<br>  这个是维护 NFS 分享资源的指令，可以利用这个指令重新分享 /etc/exports 变更的目录资源、将 NFS Server 分享的目录卸除或重新分享。</li><li>分享资源的登录档：/var/lib/nfs/*tab<br>  在 NFS 服务器的登录文件都放置到 /var/lib/nfs/ 目录里面，在该目录下有两个比较重要的登录档， 一个是 etab ，主要记录了 NFS 所分享出来的目录的完整权限设定值；另一个 xtab 则记录曾经链接到此 NFS 服务器的相关客户端数据。</li><li>客户端查询服务器分享资源的指令：/usr/sbin/showmount<br>  这是另一个重要的 NFS 指令。exportfs 是用在 NFS Server 端，而 showmount 则主要用在 Client 端。showmount 可以用来察看 NFS 分享出来的目录资源。</li></ul><h1 id="4-服务实践"><a href="#4-服务实践" class="headerlink" title="4.服务实践"></a>4.服务实践</h1><p>首先服务器端需要启动nfs-server和rpcbind，客户端也需要启动rpcbind。</p><h2 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h2><p>安装nfs<br>yum -y install nfs-utils rpcbind</p><p>配置<br>主配置文件/etc/exports,默认空<br>格式：<br>共享目录路径 允许访问的nfs客户端（共享权限参数）<br>共享目录路径： 服务器本地目录路径<br>允许访问的客户端：<br>ip or 域名<br>网段： 172.16.1.0/24 主机： 172.16.1.1/32 域名：*.edu.mage.com<br>权限：<br>rw 读写权限 ***<br>ro 只读权限<br>root_squash 当nfs客户端以root管理员访问时，映射为nfs服务器的匿名用户<br>no_root_squash 当nfs客户端以root管理员访问时，映射为nfs服务器的ROOT管理员用户<br>all_squash 无论nfs客户端使用什么账户访问，均映射为nfs服务器的匿名用户 ***<br>sync 同时将数据写入内存与硬盘中，保证不丢死数据<br>async 优先将数据保存到内存中，然后再写入硬盘，这样效率更高，但可能会丢失数据。<br>async 优先将数据保存到内存中，然后再写入硬盘，这样效率更高，但可能会丢失数据。<br>anonuid 配置all_aquash使用，指定nfs的用户uid，必须存在系统 ***<br>anongid 配置all_aquash使用，指定nfs的用户gid，必须存在系统 ***</p><p>例子（/etc/exports）：<br>/data 172.16.1.0/24(rw),0.0.0.0/0(ro)<br>/backup 192.1.1.1/32(rw)<br>/backuo *.edu.com(rw)</p><p>4.创建环境<br>mkdir /data<br>chown -R nfsnobody.nfsnobody /data</p><p>5.启动服务<br>systemctl start nfs-server rpcbind<br>systemctl status nfs-server rpcbind</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端挂载<br>1.安装工具 安装nfs-utils 并启动rpcbind<br>yum -y install rpcbind nfs-utils</p><p>2.客户端使用 showmount -e 查看远程服务器rpc提供的可挂载nfs信息</p><p>showmount -e 192.168.1.1<br>3.在nfs创建一个挂载目录，然后使用mount命令挂载。<br>mount -t nfs 192.168.65.131:/backup /mnt</p><p>挂载时需注意挂载权限。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux用户行为日志审计</title>
    <link href="/2021/12/23/Linux%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1_hexo/"/>
    <url>/2021/12/23/Linux%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1_hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="配置调试"><a href="#配置调试" class="headerlink" title="配置调试"></a>配置调试</h2><p>1.创建用户审计文件存放目录和审计日志文件 ；<br>mkdir -p /var/log/usermonitor/</p><p>2.创建用户审计日志文件；<br>echo usermonitor &gt;/var/log/usermonitor/usermonitor.log</p><p>3.将日志文件所有者赋予一个最低权限的用户；<br>chown nobody:nobody /var/log/usermonitor/usermonitor.log</p><p>4.给该日志文件赋予所有人的写权限；<br>chmod 002 /var/log/usermonitor/usermonitor.log</p><p>5.设置文件权限,使所有用户对该文件只有追加权限 ；<br>chattr +a /var/log/usermonitor/usermonitor.log<br>6.编辑/etc/profile文件，添加如下任意脚本命令；</p><h3 id="代码1："><a href="#代码1：" class="headerlink" title="代码1："></a>代码1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs export">export HISTORY_FILE=/var/log/usermonitor/usermonitor.log<br>export PROMPT_COMMAND=&#x27;&#123; date &quot;+%y-%m-%d %T ##### $(who am i |awk &quot;&#123;print \$1\&quot; \&quot;\$2\&quot; \&quot;\$5&#125;&quot;)  #### $(id|awk &quot;&#123;print \$1&#125;&quot;) #### $(history 1 | &#123; read x cmd; echo &quot;$cmd&quot;; &#125;)&quot;; &#125; &gt;&gt;$HISTORY_FILE&#x27;<br></code></pre></td></tr></table></figure><h3 id="代码2："><a href="#代码2：" class="headerlink" title="代码2："></a>代码2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HISTTIMEFORMAT">HISTTIMEFORMAT=&quot;%Y%m%d-%H%M%S: &quot;<br>export HISTTIMEFORMAT<br><br>export HISTORY_FILE=/var/log/usermonitor/usermonitor.log<br>export PROMPT_COMMAND=&#x27;&#123; command=$(history 1 | &#123; read x y; echo $y; &#125;); logger -p local1.notice -t bash -i &quot;user=$USER,ppid=$PPID,from=$SSH_CLIENT,pwd=$PWD,command:$command&quot;; &#125; &gt;&gt;$HISTORY_FILE&#x27;<br></code></pre></td></tr></table></figure><h3 id="代码3："><a href="#代码3：" class="headerlink" title="代码3："></a>代码3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs export">export HISTORY_FILE=/var/log/usermonitor/usermonitor.log<br>PROMPT_COMMAND=&#x27;&#123; date &quot;+%Y-%m-%d %T ##### USER:$USER IP:$SSH_CLIENT PS:$SSH_TTY ppid=$PPID pwd=$PWD  #### $(history 1 | &#123; read x cmd; echo &quot;$cmd&quot;; &#125;)&quot;;&#125; &gt;&gt;$HISTORY_FILE&#x27;<br></code></pre></td></tr></table></figure><h3 id="使配置生效"><a href="#使配置生效" class="headerlink" title="使配置生效"></a>使配置生效</h3><p>source /etc/profile</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zabbix</title>
    <link href="/2021/12/23/Zabbix_hexo/"/>
    <url>/2021/12/23/Zabbix_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Zabbix简介："><a href="#Zabbix简介：" class="headerlink" title="Zabbix简介："></a>Zabbix简介：</h1><p>Zabbix是一款监控软件，用于监控linux服务器，是当下最热门的服务器监控解决方案。其监控方式可分为：客户端，SNMP,JMX(JAVA虚拟机监控)，IPMI(服务器硬件监控)，一般情况下客户端监控比较常见，也就是在需要监控的主机上安装zabbix_agent程序，服务器端定时去向客户端拉取数据。当然除了服务器拉取客户端的数据以外，客户端也可以定时主动把数据推向服务器，这样在监控主机过多时可以缓解服务器端的压力，这种模式被称为主动模式。</p><p>Zabbix在使用C/S架构进行监控时，此时需要用到的组件有：zabbix-server,zabbix-agent,zabbix-gui(提供图形管理页面)。由于zabbix-server和gui需要用到数据库，而gui管理页面本身基于php。所以在部署时还需要安装mysql（or other sql）和php-fpm。而snmp主要用于无法安装agent端的设备，例如路由器，交换机等，但因其snmp是TCP/IP二层协议，一般都支持snmp，便可用这种方式监控。</p><h1 id="zabbix安装："><a href="#zabbix安装：" class="headerlink" title="zabbix安装："></a>zabbix安装：</h1><h2 id="zabbix依赖："><a href="#zabbix依赖：" class="headerlink" title="zabbix依赖："></a>zabbix依赖：</h2><p>web服务器+php+数据库:</p><p>nginx(apache)+php+mysql(other sql)</p><p>zabbix分为服务器端，客户端，gui（web端），如果监控的主机较多，还会用到proxy端（分布式监控）</p><p>一般安装分为两种方式源码和rpm，还有一种是docker</p><h2 id="源码安装："><a href="#源码安装：" class="headerlink" title="源码安装："></a>源码安装：</h2><p><a href="https://www.zabbix.com/download_sources">https://www.zabbix.com/download_sources</a> 下载源码包</p><p>tar -zxvf zabbix-5.2.0.tar.gz</p><p>创建用户帐号：</p><p>groupadd –system zabbix</p><p>useradd –system -g zabbix -d /usr/lib/zabbix -s /sbin/nologin -c “Zabbix Monitoring System” zabbix</p><p>创建家目录</p><p>mkdir -m u=rwx,g=rwx,o= -p /usr/lib/zabbix</p><p>chown zabbix:zabbix /usr/lib/zabbix</p><p>安装：</p><p>依赖安装：</p><p>yum -y install curl-devel libevent-devel net-snmp-devel mysql-devel</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>要查看所有受支持的配置选项，请在提取的Zabbix源目录中运行：</p><p>./configure –help</p><p>要为Zabbix服务器和代理配置源，您可以运行以下命令：</p><p>./configure –enable-server –enable-agent –with-mysql –enable-ipv6 –with-net-snmp –with-libcurl –with-libxml2</p><p>要为Zabbix服务器（使用PostgreSQL等）配置源，可以运行：</p><p>./configure –enable-server –with-postgresql –with-net-snmp</p><p>要配置Zabbix代理的源（使用SQLite等），可以运行：</p><p>./configure –prefix=/usr –enable-proxy –with-net-snmp –with-sqlite3 –with-ssh2</p><p>要为Zabbix代理配置源，可以运行：</p><p>./configure –enable-agent</p><p>或者，对于Zabbix代理2：</p><p>./configure –enable-agent2</p><p>编译Zabbix代理2需要Go版本1.13或更高版本。有关安装说明，请参阅golang.org。</p><p>官方文档：<a href="https://www.zabbix.com/documentation/current/manual/installation/install">https://www.zabbix.com/documentation/current/manual/installation/install</a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>我这里agent和server都在一台服务器，就使用参数安装：</p><p>./configure –enable-server –enable-agent –with-mysql –enable-ipv6 –with-net-snmp –with-libcurl –with-libxml2 –prefix=/usr/local/zabbix</p><p>导入数据库</p><p>#先安装好mysql</p><p>shell&gt; mysql -uroot -p</p><p>mysql&gt; create database zabbix character set utf8 collate utf8_bin;</p><p>mysql&gt; create user ‘zabbix‘@’localhost’ identified by ‘’;</p><p>mysql&gt; grant all privileges on zabbix.* to ‘zabbix‘@’localhost’;</p><p>mysql&gt; quit;</p><p>shell&gt; cd database/mysql</p><p>shell&gt; mysql -uzabbix -p zabbix &lt; schema.sql</p><p>stop here if you are creating database for Zabbix proxy</p><p>shell&gt; mysql -uzabbix -p zabbix &lt; images.sql</p><p>shell&gt; mysql -uzabbix -p zabbix &lt; data.sql</p><p>这几个文件在源码包的database/mysql里面，路径应为</p><p>zabbix-5.2.5/database/mysql</p><p>非mysql请参考官方文档:<a href="https://www.zabbix.com/documentation/current/manual/appendix/install/db_scripts">https://www.zabbix.com/documentation/current/manual/appendix/install/db_scripts</a></p><p>导入好数据库以后此时可以将zabbix配置文件指定到数据库就可以启动了</p><p>zabbix_agent.conf:</p><p>一般agent只用指定server和serveractive即可</p><p>但是如果server和agent位于同一服务器也不用设置，应其默认为127.0.0.1</p><p>（这里的serveractive是zabbix——agent主动模式的服务器地址）</p><p>zabbix_server.conf:</p><p>DBHost=192.168.34.136</p><p>DBName=zabbixnew</p><p>DBUser=root</p><p>DBPassword=admin</p><p>配置完就可以启动zabbix_agent和zabbix_server了</p><p>./sbin/zabbix_agentd</p><p>./sbin/zabbix_server</p><p>如启动有问题可以看日志，默认编译安装应在/tmp/zabbix_agentd(server).conf</p><p>也可以将zabbix写入systemd配置文件用systemctl启动</p><p>/usr/lib/systemd/system/zabbix-server.service</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[Unit]<br><br><span class="hljs-attribute">Description</span>=Zabbix<span class="hljs-built_in"> Server</span><br><span class="hljs-built_in"></span><br><span class="hljs-attribute">After</span>=syslog.target<br><br><span class="hljs-attribute">After</span>=network.target<br><br><span class="hljs-attribute">After</span>=mysql.service<br><br><span class="hljs-attribute">After</span>=mysqld.service<br><br><span class="hljs-attribute">After</span>=mariadb.service<br><br><span class="hljs-attribute">After</span>=postgresql.service<br><br><span class="hljs-attribute">After</span>=pgbouncer.service<br><br><span class="hljs-attribute">After</span>=postgresql-9.4.service<br><br><span class="hljs-attribute">After</span>=postgresql-9.5.service<br><br><span class="hljs-attribute">After</span>=postgresql-9.6.service<br><br><span class="hljs-attribute">After</span>=postgresql-10.service<br><br><span class="hljs-attribute">After</span>=postgresql-11.service<br><br><span class="hljs-attribute">After</span>=postgresql-12.service<br><br>[Service]<br><br><span class="hljs-attribute">Environment</span>=<span class="hljs-string">&quot;CONFFILE=/etc/zabbix/zabbix_server.conf&quot;</span><br><br><span class="hljs-attribute">EnvironmentFile</span>=-/etc/sysconfig/zabbix-server<br><br><span class="hljs-attribute">Type</span>=forking<br><br><span class="hljs-attribute">Restart</span>=on-failure<br><br><span class="hljs-attribute">PIDFile</span>=/run/zabbix/zabbix_server.pid<br><br><span class="hljs-attribute">KillMode</span>=control-group<br><br><span class="hljs-attribute">ExecStart</span>=/usr/sbin/zabbix_server -c <span class="hljs-variable">$CONFFILE</span><br><br><span class="hljs-attribute">ExecStop</span>=/bin/kill -SIGTERM <span class="hljs-variable">$MAINPID</span><br><br><span class="hljs-attribute">RestartSec</span>=10s<br><br><span class="hljs-attribute">TimeoutSec</span>=0<br><br>[Install]<br><br><span class="hljs-attribute">WantedBy</span>=multi-user.target<br><br>/usr/lib/systemd/system/zabbix-agent.service<br><br>[Unit]<br><br><span class="hljs-attribute">Description</span>=Zabbix Agent<br><br><span class="hljs-attribute">After</span>=syslog.target<br><br><span class="hljs-attribute">After</span>=network.target<br><br>[Service]<br><br><span class="hljs-attribute">Environment</span>=<span class="hljs-string">&quot;CONFFILE=/etc/zabbix/zabbix_agentd.conf&quot;</span><br><br><span class="hljs-attribute">EnvironmentFile</span>=-/etc/sysconfig/zabbix-agent<br><br><span class="hljs-attribute">Type</span>=forking<br><br><span class="hljs-attribute">Restart</span>=on-failure<br><br><span class="hljs-attribute">PIDFile</span>=/run/zabbix/zabbix_agentd.pid<br><br><span class="hljs-attribute">KillMode</span>=control-group<br><br><span class="hljs-attribute">ExecStart</span>=/usr/sbin/zabbix_agentd -c <span class="hljs-variable">$CONFFILE</span><br><br><span class="hljs-attribute">ExecStop</span>=/bin/kill -SIGTERM <span class="hljs-variable">$MAINPID</span><br><br><span class="hljs-attribute">RestartSec</span>=10s<br><br><span class="hljs-attribute">User</span>=zabbix<br><br><span class="hljs-attribute">Group</span>=zabbix<br><br>[Install]<br><br><span class="hljs-attribute">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>zabbix-agent和server启动完后还差一个必要的组件，zabbix-gui，也就是zabbix的管理图形界面</p><p>因是基于php编写的，所以这里还需要搭建一个nginx(apache)+php-fpm</p><p>yum -y install nginx php-fpm</p><p>其前端文件位于编译安装包根目录下的ui路径下面</p><p>nginx:conf.d/zabbix.conf</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> php-fpm &#123;<br>        <span class="hljs-attribute">server</span> unix:/run/php-fpm/www.sock;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>          <span class="hljs-number">81</span>;<br>        <span class="hljs-attribute">server_name</span>     localhost;<br><br>        <span class="hljs-attribute">root</span>    /usr/local/zabbix/ui;<br><br>        <span class="hljs-attribute">index</span>   index.php;<br><br>        <span class="hljs-attribute">location</span> = /favicon.ico &#123;<br>                <span class="hljs-attribute">log_not_found</span>   <span class="hljs-literal">off</span>;<br>        &#125;<br><br>        <span class="hljs-attribute">location</span> / &#123;<br>                <span class="hljs-attribute">try_files</span>       $uri $uri/ =<span class="hljs-number">404</span>;<br>        &#125;<br><br>        <span class="hljs-attribute">location</span> /assets &#123;<br>                <span class="hljs-attribute">access_log</span>      <span class="hljs-literal">off</span>;<br>                <span class="hljs-attribute">expires</span>         <span class="hljs-number">10d</span>;<br>        &#125;<br><br>        <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /\.ht</span> &#123;<br>                <span class="hljs-attribute">deny</span>            all;<br>        &#125;<br><br>        <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /(api\/|conf[^\.]|include|locale)</span> &#123;<br>                <span class="hljs-attribute">deny</span>            all;<br>                <span class="hljs-attribute">return</span>          <span class="hljs-number">404</span>;<br>        &#125;<br><br>        <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ [^/]\.php(/|$)</span> &#123;<br>                <span class="hljs-attribute">fastcgi_pass</span>    unix:/run/php-fpm/zabbix.sock;<br>                <span class="hljs-attribute">fastcgi_split_path_info</span><span class="hljs-regexp"> ^(.+\.php)(/.+)$</span>;<br>                <span class="hljs-attribute">fastcgi_index</span>   index.php;<br><br>                <span class="hljs-attribute">fastcgi_param</span>   DOCUMENT_ROOT   /usr/local/zabbix/ui;<br>                <span class="hljs-attribute">fastcgi_param</span>   SCRIPT_FILENAME /usr/local/zabbix/ui$fastcgi_script_name;<br>                <span class="hljs-attribute">fastcgi_param</span>   PATH_TRANSLATED /usr/local/zabbix/ui$fastcgi_script_name;<br><br>                <span class="hljs-attribute">include</span> fastcgi_params;<br>                <span class="hljs-attribute">fastcgi_param</span>   QUERY_STRING    $query_string;<br>                <span class="hljs-attribute">fastcgi_param</span>   REQUEST_METHOD  $request_method;<br>                <span class="hljs-attribute">fastcgi_param</span>   CONTENT_TYPE    $content_type;<br>                <span class="hljs-attribute">fastcgi_param</span>   CONTENT_LENGTH  $content_length;<br><br>                <span class="hljs-attribute">fastcgi_intercept_errors</span>        <span class="hljs-literal">on</span>;<br>                <span class="hljs-attribute">fastcgi_ignore_client_abort</span>     <span class="hljs-literal">off</span>;<br>                <span class="hljs-attribute">fastcgi_connect_timeout</span>         <span class="hljs-number">60</span>;<br>                <span class="hljs-attribute">fastcgi_send_timeout</span>            <span class="hljs-number">180</span>;<br>                <span class="hljs-attribute">fastcgi_read_timeout</span>            <span class="hljs-number">180</span>;<br>                <span class="hljs-attribute">fastcgi_buffer_size</span>             <span class="hljs-number">128k</span>;<br>                <span class="hljs-attribute">fastcgi_buffers</span>                 <span class="hljs-number">4</span> <span class="hljs-number">256k</span>;<br>                <span class="hljs-attribute">fastcgi_busy_buffers_size</span>       <span class="hljs-number">256k</span>;<br>                <span class="hljs-attribute">fastcgi_temp_file_write_size</span>    <span class="hljs-number">256k</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处官方提供的配置文件在匹配到.php时是跳转到</p><p>unix:/run/php-fpm/zabbix.sock;</p><p>说明此处php-fpm应将其sock文件放置于此，</p><p>/etc/php-fpm.d/zabbix.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zabbix]<br><br>user = apache<br><br>group = apache<br><br>listen = /run/php-fpm/zabbix.sock<br><br>listen.acl_users = apache,nginx<br><br>listen.allowed_clients = 127.0.0.1<br><br>pm = dynamic<br><br>pm.max_children = 50<br><br>pm.start_servers = 5<br><br>pm.min_spare_servers = 5<br><br>pm.max_spare_servers = 35<br><br>php_value[session.save_handler] = files<br><br>php_value[session.save_path]    = /var/lib/php/session<br><br>php_value[max_execution_time] = 300<br><br>php_value[memory_limit] = 128M<br><br>php_value[post_max_size] = 16M<br><br>php_value[upload_max_filesize] = 2M<br><br>php_value[max_input_time] = 300<br><br>php_value[max_input_vars] = 10000<br><br>php_value[date.timezone] = Asia/Shanghai<br></code></pre></td></tr></table></figure><p>配置完启动即可</p><p>systemctl start nginx</p><p>systemctl start php-fpm</p><h2 id="Yum安装："><a href="#Yum安装：" class="headerlink" title="Yum安装："></a>Yum安装：</h2><p>zabbix安装</p><p>rpm -Uvh <a href="https://repo.zabbix.com/zabbix/5.0/rhel/8/x86_64/zabbix-release-5.0-1.el8.noarch.rpm">https://repo.zabbix.com/zabbix/5.0/rhel/8/x86_64/zabbix-release-5.0-1.el8.noarch.rpm</a></p><p>yum makecache</p><p>yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-nginx-conf zabbix-agent</p><p>创建初始数据库</p><p>确保您已启动并运行数据库服务器。</p><p>在数据库主机上运行以下命令mysql -uroot -p</p><p>password</p><p>mysql&gt; create database zabbix character set utf8 collate utf8_bin;</p><p>mysql&gt; create user zabbix@localhost identified by ‘password’;</p><p>mysql&gt; grant all privileges on zabbix.* to zabbix@localhost;</p><p>mysql&gt; quit;</p><p>zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</p><p>为Zabbix服务器配置数据库</p><p>编辑文件/etc/zabbix/zabbix_server.conf</p><p>DBPassword=password</p><p>为Zabbix前端配置PHP</p><p>编辑文件/etc/nginx/conf.d/zabbix.conf，取消注释并设置’listen’和’server_name’指令。</p><p>listen 80;</p><p>server_name example.com;</p><p>编辑文件/etc/php-fpm.d/zabbix.conf，取消注释并为您设置正确的时区。</p><p>; php_value[date.timezone] = Europe/Riga</p><p>F。启动Zabbix服务器和代理进程</p><p>启动Zabbix服务器和代理进程，并使其在系统启动时启动。</p><p>systemctl restart zabbix-server zabbix-agent nginx php-fpm</p><p>systemctl enable zabbix-server zabbix-agent nginx php-fpm</p><h3 id="zabbix官网："><a href="#zabbix官网：" class="headerlink" title="zabbix官网："></a>zabbix官网：</h3><p><a href="https://www.zabbix.com/">https://www.zabbix.com/</a></p><h2 id="装完可能遇到的问题："><a href="#装完可能遇到的问题：" class="headerlink" title="装完可能遇到的问题："></a>装完可能遇到的问题：</h2><p>1.zabbix连不上数据库（检查数据库是不是utf8-bin)</p><p>2.设置里面不能改为中文：</p><p>zabbix前端inculde/locales.inc.php中的中文是否为ture</p><p>locale -a 中是有中文字码</p><p>3.zabbix图形中中文显示乱码</p><p>从windows中找到字体c:\windows\fonts</p><p>找到linux例zabbix的字体路径（/usr/local/zabbix/ui/assets/fonts</p><p>默认路径）</p><p>find / -name “<em>fonts</em>“</p><p>[root@localhost fonts]# ll</p><p>总用量 0</p><p>lrwxrwxrwx 1 root root 33 3月 1 03:50 graphfont.ttf -&gt; /etc/alternatives/zabbix-web-font</p><p>cd /etc/alternatives/</p><p>[root@localhost alternatives]# ll zabbix-web-font</p><p>lrwxrwxrwx 1 root root 38 3月 1 03:50 zabbix-web-font -&gt; /usr/share/fonts/dejavu/DejaVuSans.ttf</p><p>cd /usr/share/fonts/dejavu/</p><p>将文件导入，备份源文件，然后将新文件改成这个名字</p><p>[root@localhost dejavu]# mv DejaVuSans.ttf DejaVuSans.ttf.bak</p><p>[root@localhost dejavu]# mv MSJH.TTC DejaVuSans.ttf</p><h1 id="监控主机："><a href="#监控主机：" class="headerlink" title="监控主机："></a>监控主机：</h1><p>监控软件本身的主要作用的就是监控主机，在zabbix中，默认的第一个监控的主机为127.0.0.1:10050如agent在本地正常安装运行了以后，首次登陆gui就能看到本机的监控信息。</p><p>zabbix监控主机有几种模式：</p><p>agent，snmp，jmx，ipmi</p><p>agent:</p><p>一般情况是agent，即在需要被监控的主机端上装入客户端工具，然后与server端连接就可以进行监控了。</p><p>agent监控有两种模式：</p><p>主动模式，被动模式</p><p>Zabbix 被动模式： Server 向 agent 请求获取监控项的数据， agent 返回数据。</p><p>Server 打开一个 TCP 连接， Server 发送请求 agent.ping， Agent 接收到请求并</p><p>且响应， Server 处理接收到的数据。</p><p>Zabbix 主动模式： Agent 主动请求 server 获取主动的监控项列表，并主动将监</p><p>控项内需要检测的数据提交给 server/proxy。 zabbix agent 首先向</p><p>ServerActive 配置的 IP 请求获取 active items，获取并提交 active tiems 数</p><p>据值 给server 或者 proxy；</p><h2 id="Agent监控："><a href="#Agent监控：" class="headerlink" title="Agent监控："></a>Agent监控：</h2><h3 id="1-agent端配置"><a href="#1-agent端配置" class="headerlink" title="1.agent端配置"></a>1.agent端配置</h3><p>首先在需要监控的主机上安装agent端，安装见上zabbix安装。</p><p>然后再zabbix_agentd.conf中配置：</p><p>Server=127.0.0.1 #指定服务器ip地址</p><p>默认是被动模式，客户端只需设置这个</p><p>完成以后启动客户端即可</p><h3 id="2-zabbix-gui配置"><a href="#2-zabbix-gui配置" class="headerlink" title="2.zabbix-gui配置"></a>2.zabbix-gui配置</h3><p>再管理页面中添加主机</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059796.jpeg" alt="image.png"></p><p>指定其ip地址和端口，默认端口10050，链接上模板</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059887.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059763.jpeg" alt="image.png"></p><p>然后就添加完成了，右方ZBX为绿色表示可用</p><p><strong>agent监控方式也是被动模式，是默认的监控方式</strong></p><h2 id="主动模式："><a href="#主动模式：" class="headerlink" title="主动模式："></a>主动模式：</h2><p>主动模式修改zabbix_agent的配置文件</p><p>首先是StartAgents=0 这里默认为3，修改为0以后将不再监听端口。（server注不注释无所谓，主要是这里要配置为0）</p><p>然后是ServerActive=127.0.0.1，这里的ip地址得指定成server端的ip地址</p><p>这两个配置完毕以后主动模式就完成了，但还有一步是zabbix-gui中的监控项必须要设置成主动模式才会主动推送数据。</p><p>这里首先选择一个模板：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231104296.jpeg" alt="image.png"></p><p>为避免改了以后无法改回来，因克隆一个模板（这里克隆的模板必须是独立的模板而非链接其他模板的模板，否则不能更改其监控项的设置）</p><p>克隆完以后全选其监控项，点击批量更新</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059857.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059929.jpeg" alt="image.png"></p><p>类型设置为zabbix客户端主动式，设置一个更新间隔。</p><p>然后在主机中加入该模板</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059401.jpeg" alt="image.png"></p><p>这个时候主动模式的监控就已经配置完毕，在主机-可用性中可以看到</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059819.jpeg" alt="image.png"></p><p>其可用性非绿色，也就是zabbix-server无法找到客户端（因其客户端本身也不再监听端口）</p><p>此时可以在最新数据中看到</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059797.jpeg" alt="image.png"></p><h2 id="Snmp监控："><a href="#Snmp监控：" class="headerlink" title="Snmp监控："></a>Snmp监控：</h2><p>Snmp为简单网络管理协议，一般用在路由器，交换机之类的设备上，因这些设备本身无法安装监控客户端，则可以通过该协议监控其数据。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059467.jpeg" alt="image.png"></p><h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX:"></a>JMX:</h2><p>JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，</p><p>实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。主要用于对JAVA应用程序和JVM进行监控和管理。</p><p>JConsole和JVisualVM中能够监控到JAVA应用程序和JVM的相关信息都是通过JMX实现的。</p><p>这里我监控的是tomcat，首先在启动脚本（catalina.sh）中加入变量</p><p>CATALINA_OPTS=’-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8888 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false’</p><p>改完需重启tomcat</p><p>启用jmx并监听其端口</p><p>首先我们需要了解一下他们的对应关系，zabbix_server开启java poller, zabbx_java开启JavaGateway，端口为10052，Tomcat JMX开启12345提供性能数据。</p><p>数据获取：java poller&lt;–&gt;JavaGateway:10052&lt;–&gt;Tomcat:12345.</p><p>此时tomcat配置完了，然后配置zabbix_java</p><p>./configure –prefix=/usr/local/zabbix –enable-java &amp;&amp; make install #编译安装zabbix_java模块</p><p>cd /usr/local/zabbix/sbin</p><p>./startup</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059194.jpeg" alt="image.png"></p><p>启动以后zabbix监听客户端就配置完毕了，然后再zabbix_server配置文件里面找到这三个选项并指定为刚才配置好的jmx服务器的地址和端口</p><p>JavaGateway=10.10.10.223</p><p>Option: JavaGatewayPort</p><p>Port that Zabbix Java gateway listens on.</p><p>Mandatory: no</p><p>Range: 1024-32767</p><p>Default:</p><p>JavaGatewayPort=10052Option: StartJavaPollers</p><p>Number of pre-forked instances of Java pollers.</p><p>Mandatory: no</p><p>Range: 0-1000# Default:</p><p>StartJavaPollers=6</p><p>最后一步在zabbix gui里面添加jmx监控主机：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059730.jpeg" alt="image.png"></p><p>指定其类型为jmx，IP地址，以及jmx的端口 号</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059996.jpeg" alt="image.png"></p><p>然后再指定其监控模板（监控项）</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059225.jpeg" alt="image.png"></p><p>完毕以后jmx为绿色即成功监控。</p><h2 id="IPMI"><a href="#IPMI" class="headerlink" title="IPMI:"></a>IPMI:</h2><p>IPMI（Intelligent PlatformManagement Interface）即智能平台管理接口是使硬件管理具备“智能化”的新一代通用接口标准。用户可以利用 IPMI 监视服务器的物理特征，如温度、电压、电扇工作状态、电源供应以及机箱入侵等。Ipmi 最大的优势在于它是独立于 CPU BIOS 和 OS 的，所以用户无论在开机还是关机的状态下，只要接通电源就可以实现对服务器的监控。</p><p>IPMI跳过</p><h1 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h1><h2 id="主机群组："><a href="#主机群组：" class="headerlink" title="主机群组："></a>主机群组：</h2><p>主机群组是给主机以及模板进行分类的</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059909.jpeg" alt="image.png"></p><p>在创建主机或模板时都需指定其主机群组。</p><h2 id="监控模板："><a href="#监控模板：" class="headerlink" title="监控模板："></a>监控模板：</h2><p>系统模板：</p><p>监控了主机以后首先应配置主机的监控项，监控模板就是一系列监控项的合集，也是zabbix自带监控项的合集。</p><p>比如我这里选择了</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059238.jpeg" alt="image.png"></p><p>Zabbix agent模板，然后其应用集，监控项，触发器就都有了，都是基于该模板。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059335.jpeg" alt="image.png"></p><p>但本身监控模板也可以不提供任何监控项，其所有监控项均为链接其他的模板，由其他模板提供，以linux by zabbix agent 为例子，它做为模板本身没有任何应用集监控项，全是链接其它模板，相当于其他模板的整合模板。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059403.jpeg" alt="image.png"></p><p>这种链接模板优点是可以做为多模板的合集，缺点是无法直接在该模板里面对其监控项触发器进行编辑，可以看到这里监控项的可编辑区域均为灰色（无法编辑）。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231104240.jpeg" alt="image.png"></p><h3 id="自定义模板："><a href="#自定义模板：" class="headerlink" title="自定义模板："></a>自定义模板：</h3><p>在配置-模板的右上角有个创建模板</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231104141.jpeg" alt="image.png"></p><p>创建时需输入模板名称与主机群组</p><p>如不链接模板则输入完成后直接点添加</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059642.jpeg" alt="image.png"></p><p>创建完成后可创建监控项应用集触发器。</p><h4 id="应用集"><a href="#应用集" class="headerlink" title="应用集"></a>应用集</h4><p>应用集是监控项的的集合，用来归类监控项，一个应用集下面包含多个监控项。</p><p>主要作用就是归类，方便按类别查找模板里面的监控项。</p><h4 id="监控项"><a href="#监控项" class="headerlink" title="监控项"></a>监控项</h4><p>一个模板（主机）最重要的就是监控项，用于监控系统里面各个指标情况</p><p>默认一个模板也会包含n个监控项。在监控项右上角可以添加监控项</p><p>添加监控项界面：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059370.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059911.jpeg" alt="image.png"></p><p>监控项最重要的指标就是键值，也就是监控项的数据来源，在选择中通过类型筛选可以找到很多系统自带的键值。除减值外其他设置都可以视情况而定，例如查看值指的是当监控项为某值时对应的监控系统状态，例如监控一个应用是否正常运行，一般就有两个状态0和1，代表运行和关闭。</p><p>这是系统自带的查看值：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059695.jpeg" alt="image.png"></p><h5 id="自定义监控"><a href="#自定义监控" class="headerlink" title="自定义监控"></a>自定义监控</h5><p>如使用系统自带的键值则是zabbix自带的监控项，但也可自定义监控项。</p><p>例如我这里要手动监控nginx的状态：</p><p>首先再zabbix_agent端的zabbixagent.conf修改配置</p><p>Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf（也可以直接将自定义监控项键值写道主配置文件，但一般不会这么做）</p><p>UnsafeUserParameters=1 UserParameter接受所有传递的参数（建议开启，有的监控脚本需要传递参数）</p><p>[root@www etc]# cat zabbix_agentd.conf.d/nginx.conf</p><p>UserParameter=nginx,ps -ef |grep -v grep |grep nginx |grep master &gt;/dev/null ;echo $?</p><p>配置完重启zabbixagent端</p><p>设置完以后可以先再zabbix_agent客户端使用zabbix_get测试一下</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103323.jpeg" alt="image.png"></p><p>测试没有问题便可以添加配置项了，键值为nginx</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059650.jpeg" alt="image.png"></p><p>然后在最新数据里面找到该监控项（nginx）</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059468.jpeg" alt="image.png"></p><p>已经有数据了。</p><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>触发器本身基于监控项，起作用为触发报警。当一个监控项的数据到达某个阈值后，触发器便会触发。</p><p>下面创建一个触发器：</p><p>模板-触发器-创建触发器</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103307.jpeg" alt="image.png"></p><p>表达式：<img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059736.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103462.jpeg" alt="image.png"></p><p>触发器创建完毕后关闭nginx</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059274.jpeg" alt="image.png"></p><p>首页便有触发器报警了，但这里写了恢复表达式，所以再nginx启动后，该报警就自动移除了。</p><h4 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h4><p>正常情况下在添加了监控项以后都会有自带的图形监控显示功能，在最新数据里面就能可以，也可以在模板中把图形添加好</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103893.jpeg" alt="image.png"></p><p>但这个的添加图形无非是定义一下图形颜色风格类别等，或者将多个监控项集成于一图形（个人觉得图形非监控必要模块，作用不大），添加界面如下<img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103890.jpeg" alt="image.png"></p><p>添加完成后在监测-主机-图形里可以看到</p><h4 id="自动发现规则"><a href="#自动发现规则" class="headerlink" title="自动发现规则"></a>自动发现规则</h4><p>略</p><h4 id="web监控"><a href="#web监控" class="headerlink" title="web监控"></a>web监控</h4><p>Web检测是用于监控web应用，主要检测项有web网页反应时间，响应码。</p><p>在模板-web场景中添加web检测</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059981.jpeg" alt="image.png"></p><p>设置其更新间隔，尝试次数以及检测时访问的客户端。</p><p>然后在步骤里面添加要检测的weburl，选择跟随跳转，指定其状态码为200</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103105.jpeg" alt="image.png"></p><p>添加以后可以最新数据中看到其最新数据以及图形监控</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059149.jpeg" alt="image.png"></p><p>其监控项一共有五个：</p><p>Response time for step “soloblog” of scenario “soloblog”.（响应时间）</p><p>Response code for step “soloblog” of scenario “soloblog”.（响应码）</p><p>Last error message of scenario “soloblog”.（上一条错误信息）</p><p>Failed step of scenario “soloblog”. （响应失败）</p><p>Download speed for step “soloblog” of scenario “soloblog”.（响应速度）</p><p>Download speed for scenario “soloblog”.（响应速度）</p><p>有了监控项后可以对其进行设置触发器，网上一般会对其响应码做设置，但不知是不是版本的原因，我在本地照着网上的触发器设置并关闭触发的web网站后并无法触发，后发现其原因为响应码监控项在web项目无法访问时不能生成任何数据，也就是无法生成200以外的数据，则无法对其监控</p><p>响应时间，响应码，响应速度（Download speed for step “soloblog” of scenario “soloblog”.）均无法在web项目关闭时生成任何数据，所以也无法对这三项进行触发器触发操作。</p><p>下面是web项目关闭时其web检测数据：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059340.jpeg" alt="image.png"></p><p>这里可以对其响应失败码和响应速度进行触发，添加触发器：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059372.jpeg" alt="image.png"></p><p>在关闭web项目就可以看到触发器触发警报了：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059806.jpeg" alt="image.png"></p><h4 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h4><p>仪表盘和首页-仪表板类似，就是展示图形数据趋势图或者文本数据等相关信息的展示页面。</p><p>在模板-仪表盘里面可以定义：</p><p>模板-仪表盘-添加仪表盘</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103716.jpeg" alt="image.png"></p><p>这是添加仪表盘界面，在空白处任意位置点击可以添加。</p><h3 id="主机："><a href="#主机：" class="headerlink" title="主机："></a>主机：</h3><p>主机里面可以配置以及记录了zabbix监控的所有客户端</p><p>右上角可以创建主机，应用集到web检测这几项可以点击进去创建，但一般都基于模板套用，无需手动创建，如果设置了代理程序，在agent代理程序会显示，点击状态可以切换开启或关闭，可用性为绿色表示可用以及显示了其agentd端的监控类型。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103133.jpeg" alt="image.png"></p><p>IPMI为监控硬件选项，可以在ipmi选项卡中指定其用户名和密码</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059609.jpeg" alt="image.png"></p><p>标记为主机的标记或备注信息</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059646.jpeg" alt="image.png"></p><p>宏：</p><p>略</p><p>主机资产记录配置过以后可以在资产记录中看到</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231103113.jpeg" alt="image.png"></p><p>加密：</p><p>Zabbix版本从3.0之后，开始支持Zabbix server, Zabbix proxy, Zabbix agent, zabbix_sender and zabbix_get之间的通信加密，加密方式有预共享密钥(PSK)和证书加密。加密配置是可选项，一些proxies和agents可以使用证书认证加密通信，另外一些可以使用PSK加密通信，而剩余的可以不使用加密进行通信。</p><p>加密需编译时加入加密编译项，可通过密钥生成器生成密钥然后在zabbixagent配置文件中指定其密钥文件，最后在主机-加密中添加。</p><p>维护：</p><p>维护中可以定义其主机群组（主机）的维护时间，在维护时间内，主机监控项的触发器不会进行触发警，但如果维护时间过后仍未解决，zabbix会触发报警。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059118.jpeg" alt="image.png"></p><p>处于维护期间的主机：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059563.jpeg" alt="image.png"></p><h3 id="动作："><a href="#动作：" class="headerlink" title="动作："></a>动作：</h3><p>分为</p><p>Trigger actions,discovery actions,autoregistration actions,internal actions.</p><h4 id="Trigger-actions："><a href="#Trigger-actions：" class="headerlink" title="Trigger actions："></a>Trigger actions：</h4><p>Trigger actions最主要的作用是为触发器触发一个动作，触发器设置监控项的监控数据到达某个阈值时，会进行触发报警，但仅仅是在zabbix-gui面板上进行报警，而动作功能在触发器触发时进行邮件报警或恢复操作（执行命令）。</p><p>邮件报警：</p><p>首先设置好动作，动作的类型可以为多个，这里主要是设置其动作触发的条件，条件可以为多个，其计算方式一般是与/或和“和”：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231102098.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231102832.jpeg" alt="image.png"></p><p>这个我设置了</p><p>|<br>触发器示警度 大于等于 <em>警告</em> 主机 等于 <em>192.168.34.136</em> |<br>| - |</p><p>两个条件，计算方式是和</p><p>则在主机192.168.34.136的触发器警示度大于等于警告时，则会触发动作，接下来设置其动作。其动作有两种：发送消息和远程命令，发送消息也就是邮件报警或者钉钉（短信）等多种报警方式的实现，远程命令一般适用于其动作为某单个触发器时对其监控项进行命令恢复操作。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059111.jpeg" alt="image.png"></p><p>其动作设置了在触发器触发和恢复时通过email发给admin用户，其实也就是发送email给对应用户，这里需要额外设置两个东西，发送邮件的发件人设置，收件人设置。</p><p>发件人设置在其管理-报警媒介类型中：</p><p>这里是email报警，就选择email进行设置</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059154.jpeg" alt="image.png"></p><p>发件邮箱为163邮箱，需要网易邮箱中开启stmp服务，并获得其授权码，在这密码也非用户密码，而是授权码。Stmp输入其邮箱服务商对应的地址，电邮和用户名称皆为用户名</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059571.jpeg" alt="image.png"></p><p>Message templates:</p><p>这里可以设置报警时发送邮件的格式zabbix默认设置了五种邮件类型的模板，最常用的应该是问题。编辑可以更改</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231100963.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231100937.jpeg" alt="image.png"></p><p>将其改为</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059136.jpeg" alt="image.png"></p><p>然后更新确定</p><p>发件邮箱设置好以后在设置收件邮箱 user settings-报警媒介里面添加一个报警媒介，设置其收件人（邮箱）。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059160.jpeg" alt="image.png"></p><p>设置完以后就可以进行邮件报警了。这里192.168.34.136有一个触发器为监控nginx状态，为测试这里关闭nginx。关闭以后可以在主页仪表盘看到触发器以及其执行的动作<img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059648.jpeg" alt="image.png"></p><p>这时登录邮箱可以看到该邮件</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059855.jpeg" alt="image.png"></p><h4 id="Discovery-actions"><a href="#Discovery-actions" class="headerlink" title="Discovery actions:"></a>Discovery actions:</h4><p>自动发现的动作首先需要设置自动发现，当自动发现根据其设置发现到主机时，才能触发discovery actions，也就是自动发现动作。</p><h5 id="自动发现："><a href="#自动发现：" class="headerlink" title="自动发现："></a>自动发现：</h5><p>其配置项位于 配置-自动发现。下面是自动发现添加中需要定义的配置项</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059237.jpeg" alt="image.png"></p><p>IP范围：自动发现需要定义一个ip范围，其扫描的时候也只扫描该范围中的ip段。</p><p>更新间隔：更新间隔意味每隔多久会进行扫描一次，这个时间建议不要太短，太短的话其扫描操作会长期占用系统大部分资源，这里为了测试方便就设置了10秒</p><p>检查：ip扫描作为第一个筛选规则，而检查就是其第二个筛选规则，下面是其检查类型，这里我设置了检查类型为zabbix客户端，其键值为system.uname(linux客户端名称的键值)</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059651.jpeg" alt="image.png"></p><p>设备唯一准则性，主机名称，可见的名称根据需求设置即可，因其本身见名知意，这里也不在解释。</p><p>自动发现设置完毕以后会在网端内定期扫描，扫描到以后的主机信息可以在检测-自动发现中看到</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059919.jpeg" alt="image.png"></p><p>此时就可以设置自动发现的动作了。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059990.jpeg" alt="image.png"></p><p>首先是其条件，一般来说自动发现状态为up即可，也可根据情况设置多个条件。</p><p>然后是其动作<img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059209.jpeg" alt="image.png"></p><p>这里设置了四个动作：添加主机，添加到主机群组，链接其模板，启用主机。</p><p>动作设置完成以后，此时当zabbix-server检测的自动发现检测到主机以后就会自动添加主机并链接其模板。</p><h4 id="Autoregistration-actions"><a href="#Autoregistration-actions" class="headerlink" title="Autoregistration actions:"></a>Autoregistration actions:</h4><p>自动注册规则本质上实现的功能与自动发现一样，都是通过自动化功能添加监控zabbix-agent端，不一样的是自动发现是通过zabbix-server去扫描指定网段的客户端，而自动注册是zabbix-agent主动注册到server端。后者的优势在于自动注册无需指定网段，在局域网网络较为复杂或者互联网实现监控时可以用到。</p><p>首先是在zabbix-agent的配置文件上进行配置：</p><p>在需要被监控的主机上安装好agent端，然后编辑zabbix_agent.conf。</p><p>Zabbix_agent.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Server=10.10.10.187(这个非自动注册用到的配置项，而是监控时需指定的serverip)ServerActive=10.10.10.187（设置主动注册的serverip）<br><br>Hostname=ysw1450 （注册时设置的主机名称，正常使用时这个也应当是zabbixagent的名称）<br><br>HostMetadata=admin145 （注册时的主机元数据）<br><br>HostMetadataItem=system.uame (也是元数据)<br></code></pre></td></tr></table></figure><p>这样，您可以确保主机元数据包含“Linux”或“Windows”，具体取决于运行代理的主机。 在这种情况下主机元数据的示例：</p><blockquote><p>Linux: Linux server3 3.2.0-4-686-pae #1 SMP Debian 3.2.41-2 i686 GNU/Linux</p><p>Windows: Windows WIN-0PXGGSTYNHO 6.0.6001 Windows Server 2008 Service Pack 1 Intel IA-32</p></blockquote><p>我感觉HostMetadataItem和HostMetadata设置一个即可，如设置HostMetadataItem的话就在配置页面主机元数据那里写上linux（windows），如果是HostMetadata的话就对其字符串进行匹配。也可以一起设置。</p><p>配置好以后转到zabbix_gui上的自动注册添加，主机名对应hostname，主机元数据对应HostMetadata</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059180.jpeg" alt="image.png"></p><p>然后设置其动作（和自动发现一样）</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059447.jpeg" alt="image.png"></p><p>添加以后启动zabbixagent然后看gui就已经注册了。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059701.jpeg" alt="image.png"></p><h4 id="Internal-actions："><a href="#Internal-actions：" class="headerlink" title="Internal actions："></a>Internal actions：</h4><p>内部动作主要是根据事件类型来做动作。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059732.jpeg" alt="image.png"></p><p>在事件类型触发以下条件时就可以做出动作（发送信息）。</p><p>但我觉得这个用的少，且本身监控项触发器在事件类型报告为未知的情况并不常见。</p><h3 id="关联项事件："><a href="#关联项事件：" class="headerlink" title="关联项事件："></a>关联项事件：</h3><p>略</p><h3 id="钉钉报警："><a href="#钉钉报警：" class="headerlink" title="钉钉报警："></a>钉钉报警：</h3><h4 id="钉钉创建群机器人"><a href="#钉钉创建群机器人" class="headerlink" title="钉钉创建群机器人"></a>钉钉创建群机器人</h4><p>首先在钉钉里面创建一个群，然后再创建一个机器人并拿到其webhook</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059972.jpeg" alt="image.png"></p><h4 id="在linux中创建脚本"><a href="#在linux中创建脚本" class="headerlink" title="在linux中创建脚本"></a>在linux中创建脚本</h4><p>vim /usr/lib/zabbix/alertscripts/dingding.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>to=<span class="hljs-variable">$1</span><br>subject=<span class="hljs-variable">$2</span><br>text=<span class="hljs-variable">$3</span><br><br><span class="hljs-comment">#此处的 xxxxx 就是刚刚复制存留的 api 接口地址。</span><br>curl -i -X POST \<br><span class="hljs-string">&#x27;https://oapi.dingtalk.com/robot/send?access_token=XXX&#x27;</span> \<br>-H <span class="hljs-string">&#x27;Content-type&#x27;</span>:<span class="hljs-string">&#x27;application/json&#x27;</span> \<br>-d <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;msgtype&quot;: &quot;text&quot;,</span><br><span class="hljs-string">     &quot;text&quot;: &#123;</span><br><span class="hljs-string">        &quot;content&quot;: &quot;&#x27;</span>监控报警：<span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&quot;<span class="hljs-variable">$text</span>&quot;</span><span class="hljs-string">&#x27;&quot;</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">  &quot;at&quot;:&#123;</span><br><span class="hljs-string">    &quot;atMobiles&quot;:[</span><br><span class="hljs-string">      &quot;&#x27;</span><span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><span class="hljs-string">&#x27;&quot;</span><br><span class="hljs-string">      ],</span><br><span class="hljs-string">  &quot;isAtAll&quot;:false</span><br><span class="hljs-string">   &#125; </span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>chmod +x dingding.sh</p><p>测试脚本是否执行成功。<br>sh dinhding.sh 11 22 33</p><p><strong>此时应该能在钉钉群里看到机器人发送消息</strong></p><h4 id="在zabbix中添加报警媒介"><a href="#在zabbix中添加报警媒介" class="headerlink" title="在zabbix中添加报警媒介"></a>在zabbix中添加报警媒介</h4><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059800.jpeg" alt="image.png"></p><p>参数：</p><p>{ALERT.SENDTO}</p><p>{ALERT.SUBJECT}</p><p>{ALERT.MESSAGE}</p><h5 id="message-templates："><a href="#message-templates：" class="headerlink" title="message templates："></a>message templates：</h5><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059850.jpeg" alt="image.png"></p><p>主题：</p><p>故障{TRIGGER.STATUS},服务器:{HOSTNAME1}发生: {TRIGGER.NAME}故障!</p><p>消息：</p><p>告警主机:{HOSTNAME1}</p><p>告警时间:{EVENT.DATE} {EVENT.TIME}</p><p>告警等级:{TRIGGER.SEVERITY}</p><p>告警信息: {TRIGGER.NAME}</p><p>告警项目:{TRIGGER.KEY1}</p><p>问题详情:{ITEM.NAME}:{ITEM.VALUE}</p><p>当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}</p><p>事件 ID:{EVENT.ID}</p><h4 id="触发器动作中加入钉钉报警"><a href="#触发器动作中加入钉钉报警" class="headerlink" title="触发器动作中加入钉钉报警"></a>触发器动作中加入钉钉报警</h4><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059029.jpeg" alt="image.png"></p><h4 id="给admin添加钉钉报警媒介"><a href="#给admin添加钉钉报警媒介" class="headerlink" title="给admin添加钉钉报警媒介"></a>给admin添加钉钉报警媒介</h4><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231059359.jpeg" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>firewalld</title>
    <link href="/2021/12/23/firewalld_hexo/"/>
    <url>/2021/12/23/firewalld_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>firewalld是linux的防火墙命令工具，与iptables类似，本身和iptables一样只是命令行工具，真正实现防火墙是内置于linux内核里面的netfilter模块。但其命令无需理解netfilter的四表五链，相对于iptables会简单一些。也是centos7以后的默认防火墙命令行工具。</p><h1 id="2-firewalld-和iptables的区别"><a href="#2-firewalld-和iptables的区别" class="headerlink" title="2 firewalld 和iptables的区别"></a>2 firewalld 和iptables的区别</h1><ol><li>firewalld可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效;</li><li>firewalld在使用上要比iptables人性化很多，即使不明白“五张表五条链”而且对TCPIP协议也不理解也可以实现大部分功能;</li><li>firewalld跟iptables比起来，不好的地方是每个服务都需要去设置才能放行，因为默认是拒绝。而iptables里默认是每个服务是允许，需要拒绝的才去限制;</li><li>firewalld加入了区域zone的概念。</li></ol><h1 id="3-区域"><a href="#3-区域" class="headerlink" title="3.区域"></a>3.区域</h1><p>firewalld有区域的概念，而其防火墙隔离操作也是通过区域来进行隔离的</p><p>firewalld默认自带的区域：<br>trusted (信任)<br>允许所有的数据包流入与流出<br>home (家庭)<br>拒绝流入的流量，除非与流出的流量相关;而如果流量与ssh、mdns、 ipp-client、 amba-client与dhcpv6-client服务相关, 则允许流量<br>internal (内部)<br>等同于home区域<br>work (工作)<br>拒绝流入的流量,除非与流出的流量数相关;而如果流量与ssh、ipp-client与dhcpv6-client服务相关, 则允许流量<br>public (公共)<br>拒绝流入的流量，除非与流出的流量相关;而如果流量与ssh、dhcpv6-client服务相关， 则允许流量<br>external (外部)<br>拒绝流入的流量,除非与流出的流量相关;而如果流量与ssh服务相关,则允许流量<br>dmz (非军事区)<br>拒绝流入的流量,除非与流出的流量相关;而如果流量与5ssh服务相关,则允许流量<br>block (限制)<br>拒绝流入的流量，除非与流出的流量相关<br>drop (丢弃)<br>拒绝流入的流量，除非与流出的流量相关</p><p>默认网卡都加入到了公共的区域，也就是public。区域内可以加入网卡或者网段，默认为public区域，如加入网卡表示该网卡的所有流量都遵循该区域的规则，例如默认drop丢弃所有包，将网卡设置为drop即该网卡丢弃所有包。但如果将网段设置为一个区域，例如trust，此时该网段的所有包将允许。<br>则如果想实现黑名单拒绝所有，只允许白名单可以将网卡先设置为drop并允许部分网段<br>如果想实现某网段的部分端口放行，例如10.0.0.0/24仅放行其ssh，可以将该网段加入external区域（因其区域本身只允许ssh），但因默认所有网卡为public，此时建议把网卡设置为drop区域，这样仅10网段可以访问ssh且其他所有网段无法访问（如设置为trusted区域为所有网段皆允许但仅10网段限定智能访问其ssh端口）</p><h1 id="4-firewall-cmd"><a href="#4-firewall-cmd" class="headerlink" title="4.firewall-cmd"></a>4.firewall-cmd</h1><p>firewall-cmd是firewalld服务的命令行工具，在firewall-cmd执行命令时，有两种生效方式：</p><p>runtime （运行时）：修改规则马上生效，但是临时生效</p><p>permanent（持久配置）：需要reload才能生效 ，但是永久生效</p><h2 id="firewall-cmd相关命令参数："><a href="#firewall-cmd相关命令参数：" class="headerlink" title="firewall-cmd相关命令参数："></a>firewall-cmd相关命令参数：</h2><p>zone区域相关指令：<br>–get-default-zone 查询默认的区域名称<br>–set-default-zone=xxx 设置默认的区域，使其永久生效<br>–get-active-zones 显示当前正在使用的区域与网卡名称<br>–get-zones 显示总共可用的区域<br>–new-zone= 新增区域</p><p>services服务相关指令<br>–get-services 显示预先定义好的服务<br>–add-service= 设置默认区域允许该服务的流量<br>–remove-service= 设置默认区域不再允许该服务的流量</p><p>port端口相关指令<br>-add-port=端口号/协议 设置默认区域允许该端口的流量<br>-remove-port=端口号/协议 设置默认区域不再允许该端口的流量</p><p>interface网卡相关指令：<br>–add-interface=网卡名 将源自该网卡的所有流量都导向某个指定区域<br>–change-interface=网卡名 将某个网卡与区域进行关联</p><p>其他相关指令：<br>–list-all 显示当前区域的网卡配置参数，资源，端口以及服务等信息<br>–reload 让永久生效的配置规则立即生效，并覆盖当前的配置规则<br>–zone 在对区域进行添加修改删除等配置时，指定对其某个区域进行操作。</p><p>在对区域添加或更改配置时，如没有指明–zone,则默认设置为当前默认的区域。<br>例如 firewall-cmd –add-port=8080/tcp<br>这里给防火墙加了一个8080允许的规则，一般firewalld默认是public，所以这时，这个规则会加到public里面，如果是想把这条规则加到drop里面<br>则：firewall-cmd –add-port=8080/tcp –zone=drop</p><h2 id="firewall-cmd-–list-all"><a href="#firewall-cmd-–list-all" class="headerlink" title="firewall-cmd –list-all"></a>firewall-cmd –list-all</h2><p>显示当前区域的网卡配置参数，资源，端口以及服务等信息<br>public (active)<br>target: default<br>icmp-block-inversion: no<br>interfaces: ens33 ens37 ens38<br>sources:<br>services: cockpit dhcpv6-client http ssh<br>ports:<br>protocols:<br>masquerade: no<br>forward-ports:<br>source-ports:<br>icmp-blocks:<br>rich rules:<br>默认所有网卡都会在public区域，可以通过zone相关参数修改。默认支持的服务（端口）在services里面，如要添加允许的服务，可以通过–add-port（–add-services）。<br>例如允许81端口 :<br>firewall-cmd –permanent –add-port=81/tcp<br>firewall-cmd –reload<br>删除直接把add换成remove</p><p>禁用传统防火墙服务<br>systemctl mask iptables<br>systemctl mask ip6tables<br>systemctl mask ebtables</p><p>启动firewalld防火墙，并加入开机自启动服务<br>systemctl start/enable firewalld</p><p>备份firewalld配置文件<br>cp -rf /etc/firewalld/ /etc/firewalld_backup</p><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>案例一:<br>1.设定默认区域为drop (拒绝所有)<br>2.设置白名单IP访问，将源10.0.0.0/24网段加入trusted区域<br>//将当前默认区域修改为drop<br>[root@Firewalld ~]firewall-cmd –set-default-zone=drop<br>//将网络接口关联至drop区域<br>[root@Firewalld ~]firewall-cmd –permanent –change-interface=eth0 –zone=drop<br>将10.o.o.0/24网段加入trusted白名单<br>[root@Firewalld ~]# firewall-cmd –permanent –add-source=10.0.0.0/24 –zone=trusted<br>[rooteFirewalld ~]# firewall-cmd –reload<br>success<br>//查看当前处于活动的区域<br>firewall-cmd –get-active-zones<br>drop.默认区域,eth0接口流量都由drop区域过滤<br>interfaces: eth0<br>trusted.数据包的源IP是10.0.0.0网段走trusted区域<br>sources: 10.0.0.0/24<br>将网卡设置为drop区域以后，再将允许的网段加入trust区域，此时trust允许的网段能访问drop的网卡。</p><p>防火墙端口转发：<br>firewall-cmd –permanent –zone=&lt;区域&gt; –add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标ip地址&gt;<br>此功能对应iptables nat表功能<br>1.转发本机555/tcp端口的流量至22/tcp端口，要求当前和长期有效<br>[root@Firewalld ~]# firewall-cmd –permanent –zone=public –add-forward-port=port=555:proto=tcp:toport=22:toaddr=10.0.0.61<br>success<br>[ root@Firewalld ~]# firewall-cmd –reload<br>success<br>2.移除本机转发的555/tcp端口策略，要求当前和长期有效<br>[root@Firewalld -]firewall-cmd –remove-forward-port=port=555:proto=tcp:toport=22:toaddr=10.0.0.61<br>success<br>[ rooteFirewalld ~].firewall-cmd –reload<br>success<br>3.如果需要将本地的10.0.0.81:6666端口转发至后端172.16.1.8:22端口<br>1.开启IP伪装<br>[root@Firewalld ~]# firewall-cmd –add-masquerade –permanent<br>2.配置转发<br>[root@Firewalld ~]# firewall-cmd –permanent –zone=public<br>–add-forward-port=port=6666:proto=tcp:toport=22:toaddr=172.16.1.8<br>[ root@Firewalld ~].firewall-cmd –reload<br>此时ssh访问10 6666端口即连接到172.16.1.8:22</p><h1 id="防火墙富规则策略："><a href="#防火墙富规则策略：" class="headerlink" title="防火墙富规则策略："></a>防火墙富规则策略：</h1><p>firewalld中的富规则表示更细致，更详细的防火墙策略配置，可以针对系统服务，端口号，源地址和目标地址等诸多信息进行更有针对性的策略配置，优先级在所有防火墙策略中也是最高的。</p><p>帮助：man firewalld.richlanguage</p><p>firewall-cmd –add-rich-rule=’rule’</p><p>rule<br>[source]<br>[destination]<br>service|port|protocol|icmp-block|icmp-type|masquerade|forward-port|source-port<br>[log]<br>[audit]<br>[accept|reject|drop|mark]</p><p>rule [ family=”ipv4 lipv6””]<br>source address=”address [ /rmask]”[invert=”True”]<br>destination address=”address [/mask] “ invert=”True”<br>service name=”service name”<br>port port=”port value” protocol=”tcp|udp”<br>protocol value=”protocoi value”<br>forward-port port=”port value” protocol=”tcp|udp” to-port=”port value” to-addr=”address”<br>log [prefix=”prefix text”] [level=”log level”] [limit value=”rate/duration”]<br>accept|reject [type=”reject type”] | drop<br>//区里的富规则按先后顺序匹配，按先匹配到的规则生效。<br>–add-rich-rule=KFUJLE&gt;’//在指定的区添加一条富规则<br>–remove-rich-rule=’’//在指定的区删除一条富规则<br>–query-rich-rule=’’ 1/找到规则返回0，找不到返回1<br>–iist-rich-rules/列出指定区里的所有富规则<br>–list-all 和 –list-all-zones也能列出存在的富规则</p><p>1.允许10.0.0.0/24网段中10.0.0.1主机访问http服务,其他同网段主机无法访问，当前和永久生效<br>#1.加入10.0.0.0/24所有主机至public区域<br>[root@mo1 ~]# firewall-cmd –permanent –add-source=10.0.0.0/24 –zone=public<br>#2.仅允许public中的10.0.0.1主机访问http<br>[rootCmo1 ~]# firewall-cmd –permanent –zone=public –add-rich-rule= ‘rule family=ipv4 source address=10.0.0.1/32 port port=80 protocol=tcp accept”<br>#3.重载firewalld防火墙<br>[root@m01 ~]# firewall-cmd –reload</p><p>2.拒绝10.0.0.0/24网段中的10.0.0.9主机发起的ssh请求,当前和永久生效<br>[rootCmo1 ~]# fireuall-cmd –permanent –zone=public –add-rich-rulem ‘rule family-ipv4 source address=10.0.0.9/32 service name=ssh drop’</p><p>[ root@me1 ~]# firewall-cmd –reload<br>success</p><p>3.将远程10.0.0.1主机请求firewalld的5551端口，转发至firewalld防火墙的22端口<br>[rootCmo ~]# firewall-cmd –permanent –zone=public –add-rich-rule= ‘rule family=ipv4 source address=10.0.0.1/32 forward-port port=5551 protocol=tcp to-port=22’<br>[ root@mo1 ~]# firewall-cmd –reload<br>success</p><p>4.将远程10.0.0.1主机请求firewalld的6661端口，转发至后端主机10.0.0.9的22端口<br>[ root@mo1 ~]# firewall-cmd –add-masquerade –permanent<br>[ root@mo1 ]# firewall-cmd –permanent –zone=public –add-rich-rule=’rule family=ipv4 source address=10.0.0.1/32 forward-port port=6661 protocol=tcp to-port=22 to-addr=10.0.0.9’<br>success<br>[root@me1]# firewall-cmd –reload</p><h1 id="防火墙开启内部上网："><a href="#防火墙开启内部上网：" class="headerlink" title="防火墙开启内部上网："></a>防火墙开启内部上网：</h1><p>环境<br>主机1（防火墙主机） 外网ip 内网ip<br>主机2 内网ip<br>主机2的内网ip需要与主机1的内网ip位于同一环境，此时主机2 的内网ip无法直接与互联网进行通信<br>主机2配置：<br>gateway指定其主机1的内网ip，dns需设置（114.114.114.114）。<br>然后重启网卡<br>nmcli c down ens33 &amp;&amp;nmcli c up ens33<br>主机1配置：<br>firewall-cmd –permanet –add-masquerade (开启主机转发)</p><p>然后即可通信</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ftp</title>
    <link href="/2021/12/23/ftp_hexo/"/>
    <url>/2021/12/23/ftp_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ftp简介"><a href="#1-ftp简介" class="headerlink" title="1.ftp简介"></a>1.ftp简介</h1><p>ftp是一种较为古老的文件传输服务，可实现文件的共享以及传输。其服务器端有两个端口，一个是控制端口（默认21），控制端口负责ftp的连接控制，还有一个端口是传输端口，其主动模式时，传输端口默认为20端口，在其为被动模式时，默认为1000以后的大端口号。ftp服务的版本服务很多，vsftp是其中一个分支,译为非常安全的文件服务。</p><h1 id="2-主动模式与被动模式"><a href="#2-主动模式与被动模式" class="headerlink" title="2.主动模式与被动模式"></a>2.主动模式与被动模式</h1><p>ftp其运行时有两种工作模式，主动模式与被动模式。</p><h3 id="1-PORT（主动模式）"><a href="#1-PORT（主动模式）" class="headerlink" title="(1) PORT（主动模式）"></a>(1) PORT（主动模式）</h3><p>PORT中文称为主动模式，工作的原理： FTP客户端连接到FTP服务器的21端口，发送用户名和密码登录，登录成功后要list列表或者读取数据时，客户端随机开放一个端口（1024以上），发送 PORT命令到FTP服务器，告诉服务器客户端采用主动模式并开放端口；FTP服务器收到PORT主动模式命令和端口号后，通过服务器的20端口和客户端开放的端口连接，发送数据，原理如下图：<br><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231035913.jpeg" alt="img"></p><h3 id="2-PASV（被动模式）"><a href="#2-PASV（被动模式）" class="headerlink" title="(2) PASV（被动模式）"></a>(2) PASV（被动模式）</h3><p>PASV是Passive的缩写，中文成为被动模式，工作原理：FTP客户端连接到FTP服务器的21端口，发送用户名和密码登录，登录成功后要list列表或者读取数据时，发送PASV命令到FTP服务器， 服务器在本地随机开放一个端口（1024以上），然后把开放的端口告诉客户端， 客户端再连接到服务器开放的端口进行数据传输，原理如下图：<br><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231036826.jpeg" alt="img"></p><h1 id="3-两种模式对于防火墙的影响"><a href="#3-两种模式对于防火墙的影响" class="headerlink" title="3.两种模式对于防火墙的影响"></a>3.两种模式对于防火墙的影响</h1><p>主动模式之所以称为主动模式，是因为在两端传输端口通道建立时，是服务器端（21端口）主动与客户端（1024+随机端口）请求建立连接。这其中可能出现的问题是，我们都知道，防火墙是有入口和出口的，通常客户端的入端口在防火墙策略里面是关闭的，故也无法成功连接客户端的传输接口。而在被动模式中，是服务器端开放一个大于1024的随机接口，然后通过控制接口告知客户端，让客户端来主动请求建立连接。在这里，客户端的防火墙不会是问题所在，因为客户端出端口一般默认不会做限制，而两个连接请求也都是客户端发起的，但此时，服务器端除了开放自己21的控制端口以外，还需要特别开放一个随机端口范围（这个范围由ftp启动被动模式时定义的范围）。</p><p>综上所述，在服务器端需要面对大量客户端时，最好选择被动模式，这样不会让客户端因为自己的防火墙入口关闭而受到影响。</p><h1 id="4-vsftpd"><a href="#4-vsftpd" class="headerlink" title="4.vsftpd"></a>4.vsftpd</h1><p>vsftpd安装很简单 redhad 或centos直接使用</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs v">yum -y install vsftpd<br></code></pre></td></tr></table></figure><p>rpm -ql vsftpd #查看vsftpd安装的所有文件</p><h3 id="4-1配置文件"><a href="#4-1配置文件" class="headerlink" title="4.1配置文件"></a>4.1配置文件</h3><p>vsftpd配置文件目录：/etc/vsftpd/vsftpd.conf</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 是否允许匿名登录FTP服务器，默认设置为YES允许</span><br><span class="hljs-meta"># 用户可使用用户名ftp或anonymous进行ftp登录，口令为用户的E-mail地址。</span><br><span class="hljs-meta"># 如不允许匿名访问则设置为NO</span><br>anonymous_enable=YES<br><span class="hljs-meta"># 是否允许本地用户(即linux系统中的用户帐号)登录FTP服务器，默认设置为YES允许</span><br><span class="hljs-meta"># 本地用户登录后会进入用户主目录，而匿名用户登录后进入匿名用户的下载目录/var/ftp/pub</span><br><span class="hljs-meta"># 若只允许匿名用户访问，前面加上#注释掉即可阻止本地用户访问FTP服务器</span><br>local_enable=YES<br><span class="hljs-meta"># 是否允许本地用户对FTP服务器文件具有写权限，默认设置为YES允许</span><br>write_enable=YES <br><span class="hljs-meta"># 掩码，本地用户默认掩码为077</span><br><span class="hljs-meta"># 你可以设置本地用户的文件掩码为缺省022，也可根据个人喜好将其设置为其他值</span><br><span class="hljs-meta">#local_umask=022</span><br><span class="hljs-meta"># 是否允许匿名用户上传文件，须将全局的write_enable=YES。默认为YES</span><br><span class="hljs-meta">#anon_upload_enable=YES</span><br><span class="hljs-meta"># 是否允许匿名用户创建新文件夹</span><br><span class="hljs-meta">#anon_mkdir_write_enable=YES </span><br><span class="hljs-meta"># 是否激活目录欢迎信息功能</span><br><span class="hljs-meta"># 当用户用CMD模式首次访问服务器上某个目录时，FTP服务器将显示欢迎信息</span><br><span class="hljs-meta"># 默认情况下，欢迎信息是通过该目录下的.message文件获得的</span><br><span class="hljs-meta"># 此文件保存自定义的欢迎信息，由用户自己建立</span><br><span class="hljs-meta">#dirmessage_enable=YES</span><br><span class="hljs-meta"># 是否让系统自动维护上传和下载的日志文件</span><br><span class="hljs-meta"># 默认情况该日志文件为/var/log/vsftpd.log,也可以通过下面的xferlog_file选项对其进行设定</span><br><span class="hljs-meta"># 默认值为NO</span><br>xferlog_enable=YES<br><span class="hljs-meta"># Make sure PORT transfer connections originate from port 20 (ftp-data).</span><br><span class="hljs-meta"># 是否设定FTP服务器将启用FTP数据端口的连接请求</span><br><span class="hljs-meta"># ftp-data数据传输，21为连接控制端口</span><br>connect_from_port_20=YES<br><span class="hljs-meta"># 设定是否允许改变上传文件的属主，与下面一个设定项配合使用</span><br><span class="hljs-meta"># 注意，不推荐使用root用户上传文件</span><br><span class="hljs-meta">#chown_uploads=YES</span><br><span class="hljs-meta"># 设置想要改变的上传文件的属主，如果需要，则输入一个系统用户名</span><br><span class="hljs-meta"># 可以把上传的文件都改成root属主。whoever：任何人</span><br><span class="hljs-meta">#chown_username=whoever</span><br><span class="hljs-meta"># 设定系统维护记录FTP服务器上传和下载情况的日志文件</span><br><span class="hljs-meta"># /var/log/vsftpd.log是默认的，也可以另设其它</span><br><span class="hljs-meta">#xferlog_file=/var/log/vsftpd.log</span><br><span class="hljs-meta"># 是否以标准xferlog的格式书写传输日志文件</span><br><span class="hljs-meta"># 默认为/var/log/xferlog，也可以通过xferlog_file选项对其进行设定</span><br><span class="hljs-meta"># 默认值为NO</span><br><span class="hljs-meta">#xferlog_std_format=YES</span><br><span class="hljs-meta"># 以下是附加配置，添加相应的选项将启用相应的设置</span><br><span class="hljs-meta"># 是否生成两个相似的日志文件</span><br><span class="hljs-meta"># 默认在/var/log/xferlog和/var/log/vsftpd.log目录下</span><br><span class="hljs-meta"># 前者是wu_ftpd类型的传输日志，可以利用标准日志工具对其进行分析；后者是vsftpd类型的日志</span><br><span class="hljs-meta">#dual_log_enable</span><br><span class="hljs-meta"># 是否将原本输出到/var/log/vsftpd.log中的日志，输出到系统日志</span><br><span class="hljs-meta">#syslog_enable</span><br><span class="hljs-meta"># 设置数据传输中断间隔时间，此语句表示空闲的用户会话中断时间为600秒</span><br><span class="hljs-meta"># 即当数据传输结束后，用户连接FTP服务器的时间不应超过600秒。可以根据实际情况对该值进行修改</span><br><span class="hljs-meta">#idle_session_timeout=600</span><br><span class="hljs-meta"># 设置数据连接超时时间，该语句表示数据连接超时时间为120秒，可根据实际情况对其个修改</span><br><span class="hljs-meta">#data_connection_timeout=120</span><br><span class="hljs-meta"># 运行vsftpd需要的非特权系统用户，缺省是nobody</span><br><span class="hljs-meta">#nopriv_user=ftpsecure</span><br><span class="hljs-meta"># 是否识别异步ABOR请求。</span><br><span class="hljs-meta"># 如果FTP client会下达“async ABOR”这个指令时，这个设定才需要启用</span><br><span class="hljs-meta"># 而一般此设定并不安全，所以通常将其取消</span><br><span class="hljs-meta">#async_abor_enable=YES</span><br><span class="hljs-meta"># 是否以ASCII方式传输数据。默认情况下，服务器会忽略ASCII方式的请求。</span><br><span class="hljs-meta"># 启用此选项将允许服务器以ASCII方式传输数据</span><br><span class="hljs-meta"># 不过，这样可能会导致由&quot;SIZE /big/file&quot;方式引起的DoS攻击</span><br><span class="hljs-meta">#ascii_upload_enable=YES</span><br><span class="hljs-meta">#ascii_download_enable=YES</span><br><span class="hljs-meta"># 登录FTP服务器时显示的欢迎信息</span><br><span class="hljs-meta"># 如有需要，可在更改目录欢迎信息的目录下创建名为.message的文件，并写入欢迎信息保存后</span><br><span class="hljs-meta">#ftpd_banner=Welcome to blah FTP service.</span><br><span class="hljs-meta"># 黑名单设置。如果很讨厌某些email address，就可以使用此设定来取消他的登录权限</span><br><span class="hljs-meta"># 可以将某些特殊的email address抵挡住。</span><br><span class="hljs-meta">#deny_email_enable=YES</span><br><span class="hljs-meta"># 当上面的deny_email_enable=YES时，可以利用这个设定项来规定哪些邮件地址不可登录vsftpd服务器</span><br><span class="hljs-meta"># 此文件需用户自己创建，一行一个email address即可</span><br><span class="hljs-meta">#banned_email_file=/etc/vsftpd/banned_emails</span><br><span class="hljs-meta"># 用户登录FTP服务器后是否具有访问自己目录以外的其他文件的权限</span><br><span class="hljs-meta"># 设置为YES时，用户被锁定在自己的home目录中，vsftpd将在下面chroot_list_file选项值的位置寻找chroot_list文件</span><br><span class="hljs-meta"># 必须与下面的设置项配合</span><br><span class="hljs-meta">#chroot_list_enable=YES</span><br><span class="hljs-meta"># 被列入此文件的用户，在登录后将不能切换到自己目录以外的其他目录</span><br><span class="hljs-meta"># 从而有利于FTP服务器的安全管理和隐私保护。此文件需自己建立</span><br><span class="hljs-meta">#chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="hljs-meta"># 是否允许递归查询。默认为关闭，以防止远程用户造成过量的I/O</span><br><span class="hljs-meta">#ls_recurse_enable=YES</span><br><span class="hljs-meta"># 是否允许监听。</span><br><span class="hljs-meta"># 如果设置为YES，则vsftpd将以独立模式运行，由vsftpd自己监听和处理IPv4端口的连接请求</span><br>listen=YES<br><span class="hljs-meta"># 设定是否支持IPV6。如要同时监听IPv4和IPv6端口，</span><br><span class="hljs-meta"># 则必须运行两套vsftpd，采用两套配置文件</span><br><span class="hljs-meta"># 同时确保其中有一个监听选项是被注释掉的</span><br><span class="hljs-meta">#listen_ipv6=YES</span><br><span class="hljs-meta"># 设置PAM外挂模块提供的认证服务所使用的配置文件名，即/etc/pam.d/vsftpd文件</span><br><span class="hljs-meta"># 此文件中file=/etc/vsftpd/ftpusers字段，说明了PAM模块能抵挡的帐号内容来自文件/etc/vsftpd/ftpusers中</span><br><span class="hljs-meta">#pam_service_name=vsftpd</span><br><span class="hljs-meta"># 是否允许ftpusers文件中的用户登录FTP服务器，默认为NO</span><br><span class="hljs-meta"># 若此项设为YES，则user_list文件中的用户允许登录FTP服务器</span><br><span class="hljs-meta"># 而如果同时设置了userlist_deny=YES，则user_list文件中的用户将不允许登录FTP服务器，甚至连输入密码提示信息都没有</span><br><span class="hljs-meta">#userlist_enable=YES/NO</span><br><span class="hljs-meta"># 设置是否阻扯user_list文件中的用户登录FTP服务器，默认为YES</span><br><span class="hljs-meta">#userlist_deny=YES/NO</span><br><span class="hljs-meta"># 是否使用tcp_wrappers作为主机访问控制方式。</span><br><span class="hljs-meta"># tcp_wrappers可以实现linux系统中网络服务的基于主机地址的访问控制</span><br><span class="hljs-meta"># 在/etc目录中的hosts.allow和hosts.deny两个文件用于设置tcp_wrappers的访问控制</span><br><span class="hljs-meta"># 前者设置允许访问记录，后者设置拒绝访问记录。</span><br><span class="hljs-meta"># 如想限制某些主机对FTP服务器192.168.57.2的匿名访问，编缉/etc/hosts.allow文件，如在下面增加两行命令：</span><br><span class="hljs-meta"># vsftpd:192.168.57.1:DENY 和vsftpd:192.168.57.9:DENY</span><br><span class="hljs-meta"># 表明限制IP为192.168.57.1/192.168.57.9主机访问IP为192.168.57.2的FTP服务器</span><br><span class="hljs-meta"># 此时FTP服务器虽可以PING通，但无法连接</span><br>tcp_wrappers=YES<br></code></pre></td></tr></table></figure><p>VSFTPD登录方式：</p><p>vsftpd的配置项较多，但都是”配置项”=”xx”这种格式，其本身有三种登录方式</p><p>：匿名用户登录，本地用户登录，虚拟用户登录</p><h3 id="1-匿名用户登录"><a href="#1-匿名用户登录" class="headerlink" title="1.匿名用户登录"></a>1.匿名用户登录</h3><p>anonymous_enable=YES</p><p>只要设置这行就表示允许匿名用户登录了</p><p>匿名用户使用的登陆名为ftp或anonymous，口令为空</p><p>匿名用户（anonymous）设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs text">#控制是否允许匿名用户登入，YES 为允许匿名登入，NO 为不允许。默认值为 YES。<br>anonymous_enable=YES/NO（YES）<br><br>#是否允许登陆用户有写权限。属于全局设置，默认值为 YES。<br>write_enable=YES/NO（YES）<br><br>#若是启动这项功能，则使用匿名登入时，不会询问密码。默认值为 NO。<br>no_anon_password=YES/NO（NO）<br><br>#定义匿名登入的使用者名称。默认值为 ftp。<br>ftp_username=ftp<br><br>#使用匿名登入时，所登入的目录。默认值为/var/ftp。注意 ftp目录不能是 777的权限属性，即匿名用户的家目录不能有 777的权限。<br>anon_root=/var/ftp<br><br>#如果设为 YES，则允许匿名登入者有上传文件（非目录）的权限，只有在 write_enable=YES时，此项才有效。当然，匿名用户必须要有对上层目录的写入权。默认值为 NO<br>anon_upload_enable=YES/NO（NO）<br><br>#如果设为 YES，则允许匿名登入者下载可阅读的档案（可以下载到本机阅读，不能直接在 FTP服务器中打开阅读）。默认值为 YES。<br>anon_world_readable_only=YES/NO（YES）<br><br>#如果设为 YES，则允许匿名登入者有新增目录的权限，只有在 write_enable=YES时，此项才有效。当然，匿名用户必须要有对上层目录的写入权。默认值为 NO。<br>anon_mkdir_write_enable=YES/NO（NO）<br><br>#如果设为 YES，则允许匿名登入者更多于上传或者建立目录之外的权限，譬如删除或者重命名。（如<br>果 anon_upload_enable=NO，则匿名用户不能上传文件，但可以删除或者重命名已经存在的文件；如<br>果 anon_mkdir_write_enable=NO，则匿名用户不能上传或者新建文件夹，但可以删除或者重命名已经<br>存在的文件夹。）默认值为 NO。<br>anon_other_write_enable=YES/NO（NO）<br><br>#设置是否改变匿名用户上传文件（非目录）的属主。默认值为 NO。<br>chown_uploads=YES/NO（NO）<br><br>#设置匿名用户上传文件（非目录）的属主名。建议不要设置为 root。<br>chown_username=username<br><br>#设置匿名登入者新增或上传档案时的 umask 值。默认值为 077，则新建档案的对应权限为 700。<br>anon_umask=077<br><br>#若是启动这项功能，则必须提供一个档案/etc/vsftpd/banner_emails，内容为 email address。若是<br>使用匿名登入，则会要求输入 email address，若输入的 email address 在此档案内，则不允许进入。<br>默认值为 NO。<br>deny_email_enable=YES/NO（NO）<br><br>#此文件用来输入 email address，只有在 deny_email_enable=YES时，才会使用到此档案。若是使用匿名登入，则会要求输入 email address，若输入的 email address 在此档案内，则不允许进入。<br>banned_email_file=/etc/vsftpd/banner_emails<br></code></pre></td></tr></table></figure><p>匿名登录最重要的还是anonymous_enable=YES这个配置，表示启用了匿名</p><p>下面是我配置好的匿名登录配置文件：vsftpd.conf</p><blockquote><p>allow_writeable_chroot=YES<br>anonymous_enable=YES<br>no_anon_password=YES<br>ftp_username=ftp<br>anon_root=/var/ftp<br>anon_upload_enable=YES<br>anon_world_readable_only=YES<br>anon_mkdir_write_enable=YES<br>anon_other_write_enable=YES<br>chown_uploads=YES<br>chown_username=nobody<br>anon_umask=077<br>#local_enable=YES<br>#write_enable=YES<br>local_umask=022<br>dirmessage_enable=YES<br>xferlog_enable=YES<br>connect_from_port_20=YES<br>xferlog_std_format=YES<br>listen=YES<br>listen_ipv6=NO<br>pam_service_name=vsftpd<br>userlist_enable=YES<br>tcp_wrappers=YES</p></blockquote><p>其中local_enable表示的是本地用户登录，no表示本地用户不能登录，需要注意的是ftp服务的读写权限首先是配置文件里面定义的权限，然后是本地文件夹本身的权限。我这里发现一个问题是这个报错：500 OOPS: vsftpd: refusing to run with writable root inside chroot()，我去网上搜索了一下，网上基本都说是这个问题：</p><blockquote><p>从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。要修复这个错误，可以用命令chmod a-w /home/user去除用户主目录的写权限，注意把目录替换成你自己的。或者你可以在vsftpd的配置文件中增加下列两项中的一项：allow_writeable_chroot=YES</p></blockquote><p>但根据我测试，只能将根目录取消写权限。加这一行配置并没用，但根目录里面的文件或文件夹加上写权限并不会影响使用。</p><p>如测试连接出现这个报错，去掉tcp_wrappers配置重启即可：</p><p>500 OOPS: tcp_wrappers is set to YES but no tcp wrapper support compiled in</p><h3 id="2-本地用户登录"><a href="#2-本地用户登录" class="headerlink" title="2.本地用户登录"></a>2.本地用户登录</h3><p><strong>本地用户设置</strong></p><p><strong>local_enable=YES/NO****（YES）</strong></p><p>控制是否允许本地用户登入，YES 为允许本地用户登入，NO为不允许。默认值为YES。</p><p><strong>local_root=/home/username</strong></p><p>当本地用户登入时，将被更换到定义的目录下。默认值为各用户的家目录。</p><p><strong>write_enable=YES/NO****（YES）</strong></p><p>是否允许登陆用户有写权限。属于全局设置，默认值为YES。</p><p><strong>local_umask=022</strong></p><p>本地用户新增档案时的umask 值。默认值为077。</p><p><strong>file_open_mode=0755</strong></p><p>本地用户上传档案后的档案权限，与chmod 所使用的数值相同。默认值为0666</p><p>目录锁定配置：</p><p>在默认配置下，本地用户登入FTP后可以使用cd命令切换到其他目录，这样会对系统带来安全隐患。可以通过以下三条配置文件来控制用户切换目录。</p><p><strong>chroot_list_enable=YES/NO****（NO）</strong></p><p>设置是否启用chroot_list_file配置项指定的用户列表文件。默认值为NO。</p><p><strong>chroot_list_file=/etc/vsftpd.chroot_list</strong></p><p>用于指定用户列表文件，该文件用于控制哪些用户可以切换到用户家目录的上级目录。</p><p><strong>chroot_local_user=YES/NO****（NO）</strong></p><p>用于指定用户列表文件中的用户是否允许切换到上级目录。默认值为NO。</p><p><strong>通过搭配能实现以下几种效果：</strong></p><p><strong>①</strong>当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。</p><p><strong>②</strong>当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。</p><p><strong>③</strong>当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。</p><p><strong>④</strong>当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。</p><p><strong>控制用户访问：</strong></p><p>对于用户的访问控制可以通过/etc目录下的vsftpd.user_list和ftpusers文件来实现。</p><p><strong>userlist_file=/etc/vsftpd.user_list</strong></p><p>控制用户访问FTP的文件，里面写着用户名称。一个用户名称一行。</p><p><strong>userlist_enable=YES/NO****（NO）</strong></p><p>是否启用vsftpd.user_list文件。</p><p><strong>userlist_deny=YES/NO****（YES）</strong></p><p>决定vsftpd.user_list文件中的用户是否能够访问FTP服务器。若设置为YES，则vsftpd.user_list文件中的用户不允许访问FTP，若设置为NO，则只有vsftpd.user_list文件中的用户才能访问FTP。</p><p><strong>/etc/vsftpd/ftpusers</strong>文件专门用于定义不允许访问FTP服务器的用户列表（<strong>注意</strong>:如果userlist_enable=YES,userlist_deny=NO,此时如果在vsftpd.user_list和ftpusers中都有某个用户时，那么这个用户是不能够访问FTP的，即ftpusers的优先级要高）。默认情况下vsftpd.user_list和ftpusers，这两个文件已经预设置了一些不允许访问FTP服务器的系统内部账户。如果系统没有这两个文件，那么新建这两个文件，将用户添加进去即可。</p><p>下面是我配置好的本地用户登录配置文件 vsftpd.conf:</p><blockquote><p>anonymous_enable=NO<br>local_enable=YES<br>write_enable=YES<br>local_umask=022<br>dirmessage_enable=YES<br>xferlog_enable=YES<br>connect_from_port_20=YES<br>xferlog_std_format=YES<br>listen=YES<br>listen_ipv6=NO<br>pam_service_name=vsftpd<br>userlist_enable=YES<br>chroot_local_user=YES<br>local_root=/home/ftp/static<br>userlist_enable=YES<br>userlist_deny=YES</p></blockquote><p>这个配置文件匿名用户无法登录，切user_list和ftpusers里面的用户不能登录 user_list是userlist_enable启用的，ftpusers这个配置文件我没找到其定义的配置项，我怀疑应该是/etc/pam.d/vsftpd里面定义的，但这个不用深究。local_root锁定了用户家目录。</p><p>记得做完mkdir /home/ftp/static</p><h3 id="3-虚拟用户登录"><a href="#3-虚拟用户登录" class="headerlink" title="3.虚拟用户登录"></a>3.虚拟用户登录</h3><p>虚拟用户登录其登录的验证文件是/etc/pam.d/vsftpd，与本地登录不同的是，虚拟用户其本身也需要映射到一个本地用户，以本地用户来做为其权限载体，但可将多个虚拟用户映射为一个本地用户，然后在pam.d/vsftpd里面指定其用户账号密码文件，还需单独指定其虚拟用户配置文件，定义其ftp权限，ftp文件路径等。</p><p><strong>虚拟用户设置</strong></p><p>虚拟用户使用PAM认证方式。</p><p><strong>pam_service_name=vsftpd</strong></p><p>设置PAM使用的名称，默认值为/etc/pam.d/vsftpd。</p><p><strong>guest_enable= YES/NO****（NO）</strong></p><p>启用虚拟用户。默认值为NO。</p><p><strong>guest_username=ftp</strong></p><p>这里用来映射虚拟用户。默认值为ftp。</p><p><strong>virtual_use_local_privs=YES/NO****（NO）</strong></p><p>当该参数激活（YES）时，虚拟用户使用与本地用户相同的权限。当此参数关闭（NO）时，虚拟用户使用与匿名用户相同的权限。默认情况下此参数是关闭的（NO）。</p><p>首先把虚拟用户的配置文件配置好/etc/vsftpd/vsftpd.conf:</p><blockquote><p>anonymous_enable=NO<br>local_enable=YES<br>write_enable=YES<br>local_umask=022<br>dirmessage_enable=YES<br>xferlog_enable=YES<br>connect_from_port_20=YES<br>xferlog_std_format=YES<br>listen=YES<br>listen_ipv6=NO<br><strong>pam_service_name=vsftpd</strong><br>userlist_enable=YES<br>chroot_local_user=YES<br>local_root=/home/ftp/static<br>userlist_enable=YES<br>userlist_deny=YES<br><strong>guest_enable=YES<br>guest_username=vsftpd<br>anon_upload_enable=NO<br>anon_mkdir_write_enable=NO<br>anon_other_write_enable=NO<br>user_config_dir=/etc/vsftpd/vusers</strong></p></blockquote><p>guest_enable启用虚拟用户，guest_username是虚拟用户映射到本地用户的用户名，anon的三个配置项代表匿名用户与虚拟用户的权限，因每个虚拟用户权限不一致，所以先关闭权限。user_config_dir表示虚拟用户的配置文件夹，这里需要注意的是:</p><p><strong>/etc/vsftpd/vusers里面一个配置文件代表一个虚拟用户，且文件名需以虚拟用户名称来表示。</strong></p><p><strong>/etc/vsftpd/vusers/ftpuser:</strong></p><blockquote><p>local_root=/home/ftp/static<br>write_enable=YES<br>anon_world_readable_only=NO<br>anon_upload_enable=YES<br>anon_mkdir_write_enable=YES<br>anon_other_write_enable=YES</p></blockquote><p>虚拟用户配置文件有了以后，就可以生成虚拟用户认证文件了，首先上面vsftpd.conf里面guest_username=vsftpd代表虚拟用户映射为vsftpd,pam_service_name=vsftpd表示其登录认证文件为/etc/pam.d/vsftpd这个认证文件，首先先创建虚拟用户账号密码文件，然后再用pam.d/vsftpd配置文件中指定这个虚拟用户文件。</p><p>配置完的/etc/pam.d/vsftpd:</p><blockquote><p><strong>auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtualusers<br>account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtualusers</strong><br>session optional pam_keyinit.so force revoke<br>auth required pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed<br>auth required pam_shells.so<br>auth include password-auth<br>account include password-auth<br>session required pam_loginuid.so<br>session include password-auth</p></blockquote><p>上面两行为指定的虚拟用户认证文件，所以接下来需要创建virtualusers</p><p>echo -e “ftpuser\n123456” &gt; /etc/vsftpd/virtualusers</p><p>db_load -T -t hash -f /etc/vsftpd/virtualusers /etc/vsftpd/virtualusers.db</p><p>chmod 600 /etc/vsftpd/virtualusers*</p><p>mkdir /home/ftp/static;chown -R vsftpd.vsftpd /home/ftp/static</p><p>这个时候用ftp测试工具测试一下可以登录就OK了。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231036139.jpeg" alt="image.png"></p><p>容易出现的报错：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231035051.jpeg" alt="image.png"></p><p>在ftp根目录如果用户拥有写权限的话便会报错</p><p>421 Service not available, remote server has closed connection</p><h3 id="目前最容易遇到的坑："><a href="#目前最容易遇到的坑：" class="headerlink" title="目前最容易遇到的坑："></a>目前最容易遇到的坑：</h3><p>1.文件夹加了写权限导致ftp账号无法登录</p><p>2.虚拟用户的配置文件得在user_config_dir=/etc/vsftpd/vusers指定文件夹下面且每个虚拟用户一个配置文件，其文件名为自己的虚拟用户用户名</p><p>3.无法启动vsftpd，基本上都是配置文件文件，建议用vsftpd默认自带的来进行修改，或者复制文中已经写好的配置文件。</p><p>4.测试ftp连接性时尽量使用linux下的ftp工具:yum -y install ftp即可安装，因其出错时报错信息都比较准确，如果在windows直接测试的话可能直接就是无法登录，但没有对应的报错信息。</p><h1 id="5-vsftpd主动模式与被动模式"><a href="#5-vsftpd主动模式与被动模式" class="headerlink" title="5.vsftpd主动模式与被动模式"></a>5.vsftpd主动模式与被动模式</h1><p>这里主要是讲主动模式与被动模式的实现，首先是最常用的被动模式</p><h3 id="1-被动模式"><a href="#1-被动模式" class="headerlink" title="1.被动模式"></a>1.被动模式</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pasv_enable</span>=<span class="hljs-literal">yes</span> （Default: <span class="hljs-literal">YES</span>） 设置是否允许pasv模式<br><span class="hljs-attr">pasv_max_port</span>=<span class="hljs-number">10240</span> （Default: <span class="hljs-number">0</span> (use any port)） pasv使用的最大端口<br><span class="hljs-attr">pasv_min_port</span>=<span class="hljs-number">20480</span> （Default: <span class="hljs-number">0</span> (use any port)） pasv使用的最小端口<br></code></pre></td></tr></table></figure><p>被动模式为这三个选项，因pasv默认为yes，所以在vsftpd中，默认也是使用被动模式来运行的。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231035069.jpeg" alt="image.png"></p><p>定义好最大最小端口后重启并测试</p><p>systemctl restart vsftpd</p><p>然后找一个windows或linux的ftp客户端进行测试（浏览器也行）：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231035032.jpeg" alt="image.png"></p><p>服务器中ftp没连接时的信息<img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231036198.jpeg" alt="image.png"></p><p>然后用浏览器去访问ftp时的端口情况</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231036194.jpeg" alt="image.png"></p><p>可以知道，此时vsftpd开启了1408来作为传输端口，与我们配置的无异，被动模式成功运行。</p><h3 id="2-主动模式"><a href="#2-主动模式" class="headerlink" title="2.主动模式"></a>2.主动模式</h3><p>pasv_enable=NO #关闭被动模式<br>port_enable=YES #启用主动模式<br>connect_from_port_20=YES #主动式连接使用的数据通道</p><p>#Ftp_date_port=%portnumber% 上一选项使用NO参数是 指定数据传输端口</p><blockquote><p>anonymous_enable=NO<br>local_enable=YES<br>write_enable=YES<br>local_umask=022<br>dirmessage_enable=YES<br>xferlog_enable=YES<br>#connect_from_port_20=YES<br>xferlog_std_format=YES<br>listen=YES<br>listen_ipv6=NO<br>pam_service_name=vsftpd<br>userlist_enable=YES<br>chroot_local_user=YES<br>local_root=/home/ftp/static<br>userlist_enable=YES<br>userlist_deny=YES<br>guest_enable=YES<br>guest_username=vsftpd<br>anon_upload_enable=NO<br>anon_mkdir_write_enable=NO<br>anon_other_write_enable=NO<br>user_config_dir=/etc/vsftpd/vusers<br>#pasv_min_port=1380<br>#pasv_max_port=1500<br><strong>pasv_enable=NO<br>port_enable=YES<br>connect_from_port_20=YES</strong></p></blockquote><p>下面是测试：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231036816.jpeg" alt="image.png"></p><p>可以看到20端口启用了，所以主动模式成功运行了。但像浏览器，ftp命令行工具默认会使用被动模式进行连接，启用主动模式后便无法连接</p><p>所以最好用ftp工具连接，连接时还需指定用主动模式连接</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231036277.jpeg" alt="image.png"></p><p>当然，如不关闭被动模式，则主动模式将于被动模式共存。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2021/12/23/git_hexo/"/>
    <url>/2021/12/23/git_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Git是一种是分布式代码版本控制系统。可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><h1 id="git和svn的区别："><a href="#git和svn的区别：" class="headerlink" title="git和svn的区别："></a>git和svn的区别：</h1><p>1.GIT是分布式的，SVN不是:这是GIT和其它非分布式的版本控制系统，例如SVN，CVS<br>等，最核心的区别。<br>2.GIT把内容按元数据方式存储，而SVN是按文件︰所有的资源控制系统都是把文件的元信<br>息隐藏在一个类似.svn,.cvs等的文件夹里。<br>3.GIT分支和SVN的分支不同:分支在SVN中一点不特别，就是版本库中的另外的一个目<br>录。<br>4.GIT没有一个全局的版本号，而SVN有∶目前为止这是跟SVN相比GIT缺少的最大的一个特<br>征。<br>5.GIT的内容完整性要优于SVN:GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内<br>容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p><h1 id="git安装及使用"><a href="#git安装及使用" class="headerlink" title="git安装及使用"></a>git安装及使用</h1><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>centos系统使用yum安装即可（ubantu则是apt-get），git本身对版本无过多需求，所以也无需在意版本号。</p><p>yum -y install git //安装git</p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><h3 id="配置git仓库"><a href="#配置git仓库" class="headerlink" title="配置git仓库"></a>配置git仓库</h3><p>Git提供了一个叫做git config 的工具，专门用来配置或读取相应的工作环境变量。<br>这些环境变量，决定了Git在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方:<br>/etc/gitconfig文件:</p><p>系统中对所有用户都普遍适用的配置。若使用git config时用–system选项，读写的就是这个文件。<br>~/.gitconfig文件:</p><p>用户目录下的配置文件只适用于该用户。若使用git config时用-global选项，读写的就是这个文件。</p><p>当前项目的Git目录中的配置文件（也就是工作目录中的.git/config文件)︰这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以<br>.git/config里的配置会覆盖/etc/gitconfig中的同名变量。</p><p><strong>git config</strong></p><p><strong>–global 使用全局配置文件</strong></p><p><strong>–system 使用系统级配置文件</strong></p><p><strong>–local</strong> <strong>使用版本库级配置文件</strong></p><p>git config –global user.name “ysw” 配置使用用户</p><p>git config –global user.email “<a href="mailto:1@qq.com">1@qq.com</a>“ 配置使用邮箱</p><p>git config –global color.ui true 语法高亮</p><p>[root@localhost ~]# git config –list</p><p>user.name=ysw</p><p><a href="mailto:user.email=1@11.com">user.email=1@11.com</a></p><p>[root@localhost ~]# cat .gitconfig</p><p>[user]</p><p>name = ysw<br>email = <a href="mailto:1@11.com">1@11.com</a></p><p>查看设置的用户和邮箱</p><h3 id="git初始化"><a href="#git初始化" class="headerlink" title="git初始化"></a>git初始化</h3><p>mkdir git_data &amp;&amp; cd git_data</p><p>git init //初始化 在git-server上应该使用用git –bare init</p><p>git status //查看工作区状态</p><p>//查看git创建的仓库文件</p><p>[root@localhost git_data]# ll .git/</p><p>总用量 12</p><p>drwxr-xr-x 2 root root 6 5月 25 21:27 branches</p><p>-rw-r–r– 1 root root 92 5月 25 21:27 config</p><p>-rw-r–r– 1 root root 73 5月 25 21:27 description</p><p>-rw-r–r– 1 root root 23 5月 25 21:27 HEAD</p><p>drwxr-xr-x 2 root root 332 5月 25 21:27 hooks</p><p>drwxr-xr-x 2 root root 21 5月 25 21:27 info</p><p>drwxr-xr-x 4 root root 30 5月 25 21:27 objects</p><p>drwxr-xr-x 4 root root 31 5月 25 21:27 refs</p><p>branches //分支目录</p><p>config //定义项目持有的配置选项</p><p>description //仅供git web程序使用</p><p>HEAD //指示当前的分支</p><p>hooks //包含git钩子文件</p><p>info // 包含一个全局排除文件（exclude文件）</p><p>objects // 存放所有数据内容，有info和pack两个子文件</p><p>refs // 存放指向（分支）的提交对象的指针</p><p>index // 保存暂存区信息，在执行git init的时候，这个文件还没有</p><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><p>Git的几个区域:</p><p><strong>工作区:就是你在电脑里能看到的目录。<br>暂存区:英文叫stage,或index。一般存放在”git目录”下的index文件(.git/index)中，所以我们把暂存区有时也叫作索引index).<br>版本库:工作区有一个隐藏目录git。这个不算工作区，而是Git的版本库。</strong></p><p>git分为工作区域，暂存区域，本地仓库，远程仓库。在写代码时，代码首先是放到工作区域，然后上传到暂存区域，然后再是本地仓库，具体流程如下：</p><p>工作目录 暂存区域 本地仓库 远程仓库</p><p>git add –&gt; git commit–&gt; git push –&gt;</p><p>git rm &lt;– git clone/git pull &lt;–</p><p>git restore &lt;–</p><p>git reset –hard 3de15d4 &lt;————-</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107486.jpeg" alt="image.png"></p><h3 id="git命令介绍："><a href="#git命令介绍：" class="headerlink" title="git命令介绍："></a>git命令介绍：</h3><p>git add：将工作目录的代码提交至暂存区域</p><p>git rm：从工作区和索引中删除文件</p><p>git restore ：当工作区的文件删除时可通过该命令恢复,–staged为删除暂存区的文件 git –staged == git rm –cached</p><p>git reset –hard xxx:将代码代码恢复到某个版本</p><p>git commit :提交暂存仓库的代码到本地仓库</p><p>git push / git clone/git pull :推拉远程仓库到本地仓库</p><p>git mv : 移动或重命名一个文件、目录或符号链接</p><p>git clone:克隆仓库到一个新目录</p><p>git diff:显示提交之间、提交和工作区之间等的差异</p><p>git show:显示各种类型的对象(仓库中的)和git log -p一样</p><p>git log:查看仓库中的版本（只能看到已当前主版本为最新的历史版本）</p><p>git log 查看提交的仓库信息</p><p>git log –oneline 简略查看</p><p>git log -p 查看详细提交的内容</p><p>git reflog 查看所有仓库日志（git log只能看到当前主版本）</p><p>git reflog：查看仓库中所有代码版本</p><h3 id="Git使用示例："><a href="#Git使用示例：" class="headerlink" title="Git使用示例："></a>Git使用示例：</h3><p>[root@localhost git_data]# touch a b</p><p>[root@localhost git_data]# git status</p><p>位于分支 master</p><p>尚无提交</p><p>未跟踪的文件:</p><p>（使用 “git add &lt;文件&gt;…” 以包含要提交的内容）</p><p>a<br>b</p><p>提交为空，但是存在尚未跟踪的文件（使用 “git add” 建立跟踪）</p><p>[root@localhost git_data]# git add a b</p><p>[root@localhost git_data]# git status</p><p>位于分支 master</p><p>尚无提交</p><p>要提交的变更：</p><p>（使用 “git rm –cached &lt;文件&gt;…” 以取消暂存）</p><p>新文件： a<br>新文件： b</p><p><strong>//此时a，b文件已经上传到暂存区域</strong></p><p>[root@localhost git_data]# git commit -m “new” a b</p><p>[master（根提交） 0958221] new</p><p>2 files changed, 0 insertions(+), 0 deletions(-)</p><p>create mode 100644 a</p><p>create mode 100644 b</p><p>[root@localhost git_data]# git log</p><p>commit 0958221eeae14b91800e79af6e9056d202a7a22c (HEAD -&gt; master)</p><p>Author: ysw <a href="mailto:1@11.com">1@11.com</a></p><p>Date: Tue May 25 22:34:59 2021 -0400</p><p>New</p><p><strong>//Git仓库里面可以看到已提交的。</strong></p><p>[root@localhost git_data]# git status</p><p>位于分支 master</p><p>无文件要提交，干净的工作区</p><p><strong>//提交完以后工作区就没有可以提交的了。</strong></p><h4 id="删除工作区域并恢复："><a href="#删除工作区域并恢复：" class="headerlink" title="删除工作区域并恢复："></a>删除工作区域并恢复：</h4><p>[root@localhost git_data]# rm -rf a b</p><p>[root@localhost git_data]# git restore a b</p><p>//此时文件就恢复了</p><p>用git rm删除：</p><p>[root@localhost git_data]# git rm a145 b145</p><p>rm ‘a145’</p><p>rm ‘b145’</p><p>[root@localhost git_data]# git reset –hard HEAD</p><p>//这里无法通过restore进行恢复，因为git rm是直接将本地和暂存区的都删除了，只能去本地仓库拉取。</p><h4 id="改名："><a href="#改名：" class="headerlink" title="改名："></a>改名：</h4><p>[root@localhost git_data]# git mv a a145</p><p>[root@localhost git_data]# git mv b b145</p><p>[root@localhost git_data]# ll</p><p>总用量 0</p><p>-rw-r–r– 1 root root 0 5月 25 22:41 a145</p><p>-rw-r–r– 1 root root 0 5月 25 22:41 b145</p><p>提交重命名的文件:</p><p>[root@localhost git_data]# git status</p><p>位于分支 master</p><p>要提交的变更：</p><p>（使用 “git restore –staged &lt;文件&gt;…” 以取消暂存）</p><p>重命名： a -&gt; a145<br>重命名： b -&gt; b145</p><p>[root@localhost git_data]# git commit -m “145” a145 b145</p><p>[master 9b2380a] 145</p><p>2 files changed, 0 insertions(+), 0 deletions(-)</p><p>create mode 100644 a145</p><p>create mode 100644 b145</p><h4 id="将工作区域更新到仓库某一版本："><a href="#将工作区域更新到仓库某一版本：" class="headerlink" title="将工作区域更新到仓库某一版本："></a>将工作区域更新到仓库某一版本：</h4><p>[root@localhost git_data]# git log –oneline</p><p>9b2380a (HEAD -&gt; master) 145</p><p>0958221 new</p><p>[root@localhost git_data]# git reset –hard HEAD</p><p>HEAD 现在位于 9b2380a 145</p><h4 id="删除暂存区的代码文件："><a href="#删除暂存区的代码文件：" class="headerlink" title="删除暂存区的代码文件："></a>删除暂存区的代码文件：</h4><p>[root@localhost git_data]# echo 111 &gt; c</p><p>[root@localhost git_data]# echo 222 &gt; d</p><p>[root@localhost git_data]# git add c d</p><p>[root@localhost git_data]# git status c d</p><p>位于分支 master</p><p>要提交的变更：</p><p>（使用 “git restore –staged &lt;文件&gt;…” 以取消暂存）</p><p>新文件： c<br>新文件： d</p><p>[root@localhost git_data]# git restore –staged c d</p><p>[root@localhost git_data]# git status c d</p><p>位于分支 master</p><p>未跟踪的文件:</p><p>（使用 “git add &lt;文件&gt;…” 以包含要提交的内容）</p><p>c<br>d</p><p>提交为空，但是存在尚未跟踪的文件（使用 “git add” 建立跟踪）</p><p>[root@localhost git_data]# git add c d</p><p>[root@localhost git_data]# git rm –cached c d</p><p>rm ‘c’</p><p>rm ‘d’</p><p>[root@localhost git_data]# git status</p><p>位于分支 master</p><p>未跟踪的文件:</p><p>（使用 “git add &lt;文件&gt;…” 以包含要提交的内容）</p><p>c<br>d</p><p>提交为空，但是存在尚未跟踪的文件（使用 “git add” 建立跟踪）</p><h4 id="git文件比对："><a href="#git文件比对：" class="headerlink" title="git文件比对："></a>git文件比对：</h4><p>git比对工作区和暂存区的区别 diff：</p><p>[root@localhost git_data]# git diff a.txt1</p><p>diff –git a/a.txt1 b/a.txt1</p><p>index e69de29..2aaba2d 100644</p><p>— a/a.txt1</p><p>+++ b/a.txt1</p><p>@@ -0,0 +1 @@</p><p>+asdfasfasf</p><p>[root@localhost git_data]# git commit -m “new2 “ a.txt1</p><p>[master 4e17e88] new2</p><p>1 file changed, 1 insertion(+)</p><p>create mode 100644 a.txt1</p><p>[root@localhost git_data]# git diff a.txt1</p><p>对比暂存区和仓库的区别</p><p>[root@localhost git_data]# git add a.txt1</p><p>[root@localhost git_data]# git diff –cached a.txt1</p><p>diff –git a/a.txt1 b/a.txt1</p><p>index 2aaba2d..cc6fda8 100644</p><p>— a/a.txt1</p><p>+++ b/a.txt1</p><p>@@ -1 +1 @@</p><p>-asdfasfasf</p><p>+1ds</p><h3 id="git标签"><a href="#git标签" class="headerlink" title="git标签"></a>git标签</h3><p>git tag -a v1.0 -m “banben” //为当前版本库打上标签，如要为指定版本库打标签可先用git reflog找到对应版本的hash值，然后git tag -a v1.0 4e17e88 -m “banben”</p><p>git tag //查看历史标签</p><p>git reset –hard v1.0 //可以通过标签名回滚<br><strong>//git的使用本身并没有太多难度，大多数主要就是围绕着工作区域，暂存区域和本地仓库的工作，其流程无非就是在工作区域编写代码然后上传到暂存区域再上传到本地仓库，暂存区域和工作区域的代码文件即使删除也可以通过本地仓库找回来。需要注意的是如果将版本更新到仓库最新以前的版本之后使用git log是看不到最新的版本，只能看到当前主版本及以前的代码，使用log reflog可以看到所有的。</strong></p><h3 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h3><p>分支即使平行空间，假设你在为某个手机系统研发拍照功能，代码已经完成了80%，但如果将这不完整的代码直接提供到git仓库中，又可能影响其他人的工作，此时我们便可以在该软件的项目上创建一个名叫“拍照功能”的分支，这个分支只属于你自己，而其他人看不到，等代码编写完成后再与原来的项目主分支合并下即可，这样既能保证代码不丢失，又不影响其他人的工作。</p><p>git log –oneline –decorate 默认分支指向最后一次的master分支</p><p>git branch testing 新增分支</p><p>git branch 查看分支</p><p>git checkout testing 切换分支</p><p>git branch -d testing 删除分支</p><p>git merge xxx 合并分支</p><h4 id="合并例："><a href="#合并例：" class="headerlink" title="合并例："></a>合并例：</h4><p>[root@localhost git_data]# git branch testing // 添加分支</p><p>[root@localhost git_data]# git checkout testing //切换分支</p><p>A c</p><p>A d</p><p>切换到分支 ‘testing’</p><p>[root@localhost git_data]# ll</p><p>总用量 8</p><p>-rw-r–r– 1 root root 0 5月 25 22:52 a</p><p>-rw-r–r– 1 root root 0 5月 25 23:31 a145</p><p>-rw-r–r– 1 root root 0 5月 25 22:52 b</p><p>-rw-r–r– 1 root root 0 5月 25 23:31 b145</p><p>-rw-r–r– 1 root root 4 5月 25 23:43 c</p><p>-rw-r–r– 1 root root 4 5月 25 23:38 d</p><p>[root@localhost git_data]# echo dfaf &gt; testing</p><p>[root@localhost git_data]# git add testing</p><p>[root@localhost git_data]# git commit -m “testing” testing</p><p>[testing aed242b] testing</p><p>1 file changed, 1 insertion(+)</p><p>create mode 100644 testing</p><p>[root@localhost git_data]# git log –oneline</p><p>aed242b (HEAD -&gt; testing) testing</p><p>9b2380a (master) 145</p><p>0958221 new</p><p>//在这个分支上新增代码并上传</p><p>[root@localhost git_data]# git checkout master</p><p>A c</p><p>A d</p><p>切换到分支 ‘master’</p><p>[root@localhost git_data]# ll</p><p>总用量 8</p><p>-rw-r–r– 1 root root 0 5月 25 22:52 a</p><p>-rw-r–r– 1 root root 0 5月 25 23:31 a145</p><p>-rw-r–r– 1 root root 0 5月 25 22:52 b</p><p>-rw-r–r– 1 root root 0 5月 25 23:31 b145</p><p>-rw-r–r– 1 root root 4 5月 25 23:43 c</p><p>-rw-r–r– 1 root root 4 5月 25 23:38 d</p><p>[root@localhost git_data]# git merge testing</p><p>更新 9b2380a..aed242b</p><p>Fast-forward</p><p>testing | 1 +</p><p>1 file changed, 1 insertion(+)</p><p>create mode 100644 testing</p><p>//切换到主版本并合并分支</p><p>[root@localhost git_data]# ll</p><p>总用量 12</p><p>-rw-r–r– 1 root root 0 5月 25 22:52 a</p><p>-rw-r–r– 1 root root 0 5月 25 23:31 a145</p><p>-rw-r–r– 1 root root 0 5月 25 22:52 b</p><p>-rw-r–r– 1 root root 0 5月 25 23:31 b145</p><p>-rw-r–r– 1 root root 4 5月 25 23:43 c</p><p>-rw-r–r– 1 root root 4 5月 25 23:38 d</p><p>-rw-r–r– 1 root root 5 5月 26 01:54 testing</p><p>[root@localhost git_data]# git log –oneline</p><p>aed242b (HEAD -&gt; master, testing) testing</p><p>9b2380a 145</p><p>0958221 new</p><p>//<strong>新增分支时分支会复制主版本master的所有代码文件，此时分支与master一样，在分支上新增了代码后，这时分支上的代码比主版本新，可以通过merge合并分支。合并时如果代码冲突会合并失败，合并失败需手动修正冲突。</strong></p><h1 id="git远程仓库："><a href="#git远程仓库：" class="headerlink" title="git远程仓库："></a>git远程仓库：</h1><p>这里有两台主机，分别是git-server和git-client，虽然git是分布式，但是为了区分一下就这样命名了。</p><p>这里是git-server上已经建立好的仓库（master分支）：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107572.jpeg" alt="image.png"></p><p>git-client：</p><p>git clone <a href="ssh://10.10.10.85/root/git/.git">ssh://10.10.10.85/root/git/.git</a> //需要输入密码，如果不想输入密码可以通过ssh-keygen生成密钥将公钥传到server上这样client可以免密登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ysw-virtual-machine:/git-core<span class="hljs-comment"># ll git/total 36</span><br>drwxr-xr-x 3 root root 4096 Jun  4 01:43 ./<br>drwxr-xr-x 4 root root 4096 Jun  4 01:43 ../<br>-rw-r--r-- 1 root root    8 Jun  4 01:43 1<br>-rw-r--r-- 1 root root    5 Jun  4 01:43 2<br>-rw-r--r-- 1 root root    5 Jun  4 01:43 3<br>-rw-r--r-- 1 root root    8 Jun  4 01:43 4<br>-rw-r--r-- 1 root root    2 Jun  4 01:43 5<br>drwxr-xr-x 8 root root 4096 Jun  4 01:43 .git/<br>-rw-r--r-- 1 root root    8 Jun  4 01:43 ysw<br></code></pre></td></tr></table></figure><p>此时便克隆成功了</p><p>还有一种方式是通过git remote add：</p><p>clone无需创建文件夹，可以直接把库复制过来，remote要麻烦一点,需要手动创建文件夹以及空库</p><p>首先创建一个文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bas">root@ysw-virtual-machine:~ mkdir /yswroot@ysw-virtual-machine:~# cd /ysw<br>root@ysw-virtual-machine:/ysw# git init<br>Initialized empty Git repository in /ysw/.git/<br>root@ysw-virtual-machine:/ysw# git remote add origin ssh://10.10.10.85/root/git/.git<br>root@ysw-virtual-machine:/ysw# git pull origin master<br>root@10.10.10.85&#x27;s password:<br>remote: Enumerating objects: 11, done.<br>remote: Counting objects: 100% (11/11), done.<br>remote: Compressing objects: 100% (6/6), done.<br>remote: Total 11 (delta 2), reused 0 (delta 0)<br>Unpacking objects: 100% (11/11), 640 bytes | 128.00 KiB/s, done.<br>From ssh://10.10.10.85/root/git/branch            master     -&gt; FETCH_HEAD[new branch]      master     -&gt; origin/master<br>root@ysw-virtual-machine:/ysw# ll<br>total 36<br>drwxr-xr-x  3 root root 4096 Jun  4 01:49 ./<br>drwxr-xr-x 23 root root 4096 Jun  4 01:48 ../<br>-rw-r--r--  1 root root    8 Jun  4 01:49 1<br>-rw-r--r--  1 root root    5 Jun  4 01:49 2<br>-rw-r--r--  1 root root    5 Jun  4 01:49 3<br>-rw-r--r--  1 root root    8 Jun  4 01:49 4<br>-rw-r--r--  1 root root    2 Jun  4 01:49 5<br>drwxr-xr-x  8 root root 4096 Jun  4 01:49 .git/<br>-rw-r--r--  1 root root    8 Jun  4 01:49 ysw<br></code></pre></td></tr></table></figure><p>此时就成功了</p><h2 id="在本地创建新代码并推送至远程仓库："><a href="#在本地创建新代码并推送至远程仓库：" class="headerlink" title="在本地创建新代码并推送至远程仓库："></a>在本地创建新代码并推送至远程仓库：</h2><p><strong>首先将在本地创建测试代码并上传到本地仓库：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">root@ysw-<span class="hljs-keyword">virtual</span>-machine:/ysw<span class="hljs-meta"># echo ceshi &gt;ceshi</span><br>root@ysw-<span class="hljs-keyword">virtual</span>-machine:/ysw<span class="hljs-meta"># git add ceshi</span><br>root@ysw-<span class="hljs-keyword">virtual</span>-machine:/ysw<span class="hljs-meta"># git commit -m <span class="hljs-meta-string">&quot;ceshi&quot;</span> ceshi</span><br>[master <span class="hljs-number">9</span>a3d5d5] ceshi<br><span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> <span class="hljs-built_in">insertion</span>(+)<br>create mode <span class="hljs-number">100644</span> ceshi<br></code></pre></td></tr></table></figure><p><strong>然后上传到远程仓库</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">```root@ysw-<span class="hljs-keyword">virtual</span>-machine:/ysw<span class="hljs-meta"># git push -u origin master</span><br>root@<span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.85&#x27;</span>s password:<br>Enumerating objects: <span class="hljs-number">4</span>, done.<br>Counting objects: <span class="hljs-number">100</span>% (<span class="hljs-number">4</span>/<span class="hljs-number">4</span>), done.<br>Delta compression <span class="hljs-keyword">using</span> up to <span class="hljs-number">2</span> threads<br>Compressing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">2</span>/<span class="hljs-number">2</span>), done.<br>Writing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">3</span>/<span class="hljs-number">3</span>), <span class="hljs-number">247</span> bytes | <span class="hljs-number">247.00</span> KiB/s, done.<br>Total <span class="hljs-number">3</span> (delta <span class="hljs-number">1</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>To ssh:<span class="hljs-comment">//10.10.10.85/root/git/.git</span><br><span class="hljs-number">111</span>c7d3.<span class="hljs-number">.9</span>a3d5d5  master -&gt; master<br>Branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-keyword">set</span> up to track remote branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><p><strong>git-server：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tap">root@ysw-virtual-machine:~/git<span class="hljs-comment"># git reflog</span><br>9a3d5d5 (HEAD -&gt; master) HEAD@&#123;0&#125;: push<br>111c7d3 HEAD@&#123;1&#125;: commit: new 3<br>1412870 HEAD@&#123;2&#125;: reset: moving to HEAD<br>1412870 HEAD@&#123;3&#125;: push<br>76eca6c HEAD@&#123;4&#125;: commit (initial): new<br>root@ysw-virtual-machine:~/git<span class="hljs-comment"># git reset --hard</span><br>HEAD is now at 9a3d5d5 ceshi<br>root@ysw-virtual-machine:~/git<span class="hljs-comment"># ll</span><br>total 40<br>drwxr-xr-x<span class="hljs-number"> 3 </span>root root<span class="hljs-number"> 4096 </span>Jun <span class="hljs-number"> 4 </span>01:53 ./<br>drwx------<span class="hljs-number"> 5 </span>root root<span class="hljs-number"> 4096 </span>Jun <span class="hljs-number"> 3 </span>20:59 ../<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 8 </span>Jun <span class="hljs-number"> 3 </span>19:39 1<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 5 </span>Jun <span class="hljs-number"> 3 </span>19:39 2<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 5 </span>Jun <span class="hljs-number"> 3 </span>19:39 3<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 8 </span>Jun <span class="hljs-number"> 3 </span>20:24 4<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 2 </span>Jun <span class="hljs-number"> 3 </span>20:42 5<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 6 </span>Jun <span class="hljs-number"> 4 </span>01:53 ceshi<br>drwxr-xr-x<span class="hljs-number"> 8 </span>root root<span class="hljs-number"> 4096 </span>Jun <span class="hljs-number"> 4 </span>01:53 .git/<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 8 </span>Jun <span class="hljs-number"> 3 </span>20:24 ysw<br></code></pre></td></tr></table></figure><h1 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h1><p>GitLab是一个用于仓库管理系统的开源项目。使用Cit作为代码管理工具，并在此基础上搭建起来的web服务。可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用。</p><h2 id="gitlab服务构成："><a href="#gitlab服务构成：" class="headerlink" title="gitlab服务构成："></a>gitlab服务构成：</h2><p>nginx静态web服务器<br>gitlab-workhorse:轻量级的反向代理服务器<br>logrotate：日志文件管理工具<br>postgresql：数据库<br>redis：缓存数据库<br>sidekiq：用在后台执行队列任务（异步执行）。（Ruby）<br>unicorn:an http server for rack applications .gitlab rails应用是托管在这个服务器上面的</p><h2 id="gitlab安装"><a href="#gitlab安装" class="headerlink" title="gitlab安装:"></a>gitlab安装:</h2><h3 id="redhad"><a href="#redhad" class="headerlink" title="redhad:"></a>redhad:</h3><p>sudo dnf install -y curl policycoreutils openssh-server perl<br><a href="https://packages.gitlab.com/gitlab/">https://packages.gitlab.com/gitlab/</a> //去官网下载包<br>curl -s <a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh">https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh</a> | sudo bash<br>sudo yum install gitlab-ce-13.11.4-ce.0.el8.x86_64</p><h3 id="ubuntu安装-（换成国内源）"><a href="#ubuntu安装-（换成国内源）" class="headerlink" title="ubuntu安装:（换成国内源）"></a>ubuntu安装:（换成国内源）</h3><ol><li>安装配置依赖项 sudo apt-get update<br> sudo apt-get install -y curl openssh-server ca-certificates</li></ol><p>2.安装发送邮件的（可以用自己熟悉的代替） sudo apt-get install -y postfix</p><p>安装过程中会弹出对话框，按TAB键让按钮点亮后按Enter或者空格。填文字的地方随便写，是邮件中显示的发送者。</p><p>3.下载安装脚本 curl <a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh">https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh</a> | sudo bash</p><p>4.修改安装脚本 vim /etc/apt/sources.list.d/gitlab_gitlab-ce.list</p><p>把原来的两行删除或者注释（#是行注释），然后增加<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu</a> bionic main<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu</a> bionic main</p><p>再次执行<br>sudo apt-get update<br><a href="http://t.zoukankan.com/whm-blog-p-11557498.html">http://t.zoukankan.com/whm-blog-p-11557498.html</a><br>5.安装<br>sudo apt-get install gitlab-ce=13.10.5-ce.0<br>完成后需要改一下external_url，将其改为本机的ip地址（访问地址）<br>vim /etc/gitlab/gitlab.rb：<br>external_url ‘<a href="http://10.10.10.10/">http://10.10.10.10</a>‘</p><p>sudo gitlab-ctl reconfigure<br>初始化完成以后<br>gitlab-ctl status //查看gitlab进程状态<br>gitlab-ctl start //启动，但初始化完成会自动启动，不用再启动。<br>访问地址：<a href="http://ip/">http://ip</a><br>启动了以后访问出现报错：<br>Whoops, GitLab is taking too much time to respond. 502<br>可以free -h看一下内存，一般是内存不够</p><h2 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h2><p>第一次登录需要修改密码，账号为root。首页：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107468.jpeg" alt="image.png"></p><h3 id="注册限制："><a href="#注册限制：" class="headerlink" title="注册限制："></a>注册限制：</h3><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107491.jpeg" alt="image.png"></p><p>设置了注册限制以后无法在登录页面注册，只能通过管理员账号添加注册账号</p><h3 id="中文设置："><a href="#中文设置：" class="headerlink" title="中文设置："></a>中文设置：</h3><p>首次登陆需要重置密码，用户为root，然后设置流程为<br>右上角的头像-preferences-Localization-language-简体中文</p><h3 id="备份："><a href="#备份：" class="headerlink" title="备份："></a>备份：</h3><p>对gitlab进行备份将会创建一个包含所有库和附件的归档文件。对备份的恢复只能恢复到与备份时的gitlab相同的版本。将gitlab迁移到另一台服务器上的最佳方法就是通过备份和还原。<br>gitlab提供了一个简单的命令行来备份整个gitlab，并且能灵活的满足需求。<br>备份文件将保存在配置文件中定义的backup_path中，文件名为TIMESTAMP_gitlab_backup.tar,TIMESTAMP为备份时的时间。TIMESTAMP的格式为:EPOCH_YYYY_MM_DD_Gitlab-version.<br>如果自定义备份目录需要赋予git权限<br>配置文件中加入<br>gitlab_rails[‘backup_path’] = “/data/ backup/gitlab”<br>gitlab_rails[‘backup_keep_time’ = 604800</p><p>备份保留的时间(以秒为单位，这个是七天默认值)，</p><p>mkdir / data/ backup/gitlab<br>chown -R git.git /data/ backup/gitlab</p><p>完成后执行gitlab-ctl reconfigure</p><p>备份<br>gitlab-rake gitlab:backup:create<br>恢复<br>gitlab-rake gitlab:backup:restore BACKUP=1537261122_2018_09_18_9.2.5</p><h3 id="gitlab配置smtp邮件功能："><a href="#gitlab配置smtp邮件功能：" class="headerlink" title="gitlab配置smtp邮件功能："></a>gitlab配置smtp邮件功能：</h3><p>vim /etc/gitlab/gitlab.rb:<br>gitlab_rails[‘smtp_enable’] = true<br>gitlab_rails[‘smtp_address’] = “smtp.qq.com”<br>gitlab_rails[‘smtp_port’] = 465<br>gitlab_rails[‘smtp_user_name’] = “<a href="mailto:1072023998@qq.com">1072023998@qq.com</a>“<br>gitlab_rails[‘smtp_password’] = “jlgwsbmvbedebfdf”<br>gitlab_rails[‘smtp_domain’] = “smtp.qq.com”<br>gitlab_rails[‘smtp_authentication’] = “login”<br>gitlab_rails[‘smtp_enable_starttls_auto’] = true<br>gitlab_rails[‘smtp_tls’] = true<br>gitlab_rails[‘smtp_pool’] = false<br>gitlab_rails[‘gitlab_email_enabled’]=true<br>gitlab_rails[‘gitlab_email_display_name’]=’gitlab’<br>gitlab_rails[‘gitlab_email_from’]<a href="mailto:='1072023998@qq.com">=‘1072023998@qq.com</a>‘<br>gitlab_rails[‘gitlab_email_reply_to’]<a href="mailto:='1072023998@qq.com">=‘1072023998@qq.com</a>‘<br>gitlab_rails[‘gitlab_email_subject_suffix’]=’[gitlab]’</p><p>修改完成后初始化配置<br>gitlab-ctl reconfigure<br>gitlab-ctl stop &amp;&amp;gitlab-ctl start</p><p>完成以后测试：<br>gitlab-rails console<br>irb(main):002:0&gt;<br>Notify.test_email(<a href="mailto:'1072023998@qq.com">‘1072023998@qq.com</a>‘,’Message Subject’,’Message Body’).deliver_now<br>测试邮件发送后前往邮箱查看</p><h3 id="创建用户，组，项目："><a href="#创建用户，组，项目：" class="headerlink" title="创建用户，组，项目："></a>创建用户，组，项目：</h3><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107595.jpeg" alt="image.png"></p><h4 id="新建用户："><a href="#新建用户：" class="headerlink" title="新建用户："></a>新建用户：</h4><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107479.jpeg" alt="image.png"></p><p>这里如果输入了正确的邮箱并设置了发送邮箱的服务器，便会在用户创建完成以后向该邮箱发送邮件</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107803.jpeg" alt="image.png"></p><p>点击修改密码</p><h4 id="创建群组："><a href="#创建群组：" class="headerlink" title="创建群组："></a>创建群组：</h4><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107034.jpeg" alt="image.png"></p><p>将用户加入群组并授予开发者权限</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231108174.jpeg" alt="image.png"></p><h4 id="新建项目："><a href="#新建项目：" class="headerlink" title="新建项目："></a>新建项目：</h4><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107216.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107267.jpeg" alt="image.png"></p><p>邀请成员或群组便可以使其加入该项目</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231108205.jpeg" alt="image.png"></p><p>此时就应该将gitlab作为git的远程仓库来进行使用了。</p><h3 id="将gitlab作为git的远程仓库："><a href="#将gitlab作为git的远程仓库：" class="headerlink" title="将gitlab作为git的远程仓库："></a>将gitlab作为git的远程仓库：</h3><p>下面是创建完后gitlab自带的命令行指示：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Git</span> 全局设置<br><span class="hljs-symbol">git</span> config --<span class="hljs-meta">global</span> user.name <span class="hljs-string">&quot;Administrator&quot;</span><br><span class="hljs-symbol">git</span> config --<span class="hljs-meta">global</span> user.email <span class="hljs-string">&quot;admin@example.com&quot;</span><br><br>创建一个新仓库<br><span class="hljs-symbol">git</span> clone http:<span class="hljs-comment">//10.10.10.90/root/dev.git</span><br><span class="hljs-symbol">cd</span> dev<br><span class="hljs-symbol">touch</span> README.md<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> README.md<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;add README&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin master<br><br>推送现有文件夹<br><span class="hljs-symbol">cd</span> existing_folder<br><span class="hljs-symbol">git</span> init<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin http:<span class="hljs-comment">//10.10.10.90/root/dev.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin master<br><br>推送现有的 Git 仓库<br><span class="hljs-symbol">cd</span> existing_repo<br><span class="hljs-symbol">git</span> remote rename origin old-origin<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin http:<span class="hljs-comment">//10.10.10.90/root/dev.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin --all<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin --tags<br></code></pre></td></tr></table></figure><p>如果是gitlab有数据git上没有就在git上使用clone。如果是将git上的代码仓库推送到gitlab上就用推送现有文件夹或推送现有仓库。</p><p>因git与gitlab传输时可以通过两种方式，http与ssh</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107774.jpeg" alt="image.png"></p><p>这里我们使用ssh，首先在linux（git-server）上创建秘钥并把公钥传到gitlab上以实现免密传输。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen<br>cat /root/.ssh/id_rsa.pub //将里面的内容复制到gitlab<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107828.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107040.jpeg" alt="image.png"></p><p>粘贴复制的公钥</p><p>由于这里git本地已有仓库，就通过remote设置远程仓库然后将代码推送过去</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231108089.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231108427.jpeg" alt="image.png"></p><p>此时刷新一下gitlab可以看到</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231107419.jpeg" alt="image.png"></p><p>所有代码文件都上传上来了！</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jdk环境变量</title>
    <link href="/2021/12/23/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F_hexo/"/>
    <url>/2021/12/23/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F_hexo/</url>
    
    <content type="html"><![CDATA[<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/java/jdk1.8.0_131 <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$&#123;JAVA_HOME&#125;/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="hljs-variable">$CLASSPATH</span> <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_PATH</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:$&#123;JRE_HOME&#125;/bin <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$&#123;JAVA_PATH&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>keepalived</title>
    <link href="/2021/12/23/keepalived_hexo/"/>
    <url>/2021/12/23/keepalived_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>keepalived服务是一个高可用服务，用于解决服务器单点故障，保证服务器能执行高可用。一般keepalived于lvs一起使用，本身其就有检查lvs的状态功能。</p><p>keepalived基于VRRP协议，VRRP是虚拟路由器冗余协议，VRRP出现的目的就是为了解决静态路由单点故障问题的，它能够保证当个别节点宕机时，整个网络可以不间断地运行。</p><p>keepalived配置完毕以后，根据配置文件内容，会将多个服务器定义为一组实例，生成一个或多个虚拟IP和虚拟MAC地址，一般为一个主节点和一个（或多个）备用节点，正常情况下其VIP（虚拟IP）和对应MAC地址会在主节点中监听并向外提供服务，当主节点出现故障时，其备用节点就会监听其IP代替主节点提供服务（如有多个备用节点会根据其优先级大小对比）。所以对用户来说，即使挂掉一个或多个服务器仍能正常访问到，也就实现了高可用。</p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>安装一般有两种方式，yum或者源码安装，yum安装的话阿里云或者国内常见源都有keepalived的包，如果是源码安装就需要去官方下载</p><p>官方地址：<a href="https://keepalived.org/">https://keepalived.org/</a></p><h2 id="yum安装："><a href="#yum安装：" class="headerlink" title="yum安装："></a>yum安装：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list keepalived<br><br>yum -y install keepalived<br></code></pre></td></tr></table></figure><h2 id="源码安装："><a href="#源码安装：" class="headerlink" title="源码安装："></a>源码安装：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wget">tar -xvf keepalived-2.2.1.tar.gz<br><br>cd keepalived-2.2.1<br><br>./configure --prefix=/usr/local/keepalived<br><br>make&amp;&amp;make install<br></code></pre></td></tr></table></figure><h1 id="2-keepalived配置文件"><a href="#2-keepalived配置文件" class="headerlink" title="2.keepalived配置文件"></a>2.keepalived配置文件</h1><p>/etc/keepalived/keepalived.conf (源码安装一般在自身目录下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs bash">! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;                                     <span class="hljs-comment">#全局定义部分</span><br>    notification_email &#123;                          <span class="hljs-comment">#设置报警邮件地址，可设置多个</span><br>        acassen@firewall.loc                      <span class="hljs-comment">#接收通知的邮件地址</span><br>    &#125;  <br>    notification_email_from test0@163.com         <span class="hljs-comment">#设置 发送邮件通知的地址</span><br>    smtp_server smtp.163.com                      <span class="hljs-comment">#设置 smtp server 地址，可是ip或域名.可选端口号 （默认25）</span><br>    smtp_connect_timeout 30                       <span class="hljs-comment">#设置 连接 smtp server的超时时间</span><br>    router_id LVS_DEVEL                           <span class="hljs-comment">#主机标识，用于邮件通知</span><br>    vrrp_skip_check_adv_addr   <br>    vrrp_strict                                   <span class="hljs-comment">#严格执行VRRP协议规范，此模式不支持节点单播</span><br>    vrrp_garp_interval 0   <br>    vrrp_gna_interval 0   <br>    script_user keepalived_script                 <span class="hljs-comment">#指定运行脚本的用户名和组。默认使用用户的默认组。如未指定，默认为keepalived_script 用户，如无此用户，则使用root</span><br>    enable_script_security                        <span class="hljs-comment">#如过路径为非root可写，不要配置脚本为root用户执行。</span><br>&#125;   <br>vrrp_sync_group &#123;<br>group&#123;<br>VI_1<br>VI_2<br>&#125;<br>&#125;<br>vrrp_script chk_nginx_service &#123;                   <span class="hljs-comment">#VRRP 脚本声明</span><br>    script <span class="hljs-string">&quot;/etc/keepalived/chk_nginx.sh&quot;</span>         <span class="hljs-comment">#周期性执行的脚本</span><br>    interval 3                                    <span class="hljs-comment">#运行脚本的间隔时间，秒</span><br>    weight -20                                    <span class="hljs-comment">#权重，priority值减去此值要小于备服务的priority值</span><br>    fall 3                                        <span class="hljs-comment">#检测几次失败才为失败，整数</span><br>    rise 2                                        <span class="hljs-comment">#检测几次状态为正常的，才确认正常，整数</span><br>    user keepalived_script                        <span class="hljs-comment">#执行脚本的用户或组</span><br>&#125;   <br><br>vrrp_instance VI_1 &#123;                              <span class="hljs-comment">#vrrp 实例部分定义，VI_1自定义名称</span><br>    state MASTER                                  <span class="hljs-comment">#指定 keepalived 的角色，必须大写 可选值：MASTER|BACKUP</span><br>    interface ens33                               <span class="hljs-comment">#网卡设置，lvs需要绑定在网卡上，realserver绑定在回环口。区别：lvs对访问为外，realserver为内不易暴露本机信息</span><br>    virtual_router_id 51                          <span class="hljs-comment">#虚拟路由标识，是一个数字，同一个vrrp 实例使用唯一的标识，MASTER和BACKUP 的 同一个 vrrp_instance 下 这个标识必须保持一致</span><br>    priority 100                                  <span class="hljs-comment">#定义优先级，数字越大，优先级越高。</span><br>    advert_int 1                                  <span class="hljs-comment">#设定 MASTER 与 BACKUP 负载均衡之间同步检查的时间间隔，单位为秒，两个节点设置必须一样</span><br>    authentication &#123;                              <span class="hljs-comment">#设置验证类型和密码，两个节点必须一致</span><br>        auth_type PASS  <br>        auth_pass 1111  <br>    &#125;   <br>    virtual_ipaddress &#123;                           <span class="hljs-comment">#设置虚拟IP地址，可以设置多个虚拟IP地址，每行一个</span><br>        192.168.119.130   <br>    &#125;<br>    track_script &#123;                                <span class="hljs-comment">#脚本监控状态</span><br>        chk_nginx_service                         <span class="hljs-comment">#可加权重，但会覆盖声明的脚本权重值。chk_nginx_service weight -20</span><br>    &#125;<br>        notify_master <span class="hljs-string">&quot;/etc/keepalived/start_haproxy.sh start&quot;</span>  <span class="hljs-comment">#当前节点成为master时，通知脚本执行任务</span><br>        notify_backup <span class="hljs-string">&quot;/etc/keepalived/start_haproxy.sh stop&quot;</span>   <span class="hljs-comment">#当前节点成为backup时，通知脚本执行任务</span><br>        notify_fault  <span class="hljs-string">&quot;/etc/keepalived/start_haproxy.sh stop&quot;</span>   <span class="hljs-comment">#当当前节点出现故障，执行的任务; </span><br>&#125;   <br><br>virtual_server 192.168.119.130 80  &#123;          <span class="hljs-comment">#定义RealServer对应的VIP及服务端口，IP和端口之间用空格隔开</span><br>    delay_loop 6                              <span class="hljs-comment">#每隔6秒查询realserver状态</span><br>    lb_algo rr                                <span class="hljs-comment">#后端调试算法（load balancing algorithm）</span><br>    lb_kind DR                                <span class="hljs-comment">#LVS调度类型NAT/DR/TUN</span><br>    <span class="hljs-comment">#persistence_timeout 60                   同一IP的连接60秒内被分配到同一台realserver</span><br>    protocol TCP                              <span class="hljs-comment">#用TCP协议检查realserver状态</span><br>    real_server 192.168.119.120 80 &#123;  <br>        weight 1                              <span class="hljs-comment">#权重，最大越高，lvs就越优先访问</span><br>        TCP_CHECK &#123;                           <span class="hljs-comment">#keepalived的健康检查方式HTTP_GET | SSL_GET | TCP_CHECK | SMTP_CHECK | MISC</span><br>            connect_timeout 10                <span class="hljs-comment">#10秒无响应超时</span><br>            retry 3                           <span class="hljs-comment">#重连次数3次</span><br>            delay_before_retry 3              <span class="hljs-comment">#重连间隔时间</span><br>            connect_port 80                   <span class="hljs-comment">#健康检查realserver的端口</span><br>        &#125;   <br>    &#125;   <br>    real_server 192.168.119.121 80 &#123;  <br>        weight 1                              <span class="hljs-comment">#权重，最大越高，lvs就越优先访问</span><br>        TCP_CHECK &#123;                           <span class="hljs-comment">#keepalived的健康检查方式HTTP_GET | SSL_GET | TCP_CHECK | SMTP_CHECK | MISC</span><br>            connect_timeout 10                <span class="hljs-comment">#10秒无响应超时</span><br>            retry 3                           <span class="hljs-comment">#重连次数3次</span><br>            delay_before_retry 3              <span class="hljs-comment">#重连间隔时间</span><br>            connect_port 80                   <span class="hljs-comment">#健康检查realserver的端口</span><br>        &#125;   <br>    &#125;   <br>&#125;   <br><br>vrrp_instance VI_2 &#123;                          <span class="hljs-comment">#vrrp 实例部分定义，VI_1自定义名称</span><br>    state   BACKUP                            <span class="hljs-comment">#指定 keepalived 的角色，必须大写 可选值：MASTER|BACKUP 分别表示（主|备）</span><br>    interface ens33                           <span class="hljs-comment">#网卡设置，绑定vip的子接口，lvs需要绑定在网卡上，realserver绑定在回环口。区别：lvs对访问为外，realserver为内不易暴露本机信息</span><br>    virtual_router_id 52                      <span class="hljs-comment">#虚拟路由标识，是一个数字，同一个vrrp 实例使用唯一的标识，MASTER和BACKUP 的 同一个 vrrp_instance 下 这个标识必须保持一致</span><br>    priority 90                               <span class="hljs-comment">#定义优先级，数字越大，优先级越高。</span><br>    advert_int 1                              <span class="hljs-comment">#设定 MASTER 与 BACKUP 负载均衡之间同步检查的时间间隔，单位为秒，两个节点设置必须一样</span><br>    authentication &#123;                          <span class="hljs-comment">#设置验证类型和密码，两个节点必须一致</span><br>        auth_type PASS  <br>        auth_pass 1111  <br>    &#125;   <br>    virtual_ipaddress &#123;                       <span class="hljs-comment">#设置虚拟IP地址，可以设置多个虚拟IP地址，每行一个</span><br>        192.168.119.131   <br>    &#125;   <br>&#125;   <br><br>virtual_server 192.168.119.131 80 &#123;           <span class="hljs-comment">#定义RealServer对应的VIP及服务端口，IP和端口之间用空格隔开</span><br>    delay_loop 6                              <span class="hljs-comment">#每隔6秒查询realserver状态</span><br>    lb_algo rr                                <span class="hljs-comment">#后端调试算法（load balancing algorithm）</span><br>    lb_kind DR                                <span class="hljs-comment">#LVS调度类型NAT/DR/TUN</span><br>    <span class="hljs-comment">#persistence_timeout 60                   #同一IP的连接60秒内被分配到同一台realserver</span><br>    protocol TCP                              <span class="hljs-comment">#用TCP协议检查realserver状态</span><br>    real_server 192.168.119.120 80 &#123;  <br>        weight 1                              <span class="hljs-comment">#权重，最大越高，lvs就越优先访问</span><br>        TCP_CHECK &#123;                           <span class="hljs-comment">#keepalived的健康检查方式HTTP_GET | SSL_GET | TCP_CHECK | SMTP_CHECK | MISC</span><br>            connect_timeout 10                <span class="hljs-comment">#10秒无响应超时</span><br>            retry 3                           <span class="hljs-comment">#重连次数3次</span><br>            delay_before_retry 3              <span class="hljs-comment">#重连间隔时间</span><br>            connect_port 80                   <span class="hljs-comment">#健康检查realserver的端口</span><br>        &#125;   <br>    &#125;   <br>    real_server 192.168.119.121 80 &#123;  <br>        weight 1                              <span class="hljs-comment">#权重，最大越高，lvs就越优先访问</span><br>        TCP_CHECK &#123;                           <span class="hljs-comment">#keepalived的健康检查方式HTTP_GET | SSL_GET | TCP_CHECK | SMTP_CHECK | MISC</span><br>            connect_timeout 10                <span class="hljs-comment">#10秒无响应超时</span><br>            retry 3                           <span class="hljs-comment">#重连次数3次</span><br>            delay_before_retry 3              <span class="hljs-comment">#重连间隔时间</span><br>            connect_port 80                   <span class="hljs-comment">#健康检查realserver的端口</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置段分为几大块：</p><p>global_def:</p><p>该配置段为全局配置段，一般用于配置邮件发送或keepalived协议相关配置。</p><p>这个配置段可不配置，一般不会影响正常使用</p><p>vrrp_script：</p><p>用于定义检测脚本，定义了以后需在vrrp_instance中指定该脚本。</p><p>vrrp_instance:</p><p>定义一个虚拟路由器实例，在其中需定义该服务器的实例状态（master or backup），路由器id，绑定的网卡等信息，多个服务器就是通过该配置段来判断是否为同一个虚拟路由器，是主还备。</p><p>virtual_server:</p><p>定义了lvs的相关配置，</p><p>real_server则是定义了lvs对应的后端服务器的配置信息</p><p>tcp_check是keepalived对后端的健康检查方式</p><p>vrrp_sync_group :<br>group模块将多实例绑定起来，当其中一个实例挂掉时，另一个实例也会随之挂掉。</p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h1><p>一共有四台服务器</p><p>其中两台服务器是lvs+keepalived</p><p>还有两台服务器是web服务器（nginx）</p><p>这里要实现的效果为前端两台lvs调度器实现高可用，通过lvs调度器分发到后端web服务器上。</p><p>实验拓扑图及服务器ip如下：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231045829.jpeg" alt="image.png"></p><p>因为有四台服务器，这里就称为server1-server4</p><p>server1和server2是lvs+keepalived的服务器，所以有两张网卡，一张是外网网卡，一张是内网网卡，用于与用户通信和转发到后端web服务器</p><p>server3和server4是web服务器，只有一张网卡，为内网网卡</p><p>这里因为机器较多，就采用ansible批量部署了，ansible可以使用yum直接安装（epel源）</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs pf">yum -y install epel-release<br>yum -y install ansible<br>vim /etc/ansible/hosts<br><span class="hljs-comment">####添加下面的信息</span><br>[lvs]<br><span class="hljs-number">10.10</span>.<span class="hljs-number">10.105</span><br><span class="hljs-number">10.10</span>.<span class="hljs-number">10.187</span><br>[lvs:vars]<br>ansible_ssh_pass=admin<br>[ngx]<br><span class="hljs-number">192.168</span>.<span class="hljs-number">34.137</span><br><span class="hljs-number">192.168</span>.<span class="hljs-number">34.136</span><br>[ngx:vars]<br>ansible_ssh_pass=admin<br><span class="hljs-comment">####</span><br><span class="hljs-comment">#其中10.10.10.105和10.10.10.187是lvs+keepalived服务武器</span><br><span class="hljs-comment">#192.168.34.136和192.168.34.137为web服务器</span><br>sed -i &#x27;s/^<span class="hljs-comment">#host_key_checking = False/host_key_checking = False/g&#x27; /etc/ansible/ansible.cfg</span><br><br>ansible准备工作就做好，下面开始用ansible安装服务器需要用到的软件<span class="hljs-comment">#需准备好yum源</span><br>ansible lvs -m yum -a <span class="hljs-string">&quot;state=installed name=ipvsadm&quot;</span><br>ansible lvs -m yum -a <span class="hljs-string">&quot;state=installed name=keepalived&quot;</span><br>ansible ngx -m yum -a <span class="hljs-string">&quot;state=installed name=nginx&quot;</span><br>ansible <span class="hljs-number">192.168</span>.<span class="hljs-number">34.136</span> -m shell -a <span class="hljs-string">&quot;echo 192.168.34.136 &gt; /usr/share/nginx/html/index.html&quot;</span><br>ansible <span class="hljs-number">192.168</span>.<span class="hljs-number">34.137</span> -m shell -a <span class="hljs-string">&quot;echo 192.168.34.137 &gt; /usr/share/nginx/html/index.html&quot;</span><br>ansible ngx -m systemd -a <span class="hljs-string">&quot;name=nginx enabled=yes state=started&quot;</span><br><br>此时开始配置keepalived<br>编辑配置文件vim /etc/keepalived/ansible.cfg<br><span class="hljs-comment">####这个配置为10.10.10.105的配置文件，改服务器做为keepalived主服务器，state为master且为抢占模式</span><br>global_defs &#123;<br>   router_id <span class="hljs-number">99</span><br>&#125;<br>vrrp_sync_group <span class="hljs-number">145</span> &#123;<br><span class="hljs-keyword">group</span> &#123;<br>VI_1<br>VI_2<br>&#125;<br>&#125;<br>vrrp_instance VI_1 &#123;<br>    <span class="hljs-keyword">state</span> MASTER<br>    priority <span class="hljs-number">150</span><br>    advert_int <span class="hljs-number">1</span><br>    authentication &#123;<br>    &#125;<br>    virtual_ipaddress &#123;<br> <span class="hljs-number">10.10</span>.<span class="hljs-number">10.106</span><br>vrrp_instance VI_2 &#123; <br>    <span class="hljs-keyword">state</span> MASTER<br>    interface ens37 <br>    advert_int <span class="hljs-number">1</span><br>    authentication &#123;<br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br><br>global_defs &#123;<br>   router_id <span class="hljs-number">99</span><br>&#125;<br>vrrp_sync_group <span class="hljs-number">145</span> &#123;<br><span class="hljs-keyword">group</span> &#123;<br>VI_1<br>VI_2<br>&#125;<br>&#125;<br>vrrp_instance VI_1 &#123;<br>    <span class="hljs-keyword">state</span> MASTER<br>    priority <span class="hljs-number">150</span><br>    advert_int <span class="hljs-number">1</span><br>    authentication &#123;<br>    &#125;<br>    virtual_ipaddress &#123;<br> <span class="hljs-number">10.10</span>.<span class="hljs-number">10.106</span><br>vrrp_instance VI_2 &#123;<br>    <span class="hljs-keyword">state</span> MASTER<br>    priority <span class="hljs-number">150</span><br>    interface ens37<br>    advert_int <span class="hljs-number">1</span><br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass <span class="hljs-number">1111</span><br>    &#125;<br>    virtual_ipaddress &#123;<br> <span class="hljs-number">192.168</span>.<span class="hljs-number">34.145</span><br>&#125;<br>&#125;<br> virtual_server <span class="hljs-number">10.10</span>.<span class="hljs-number">10.106</span> <span class="hljs-number">80</span>  &#123;          <span class="hljs-comment">#定义RealServer对应的VIP及服务端口，IP和端口之间用空格隔开</span><br>    delay_loop <span class="hljs-number">6</span>                              <span class="hljs-comment">#每隔6秒查询realserver状态</span><br>    lb_algo rr                                <span class="hljs-comment">#后端调试算法（load balancing algorithm）</span><br>    lb_kind NAT                                <span class="hljs-comment">#LVS调度类型NAT/DR/TUN</span><br>    <span class="hljs-comment">#persistence_timeout 60                   同一IP的连接60秒内被分配到同一台realserver</span><br>    protocol TCP                              <span class="hljs-comment">#用TCP协议检查realserver状态</span><br>    real_server <span class="hljs-number">192.168</span>.<span class="hljs-number">34.137</span> <span class="hljs-number">80</span> &#123;<br>        weight <span class="hljs-number">1</span>                              <span class="hljs-comment">#权重，最大越高，lvs就越优先访问</span><br>        TCP_CHECK &#123;                           <span class="hljs-comment">#keepalived的健康检查方式HTTP_GET | SSL_GET | TCP_CHECK | SMTP_CHECK | MISC</span><br>            connect_timeout <span class="hljs-number">10</span>                <span class="hljs-comment">#10秒无响应超时</span><br>            retry <span class="hljs-number">3</span>                           <span class="hljs-comment">#重连次数3次</span><br>            delay_before_retry <span class="hljs-number">3</span>              <span class="hljs-comment">#重连间隔时间</span><br>            connect_port <span class="hljs-number">80</span>                   <span class="hljs-comment">#健康检查realserver的端口</span><br>        &#125;<br>    &#125;<br>    real_server <span class="hljs-number">192.168</span>.<span class="hljs-number">34.136</span> <span class="hljs-number">80</span> &#123;<br>        weight <span class="hljs-number">1</span>                              <span class="hljs-comment">#权重，最大越高，lvs就越优先访问</span><br>        TCP_CHECK &#123;                           <span class="hljs-comment">#keepalived的健康检查方式HTTP_GET | SSL_GET | TCP_CHECK | SMTP_CHECK | MISC</span><br>            connect_timeout <span class="hljs-number">10</span>                <span class="hljs-comment">#10秒无响应超时</span><br>            retry <span class="hljs-number">3</span>                           <span class="hljs-comment">#重连次数3次</span><br>            delay_before_retry <span class="hljs-number">3</span>              <span class="hljs-comment">#重连间隔时间</span><br>            connect_port <span class="hljs-number">80</span>                   <span class="hljs-comment">#健康检查realserver的端口</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">####</span><br><span class="hljs-number">10.10</span>.<span class="hljs-number">10.187</span>的配置于<span class="hljs-number">105</span>大致相似，只需要改一下几个点<br>vrrp_instance VI_1和VI_2<br><span class="hljs-keyword">state</span>=MASTER改为<span class="hljs-keyword">state</span>=BACKUP<br>priority=<span class="hljs-number">150</span>改为priority=<span class="hljs-number">100</span><br>改完后keepalived就配置完毕了，lvs安装即可，无需手动配置lvs的配置都会通过virtual_server和real_server自动配置上。<br>此时重启keepalived即可(如没启动便直接启动)<br>systemctl restart keepalived<br>最后因为nat的lvs需要后端服务器将其默认路由指定到前端lvs的DIP上，所以还需要写一条路由<br>ansible ngx -m shell -a <span class="hljs-string">&quot;route add default gw 192.168.34.145&quot;</span><br>此时便配置完成了。<br></code></pre></td></tr></table></figure><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>然后是测试环节，首先是访问测试</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231046645.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231045772.jpeg" alt="image.png"></p><p>访问没有问题说明lvs负载均衡和后端nginx是正常运行且能正常访问的</p><p>这时再测试keepalived</p><p>在10.10.10.105（MASTER）服务器上关闭一块网卡或关闭keepalived</p><p>nmcli c down ens33</p><p>此时，其虚拟ip就飘逸到BACKUP服务器上去了</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231045923.jpeg" alt="image.png"></p><p>此时再访问测试</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231046664.jpeg" alt="image.png"></p><p>还是可以访问说明keepalived的ip飘逸成功了。关闭一个lvs+keepalived服务器时，另一个会直接替代其对外提供服务器，也就实现了高可用服务器。</p><p>需要注意的点：</p><p>1.在keepalived中配置lvs时（virtual_server 和 real_server），指定的lvs模式（NAT,TUNL,DR）的准备工作需要提前做好，例如nat需要调度器有内外两个网卡且后端服务器默认路由地址要指定到DIP。因其keepalived仅仅只会将ipvsadm配置上，其lvs相关环境以及必要配置还是需要手动去配置。</p><p>2.在抢占模式中可以通过检测脚本（需手动写）来控制其实例的优先级数值，在非抢占模式中需要加上nopreempt的配置，且非抢占模式中不需要priority优先级配置。</p><p>抢占模式与非抢占模式的区别为：</p><p>在抢占模式中当主节点挂掉以后备用节点会立刻顶替主节点的位置，而当主节点又重新正常上线后主节点会将备用节点的虚拟ip抢占过来，而非抢占模式时当备用节点顶替主节点后，主节点再上线时其主节点这时并不会去抢占其虚拟ip。</p><p>非抢占模式要求：</p><ol><li>两个节点的state都必须配置为BACKUP</li><li>两个节点都必须加上配置 nopreempt</li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lvs</title>
    <link href="/2021/12/23/lvs_hexo/"/>
    <url>/2021/12/23/lvs_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="lvs"><a href="#lvs" class="headerlink" title="lvs"></a>lvs</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>LVS是一个开源软件，由章文嵩博士于1998年5月创立，可以实现Linux平台下的简单负载均衡。LVS是Linux Virtual Server的简写，是一个虚拟的服务器集群系统。在后续的维护过程中，LVS添加了各种新的支持，包括FreeBSD的支持、IPV6的支持、TCPHA的支持等等。</p><p>LVS为传输层协议，基于linux内核的netfilter模块，现在一般都集成与linux内核模块，无需单独安装，使用命令：lsmod | grep ip_vs，可以查看lvs是否已在内核模块中。</p><p>lvs分为ipvs和ipvsadmin，前者为已集成与内核模块的ipvs核心功能模块（内核如没有可以编译进内核），后者为lvs的命令行工具，其命令格式也类似与iptables。</p><p>lvs工作模式：ipvs是工作在内核中netfilter的INPUT的钩子函数上，对进入的报文在没有进入用户空间前，对这些报文进行操作。优点是性能高，支持并发大，无socket限制和最大文件句柄数限制。缺点是调度方式简单，仅能通过ip+port进行调度。</p><h3 id="2-调度模式"><a href="#2-调度模式" class="headerlink" title="2.调度模式"></a>2.调度模式</h3><p>lvs有三种调度模式，NAT,DR,TUN</p><p>备注：CIP(客户端IP)，VIP（lvs调度器的外网监听IP），DIP（lvs调度器和后端realserver联系的IP），RIP（后端realserver的IP）</p><h4 id="2-1-NAT模式"><a href="#2-1-NAT模式" class="headerlink" title="2.1 NAT模式"></a>2.1 NAT模式</h4><p>nat模式是通过地址转换来实现的调度方式，当客户端访问服务器时，访问的地址应是lvs监听的外网地址，也就是VIP，此时请求报文的地址应为CIP-&gt;VIP（请求地址-&gt;目标地址），到达lvs调度器以后，lvs通过修改该报文的目标地址，来进行转发到后端server，此时该报文为CIP-&gt;RIP（通过DIP转发）。后端realserver在处理完请求之后再将处理完的报文发送到lvs，此时报文为RIP-&gt;CIP（因为此时realserver指定的出口网关为DIP，所以即使该报文目标地址为CIP，也会发送到DIP所在的lvs调度服务器上面）。lvs调度器收到报文后将该报文改为VIP-&gt;CIP，再发送给客户端，完成处理本次请求。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231041277.jpeg" alt="image.png"></p><p>NAT模式优缺点：</p><ol><li>NAT技术将请求的报文和响应的报文都需要通过LB进行地址改写，因此网站访问量比较大的时候LB负载均衡调度器有比较大的瓶颈，一般要求最多之能10-20台节点</li><li>只需要在LB上配置一个公网IP地址就可以了。</li><li>每台内部的节点服务器的网关地址必须是调度器LB的内网地址。</li><li>NAT模式支持对IP地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。</li></ol><h4 id="2-2-TUN模式"><a href="#2-2-TUN模式" class="headerlink" title="2.2 TUN模式"></a>2.2 TUN模式</h4><p>virtual server via ip tunneling模式:采用NAT模式时，由于请求和响应的报文必须通过调度器地址重写，当客户请求越来越多时，调度器处理能力将成为瓶颈。为了解决这个问题，调度器把请求的报文通过IP隧道转发到真实的服务器。真实的服务器将响应处理后的数据直接返回给客户端。这样调度器就只处理请求入站报文，由于一般网络服务应答数据比请求报文大很多，采用VS/TUN模式后，集群系统的最大吞吐量可以提高10倍。</p><p>VS/TUN的工作流程图如下所示，它和NAT模式不同的是，它在LB和RS之间的传输不用改写IP地址。而是把客户请求包封装在一个IP tunnel里面，然后发送给RS节点服务器，节点服务器接收到之后解开IP tunnel后，进行响应处理。并且直接把包通过自己的外网地址发送给客户不用经过LB服务器。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231042480.jpeg" alt="image.png"></p><p>原理图过程简述：</p><ol><li>客户请求数据包，目标地址VIP发送到LB上。</li><li>LB接收到客户请求包，进行IP Tunnel封装。即在原有的包头加上IP Tunnel的包头。然后发送出去。</li><li>RS节点服务器根据IP Tunnel包头信息（此时就又一种逻辑上的隐形隧道，只有LB和RS之间懂）收到请求包，然后解开IP Tunnel包头信息，得到客户的请求包并进行响应处理。</li><li>响应处理完毕之后，RS服务器使用自己的出公网的线路，将这个响应数据包发送给客户端。源IP地址还是VIP地址。（RS节点服务器需要在本地回环接口配置VIP，后续会讲到）</li></ol><h4 id="2-3-DR模式"><a href="#2-3-DR模式" class="headerlink" title="2.3 DR模式"></a>2.3 DR模式</h4><p>DR模式是通过改写请求报文的目标MAC地址，将请求发给真实服务器的，而真实服务器响应后的处理结果直接返回给客户端用户。同TUN模式一样，DR模式可以极大的提高集群系统的伸缩性。而且DR模式没有IP隧道的开销，对集群中的真实服务器也没有必要必须支持IP隧道协议的要求。但是要求调度器LB与真实服务器RS都有一块网卡连接到同一物理网段上，必须在同一个局域网环境。</p><p>DR模式是<a href="http://www.it165.net/news/nhlw/">互联网</a>使用比较多的一种模式。</p><p>DR模式原理图：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231042526.jpeg" alt="image.png"></p><p>VS/DR模式的工作流程图如上图所示，它的连接调度和管理与NAT和TUN中的一样，它的报文转发方法和前两种不同。DR模式将报文直接路由给目标真实服务器。在DR模式中，调度器根据各个真实服务器的负载情况，连接数多少等，动态地选择一台服务器，不修改目标IP地址和目标端口，也不封装IP报文，而是将请求报文的数据帧的目标MAC地址改为真实服务器的MAC地址。然后再将修改的数据帧在服务器组的局域网上发送。因为数据帧的MAC地址是真实服务器的MAC地址，并且又在同一个局域网。那么根据局域网的通讯原理，真实复位是一定能够收到由LB发出的数据包。真实服务器接收到请求数据包的时候，解开IP包头查看到的目标IP是VIP。<em>（此时只有自己的IP符合目标IP才会接收进来，所以我们需要在本地的回环借口上面配置VIP。另：由于网络接口都会进行ARP广播响应，但集群的其他机器都有这个VIP的lo接口，都响应就会冲突。所以我们需要把真实服务器的lo接口的ARP响应关闭掉。）</em>然后真实服务器做成请求响应，之后根据自己的路由信息将这个响应数据包发送回给客户，并且源IP地址还是VIP。</p><p>DR模式小结：</p><ol><li>通过在调度器LB上修改数据包的目的MAC地址实现转发。注意源地址仍然是CIP，目的地址仍然是VIP地址。</li><li>请求的报文经过调度器，而RS响应处理后的报文无需经过调度器LB，因此并发访问量大时使用效率很高（和NAT模式比）</li><li>因为DR模式是通过MAC地址改写机制实现转发，因此所有RS节点和调度器LB只能在一个局域网里面</li><li>RS主机需要绑定VIP地址在LO接口上，并且需要配置ARP抑制。</li><li>RS节点的默认网关不需要配置成LB，而是直接配置为上级路由的网关，能让RS直接出网就可以。</li><li>由于DR模式的调度器仅做MAC地址的改写，所以调度器LB就不能改写目标端口，那么RS服务器就得使用和VIP相同的端口提供服务。</li></ol><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231041271.jpeg" alt="image.png"></p><p>lvs调度算法</p><p>Lvs的调度算法决定了如何在集群节点之间分布工作负荷。当director调度器收到来自客户端访问VIP的上的集群服务的入站请求时，director调度器必须决定哪个集群节点应该处理请求。Director调度器用的调度方法基本分为两类：</p><p>固定调度算法：rr，wrr，dh，sh</p><p>动态调度算法：wlc，lc，lblc，lblcr<img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231042661.jpeg" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux启动流程</title>
    <link href="/2021/12/23/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_hexo/"/>
    <url>/2021/12/23/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_hexo/</url>
    
    <content type="html"><![CDATA[<p>linux启动流程</p><p>linux的启动流程为：</p><p>POST-》-boot sequence》BOOTLOADER（BIOS）-》KERNEL-》INIT(SYSTEMD)</p><p>1.加电质检POST</p><p>上电自检过程中其实 Linux 没有什么也没做，上电自检主要由硬件的部分来完成，这对于所有操作系统都一样。当电脑接通电源，电脑开始执行 BIOS（基本输入输出系统Basic I/O System）的 POST（上电自检Power On Self Test）过程。</p><p>在 1981 年，IBM 设计的第一台个人电脑中，BIOS 被设计为用来初始化硬件组件。POST 作为 BIOS 的组成部分，用于检验电脑硬件基本功能是否正常。如果 POST 失败，那么这个电脑就不能使用，引导过程也将就此中断。</p><p>上电自检POST(Power-on self test)：首先加载BIOS，然后BIOS对其系统硬件进行检查，主要负责检测系统外围关键设备（如：CPU、内存、显卡、I/O、键盘鼠标等）是否正常。例如，最常见的是内存松动的情况，BIOS自检阶段会报错，系统就无法启动起来。</p><p>2..boot sequence</p><p>当硬件检查完毕BIOS加载完硬件信息后，会根据BIOS设置中的硬盘（光盘，网络）启动顺序，根据定义好的顺序依次查找硬盘中第一个扇区（MBR引导扇区），实际上这里BIOS并不关心启动设备第一个扇区中是什么内容，它只是负责读取该扇区内容、并执行。</p><p>3.boot loader</p><p>boot loader为引导加载器，引导加载器会根据自身配置文件加载内核，但这里有个问题是MBR（主引导扇区），这里需要先说明一下MBR。</p><p>MBR：MBR为主引导扇区（主引导记录），位于硬盘里面0磁道0柱面1扇区，大小为512kb，启动真正存放bootloader的空间为前446B（字节），后64B为存放分区信息（三个主分区一个扩展分区，每个各占16B），剩下2B为“55，AA”，是分区结束的标签。</p><p>所以引导加载器实际的存储空间为446字节，对于现在的引导加载器存储空间肯定是不够的，所以现在的引导加载器一般存放于文件系统上，然后通过mbr去找到并加载它。这里以grub为例，下面是步骤：</p><ul><li>第一步：这个其实就是MBR，它的主要工作就是查找并加载第二段Bootloader程序(stage2)，但系统在没启动时，MBR根本找不到文件系统，也就找不到stage2所存放的位置，因此，就有了stage2</li><li>第二步：第一步的mbr里面放置了bootloader的最小程序，用于找到并加载第二步，而第二部则是为了加载驱动，识别文件系统。</li><li>第三步：GRUB程序会根据/boot/grub/grub.conf文件查找Kernel的信息，然后开始加载Kernel程序，当Kernel程序被检测并在加载到内存中，GRUB就将控制权交接给了Kernel程序</li></ul><p>下面是grub的配置文件：</p><blockquote><p>default=0 #设定默认启动的title的编号，从0开始<br>　　　　timeout=5 #等待用户选择的超时时间<br>　　　　splashimage=(hd0,0)/boot/grub/splash.xpm.gz #GRUB的背景图片<br>　　　　hiddenmenu #隐藏菜单<br>　　　　title CentOS (2.6.18-194.el5PAE) #内核标题<br>　　　　root (hd0,0) #内核文件所在的设备<br>　　　　kernel /vmlinuz-2.6.18-194.el5PAE ro root=LABEL=/ #内核文件路径以及传递给内核的参数　　　initrd /initrd-2.6.18-194.el5PAE.img #ramdisk文件路径</p></blockquote><p>4.kernel</p><p>我们知道kernel是完成探索硬件及加载硬件驱动程序，并以读写的方式挂载根文件系统。那么这里就出现一个比较诡异的问题，是什么问题呢？<br><strong>我们又知道，要想访问真正的根文件系统（rootfs）的话，就必须加载根文件系统中的设备，这时根文件系统又没有挂载，要挂载根文件系统又得加载根文件系统中的驱动程序，哪怎么办呢？这是就用到了initrd文件了。<br>在来说下kernel初始化所要工作的内容做下简单总结：<br>探测硬件-&gt;加载驱动（initrd)-&gt;挂载根文件系统-&gt;rootfs(/sbin/init)</strong></p><p><strong>initrd功能介绍<br>其实说白了initrd就是一个虚拟的文件系统，里面有/、lib、bin、sbin、usr、proc、sys、var、dev、boot等一些目录，其实你会发现里面的目录有点像真的/对吧，所以我们称之为虚拟的根文件系统，作用就是将kernel和真的根文件系统建立关联关系，让kernel去initrd中加载根文件系统所需要的驱动程序，并以读写的方式挂载根文件系统，并让执行用户当中第一个进程init。</strong></p><p><strong>/sbin/init(/etc/inittab)</strong><br>/sbin/init启动会用到/etc/inittab所定义的条目，如：默认登陆级别id:3:initdefault:(这里就是默认启动3级别）<br><strong>下面就来说下/etc/inittab所工作那些内容：</strong><br>/etc/inittab<br>默认运行级别<br>0：halt<br>1: single user mode(单用户维护模式)<br>2：multi user mode, without NFS(不支持NFS功能）<br>3: multi user mode, text mode（字符界面）<br>4：reserved （系统保留）<br>5: multi user mode, graphic mode （图形化界面）<br>6: reboot （重启）<br>系统初始化(/etc/rc.d/rc.sysinit)<br>检测，并以读写方式挂载根文件系统<br>设定主机名<br>检测并挂载/etc/fstab中其它文件系统<br>启动swap分区<br>初始化外围硬件设备驱动<br>根据/etc/sysctl.conf设定内核参数<br>激活udev和selinux<br>激活LVM和RAID设备<br>清理过期锁文件和PID文件<br>装载键映射–&gt;键盘上每个键的功能<br>运行指定级别的服务脚本<br>/etc/rc.d/init.d/<br>/etc/rc.d/rc#.d<br>rc0-rc6<br>K* ##只要是以K开头的文件均执行stop工作<br>S* ##只要是以S开头的文件均执行start工作<br>0-99 (执行次序，数字越小越先被执行)<br>init执行/etc/rc.d/rc.local<br>init执行中断机模拟程序mingetty来启动login进程，最后等待用户登录**</p><p><strong>下面在来说下/etc/inittab的语法及格式：</strong><br>/etc/inittab格式及语法(:)</p><p>设置选项：<br>代表init主要工作选项<br>运行级别<br>0-6<br>init操作行为：<br>initdefault：代表默认运行级别<br>sysinit：代表系统初始化操作选项<br>ctrlaltdel：代表重启的相关设置<br>wait：代表上一个命令执行结束后方可执行下面的操作<br>respawn：代表后面字段可以无限制再生(reboot)<br>命令选项<br>一些命令，不过通常都是脚本<br>**</p><p><strong>init处理流程：<br>根据/etc/inittab设置进行处理：以默认级别3说明：id:3:initdefault:<br>default runlevel-&gt;/etc/rc.d/rc.sysinit-&gt;/etc/rc.d/rc5.d-&gt;ctrlatdel-&gt;set “pf” and “pr”-&gt;mingetty-&gt;login</strong></p><p>init处理系统初始化流程/etc/rc.d/rc.sysinit(设置系统环境)<br>取得网络环境与主机类型-&gt;/etc/sysconfig/network<br>测试与挂载内存设备/proc及/sys<br>SElinux<br>启动系统的随机数生成器<br>设置终端机字体<br>设置系统启动过程中的欢迎界面<br>设置系统时间与时区设置/etc/sysconfig/clock<br>接口设备检测<br>用户自定义模块加载-&gt;/etc/sysconfig/modules/.modules<br>根据/etc/sysctl.conf设置内核参数<br>初始化软件磁盘阵列-&gt;/etc/mdadm.conf<br>初始化LVM文件系统功能<br>fsck检测磁盘文件系统<br>磁盘配额<br>检测，并以读写方式重新挂载根文件系统<br>清除清除过程当中的临时文件<br>将启动的相关信息-&gt;/var/log/dmesg</p><p>启动服务与相关启动配置文件(/etc/rc.d/rc # &amp;/etc/sysconfig )<br>以默认级别3说明：id:3:initdefault:<br>l3:3:wait:/etc/rc.d/rc 3<br>找到/etc/rc.d/rc3.d<br>以K<em>开头的文件，并运行/etc/rc.d/rc3.d/K</em> stop<br>以S<em>开头的文件，并运行/etc/rc.d/rc3.d/S</em> start<br>/etc/rc.d/rc#.d/里面的文件链接的都是/etc/rc.d/init.d的文件**</p><p>**用户自定义开机启动程序(/etc/rc.d/rc.local)<br>**可以根据自己的需求将一些执行命令或是脚本写到/etc/rc.d/rc.local里，当开机时，就可以加载啦</p><p>根据mingetty程序调用login让用户登录-&gt;用户登录（完成系统启动）</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx</title>
    <link href="/2021/12/23/nginx_hexo/"/>
    <url>/2021/12/23/nginx_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="一-nginx概述"><a href="#一-nginx概述" class="headerlink" title="一.nginx概述"></a>一.nginx概述</h1><p>nginx是一款开源的http，web应用服务器，其功能模块化，高性能高可靠。</p><p>特性：<br>功能模块少：源代码仅保留http与核心模块代码，其余不够核心代码会作为插件来安装<br>代码模块化：易读，便于二次开发<br>优势：<br>适合当前主流架构趋势，微服务，云架构，中间层<br>统一技术栈，降低维护成本，降低技术成本更新成本</p><p>Nginx特点是占有<a href="http://baike.baidu.com/view/1082.htm">内存</a>少，<a href="http://baike.baidu.com/view/684757.htm">并发</a>能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p><p><strong>Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。</strong></p><h2 id="Nginx相对于Apache优点："><a href="#Nginx相对于Apache优点：" class="headerlink" title="Nginx相对于Apache优点："></a>Nginx相对于Apache优点：</h2><ol><li><strong>高并发响应性能非常好，官方Nginx处理静态文件并发5w/s</strong></li><li><strong>反向代理性能非常强。（可用于负载均衡）</strong></li><li><strong>内存和cpu占用率低。（为Apache的1/5-1/10）</strong></li><li><strong>对后端服务有健康检查功能。</strong></li><li><strong>支持PHP cgi方式和fastcgi方式。</strong></li><li>配置代码简洁且容易上手。</li><li>nginx采用epoll模型（异步非阻塞），而apache采用select模型。</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">select</span> 和<span class="hljs-literal">epoll</span>模型的区别<br><span class="hljs-literal">select</span>:当用户发起一次请求，<span class="hljs-literal">select</span>模型就会进行一次遍历扫描，从而导致性能低下<br><span class="hljs-literal">epoll</span>：当用户发起请求，<span class="hljs-literal">epoll</span>模型会直接进行处理，效率高效，并无连接限制。<br><br><span class="hljs-literal">select</span>和<span class="hljs-literal">epoll</span>对比<br><br><span class="hljs-literal">select</span><br>随着连接数增加，急剧下降。处理成千上万并发连接数时，性能很差。<br>连接数有限制，处理的最大连接数不超过<span class="hljs-number">1024</span>。如果要处理超过<span class="hljs-number">1024</span>个连接数，则需要修改FD_SETSIZE宏，并重新编译 。<br>线性轮询<br>开发复杂性低<br><span class="hljs-literal">epoll</span><br>随着连接数增加，性能基本上没有下降。处理成千上万并发连接时，性能很好。<br>连接数无限制。<br>回调callback<br>开发复杂性中<br></code></pre></td></tr></table></figure><h2 id="nginx应用场景："><a href="#nginx应用场景：" class="headerlink" title="nginx应用场景："></a>nginx应用场景：</h2><p>静态服务：<br>浏览器缓存，防资源盗用，资源分类，资源压缩，资源缓存，跨域访问<br>代理服务：<br>协议类型，正向代理，反向代理，负载均衡，代理缓存，动静分离<br>安全服务：<br>访问控制，访问限制，流量限制，拦截共计，拦截异常请求，拦截sql注入<br>流行框架<br>nginx+php，nginx+java ，nginx+python</p><h1 id="二-nginx安装"><a href="#二-nginx安装" class="headerlink" title="二.nginx安装"></a>二.nginx安装</h1><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a> #nginx官网地址</p><p>nginx一般有两种安装方式：</p><p>源码安装和rpm安装：</p><p>rpm安装：</p><p>epel源：版本低，功能少<br>官方源：官方编译好的，封装成rpm包，提供yum源 版本新</p><h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h2><h3 id="官方源："><a href="#官方源：" class="headerlink" title="官方源："></a>官方源：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> yum-utils<br></code></pre></td></tr></table></figure><p>To set up the yum repository, create the file named <strong>/etc/yum.repos.d/nginx.repo</strong> with the following contents:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[nginx-stable]</span><br><span class="hljs-attr">name</span>=nginx stable repo<br><span class="hljs-attr">baseurl</span>=http://nginx.org/packages/centos/<span class="hljs-variable">$releasever</span>/<span class="hljs-variable">$basearch</span>/<br><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key<br><span class="hljs-attr">module_hotfixes</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[nginx-mainline]</span><br><span class="hljs-attr">name</span>=nginx mainline repo<br><span class="hljs-attr">baseurl</span>=http://nginx.org/packages/mainline/centos/<span class="hljs-variable">$releasever</span>/<span class="hljs-variable">$basearch</span>/<br><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key<br><span class="hljs-attr">module_hotfixes</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>By default, the repository for stable nginx packages is used. If you would like to use mainline nginx packages, run the following command:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">sudo yum-<span class="hljs-built_in">config</span>-manager <span class="hljs-comment">--enable nginx-mainline</span><br></code></pre></td></tr></table></figure><p>To install nginx, run the following command:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure><p>When prompted to accept the GPG key, verify that the fingerprint matches 573B FD6B 3D8F BC64 1079 A6AB ABF5 BD82 7BD9 BF62, and if so, accept it.</p><p>上面的为最新包的安装，下面的为稳定版的安装，文档内容截自官方文档，如为其他系统则参考官方文档 ：<strong><a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS">http://nginx.org/en/linux_packages.html#RHEL-CentOS</a></strong></p><h3 id="epel源："><a href="#epel源：" class="headerlink" title="epel源："></a>epel源：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> epel-release.noarch  ```<span class="hljs-comment">#首先安装epel源，如已有则跳过，如还没有yum源则先把yum源配置好</span><br>yum makecache <span class="hljs-comment">#加载epel源</span><br>yum -y <span class="hljs-keyword">install</span> nginx <span class="hljs-comment">#安装nginx</span><br>安装完成以后<br>nginx -V 查看nginx安装配置以及版本<br></code></pre></td></tr></table></figure><h2 id="源码安装："><a href="#源码安装：" class="headerlink" title="源码安装："></a>源码安装：</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">wget http:<span class="hljs-string">//nginx.org/download/nginx-1.19.6.tar.gz</span> <span class="hljs-comment">#下载nginx</span><br><br>useradd -s <span class="hljs-string">/sbin/nologin</span> -M nginx <span class="hljs-comment">#添加nginx用户</span><br><br>tar -xvf nginx-1.19.6.tar.gz &amp;&amp; <span class="hljs-keyword">cd</span> nginx-1.19.6/<br><br>yum install -y gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel <span class="hljs-comment">#解决依赖</span><br><br><span class="hljs-string">./configure</span> <span class="hljs-params">--prefix=/usr/local/nginx</span> <span class="hljs-params">--user=nginx</span> <span class="hljs-params">--group=nginx</span> <span class="hljs-params">--with-file-aio</span> <span class="hljs-params">--with-ipv6</span> <span class="hljs-params">--with-http_ssl_module</span> <span class="hljs-params">--with-http_v2_module</span> <span class="hljs-params">--with-http_realip_module</span> <span class="hljs-params">--with-http_addition_module</span> <span class="hljs-params">--with-http_xslt_module=dynamic</span> <span class="hljs-params">--with-http_image_filter_module=dynamic</span> <span class="hljs-params">--with-http_sub_module</span> <span class="hljs-params">--with-http_dav_module</span> <span class="hljs-params">--with-http_flv_module</span> <span class="hljs-params">--with-http_mp4_module</span> <span class="hljs-params">--with-http_gunzip_module</span> <span class="hljs-params">--with-http_gzip_static_module</span> <span class="hljs-params">--with-http_random_index_module</span> <span class="hljs-params">--with-http_secure_link_module</span> <span class="hljs-params">--with-http_degradation_module</span> <span class="hljs-params">--with-http_slice_module</span> <span class="hljs-params">--with-http_stub_status_module</span> <span class="hljs-params">--with-http_perl_module=dynamic</span> <span class="hljs-params">--with-http_auth_request_module</span> <span class="hljs-params">--with-mail=dynamic</span> <span class="hljs-params">--with-mail_ssl_module</span> <span class="hljs-params">--with-pcre</span> <span class="hljs-params">--with-pcre-jit</span> <span class="hljs-params">--with-stream=dynamic</span> <span class="hljs-params">--with-stream_ssl_module</span> <span class="hljs-params">--with-debug</span><br><br><br>make &amp;&amp; make install  <span class="hljs-comment">#编译</span><br><br>ll <span class="hljs-string">/usr/local/nginx/</span>  <span class="hljs-comment">#查看nginx</span><br></code></pre></td></tr></table></figure><p>源码安装的好处在于其所有nginx相关文件都可以放在一起，方便数据迁移。相比于yum麻烦的是：</p><p>源码安装完成以后linux环境变量没有nginx路径，需要配置（才能直接在命令行找到命令）</p><p>systemd不会自动生成nginx启动文件（无法通过systemctl直接启动关闭nginx）</p><p>所以这两个都需要手动进行生成</p><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd:"></a>systemd:</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat &gt; <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>nginx.service &lt;&lt; EOF<br>[Unit]<br>Description=The nginx HTTP and reverse proxy server<br>After=network.target remote-fs.target nss-lookup.target[Service]<br>Type=forking<br>PIDFile=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>logs/nginx.pid<br><span class="hljs-comment"># Nginx will fail to start if /run/nginx.pid already exists but has the wrong</span><br><span class="hljs-comment"># SELinux context. This might happen when running `nginx -t` from the cmdline.</span><br><span class="hljs-comment"># https://bugzilla.redhat.com/show_bug.cgi?id=1268621</span><br>ExecStartPre=<span class="hljs-regexp">/usr/</span>bin/rm -f <span class="hljs-variable">$PIDFile</span><br>ExecStartPre=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -t<br>ExecStart=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx<br>ExecReload=<span class="hljs-regexp">/bin/</span>kill -s HUP PIDFileExecStartPre=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin<span class="hljs-regexp">/nginx−tExecStart=/u</span>sr<span class="hljs-regexp">/local/</span>nginx<span class="hljs-regexp">/sbin/</span>nginxExecReload=<span class="hljs-regexp">/bin/</span>kill−sHUP<span class="hljs-variable">$MAINPID</span><br>KillSignal=SIGQUIT<br>TimeoutStopSec=<span class="hljs-number">5</span><br>KillMode=mixed<br>PrivateTmp=true[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p>将systemd文件写入以后可以使用systemctl start nginx测试一下</p><h3 id="加入环境变量"><a href="#加入环境变量" class="headerlink" title="加入环境变量"></a>加入环境变量</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat &gt; <span class="hljs-regexp">/etc/</span>profile.d/nginx.sh &lt;&lt; EOF<br>export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin:<span class="hljs-variable">$PATH</span><br>EOF<br>source <span class="hljs-regexp">/etc/</span>profile.d/nginx.sh <span class="hljs-comment">#生效到当前环境变量</span><br>nginx -V <span class="hljs-comment">#使用命令测试一下</span><br></code></pre></td></tr></table></figure><h1 id="三-nginx配置文件"><a href="#三-nginx配置文件" class="headerlink" title="三. nginx配置文件"></a>三. nginx配置文件</h1><blockquote><p>nginx配置文件：<br>主配置文件：<br>/etc/nginx<br>/etc/nginx/nginx.conf<br>/etc/nginx/conf.d/*<br>cgi,fastcgi,uwcgi配置文件<br>/etc/nginx/fastcgi_params<br>/etc/nginx/scgi_params<br>/etc/nginx/uwsgi_params<br>编码转换映射文件<br>/etc/nginx/win-utf<br>/etc/nginx/koi-utf<br>/etc/nginx/koi-win<br>http协议的conten-type与扩展名<br>/etc/nginx/mime.types<br>systemd：<br>/usr/lib/systemd/system/nginx.service<br>nginx日志轮询，日志切割<br>/etc/logrotate.d/nginx<br>模块目录<br>/etc/nginx/modules<br>/usr/lib64/nginx<br>/usr/lib64/nginx/modules<br>默认站点目录<br>/usr/share/nginx<br>/usr/share/nginx/html/*.html<br>logs:<br>/var/log/nginx<br>缓存：<br>/var/cache/nginx</p></blockquote><p>默认使用rpm包的nginx相关配置文件如上，如果是源码安装的如果没特别指定路径一般在编译安装prefix指定的nginx根目录下，也有些文件夹不会自动生成可以手动生成。比较重要的配置文件有</p><p><strong>conf/nginx.conf：这个是nginx的根配置文件</strong></p><p><strong>html站点目录：这个是网站文件夹的路径（也可以不用默认的路径）</strong></p><p><strong>nginx.logs:nginx日志生成目录</strong></p><h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><h3 id="nginx配置文件格式一般为："><a href="#nginx配置文件格式一般为：" class="headerlink" title="nginx配置文件格式一般为："></a>nginx配置文件格式一般为：</h3><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">...</span> <span class="python">  <span class="hljs-comment"># 全局配置段，例如nginx日志文件路径，pid文件路径，nginx用户，进程信息在这里配置</span></span><br>events&#123;<br><br><span class="hljs-meta">...</span> <span class="python"> <span class="hljs-comment">#事件驱动配置端，可定义nginx的事件驱动模型，最大连接数等信息</span></span><br>&#125;<br><br>http &#123;<br><br><span class="hljs-meta">...</span> <span class="python"> <span class="hljs-comment">#http定义一个http服务的相关配置，一般下面会包含多个server，一个server又会包含多个location</span></span><br>server&#123;<br><br><span class="hljs-meta">...</span> <span class="python"><span class="hljs-comment">#server定义的是一个虚拟主机的信息，下面可能会有多个location</span></span><br>location &#123;<br><br>.. #location定义的是虚拟主机，location 指令的功能是用来匹配不同的 URI 请求，进而对请求做不同的处理和响应。例如一个网站的/根目录会匹配到服务器主机的哪个文件目录，就是在这里定义的<br>&#125;<br><br>&#125;<br><br>&#125; #一个配置段由&#123; 开始 &#125; 结尾,  ...表示省略的具体配置信息<br></code></pre></td></tr></table></figure><h3 id="完整配置文件以及常用到的一些配置："><a href="#完整配置文件以及常用到的一些配置：" class="headerlink" title="完整配置文件以及常用到的一些配置："></a>完整配置文件以及常用到的一些配置：</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#定义Nginx运行的用户和用户组</span><br><span class="hljs-attribute">user</span>  www www;<br><span class="hljs-comment">#启动进程,通常设置成和cpu的数量相等</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">8</span>;<br><span class="hljs-attribute">worker_cpu_affinity</span> <span class="hljs-number">00000001</span> <span class="hljs-number">00000010</span> <span class="hljs-number">00000100</span> <span class="hljs-number">00001000</span> <span class="hljs-number">00010000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01000000</span> <span class="hljs-number">10000000</span>;<br><span class="hljs-comment">#为每个进程分配cpu，上例中将8个进程分配到8个cpu，当然可以写多个，或者将一个进程分配到多个cpu。</span><br><span class="hljs-attribute">worker_rlimit_nofile</span> <span class="hljs-number">102400</span>;<br><span class="hljs-comment">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打</span><br><span class="hljs-comment">#开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀</span><br><span class="hljs-comment">#，所以最好与ulimit -n的值保持一致。</span><br><span class="hljs-comment">#全局错误日志及PID文件</span><br><span class="hljs-attribute">error_log</span>  /usr/local/nginx/logs/error.log; <br><span class="hljs-comment">#错误日志定义等级，[ debug | info | notice | warn | error | crit ]</span><br><span class="hljs-attribute">pid</span>        /usr/local/nginx/nginx.pid;<br><span class="hljs-comment">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀.</span><br><span class="hljs-comment">#所以建议与ulimit -n的值保持一致。</span><br><span class="hljs-attribute">worker_rlimit_nofile</span> <span class="hljs-number">65535</span>;<br><span class="hljs-comment">#工作模式及连接数上限</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">use</span>   <span class="hljs-literal">epoll</span>;             <span class="hljs-comment">#epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">102400</span>;<span class="hljs-comment">#单个后台worker process进程的最大并发链接数 （最大连接数=连接数*进程数）</span><br>    <span class="hljs-attribute">multi_accept</span>  <span class="hljs-literal">on</span>; <span class="hljs-comment">#尽可能多的接受请求</span><br>&#125;<br><span class="hljs-comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment">#设定mime类型,类型由mime.type文件定义</span><br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br>    <span class="hljs-comment">#设定日志格式</span><br>    <span class="hljs-attribute">access_log</span>    /usr/local/nginx/log/nginx/access.log;<br> <span class="hljs-attribute">sendfile</span>      <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用必须设为 on</span><br><span class="hljs-comment">#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span><br><span class="hljs-comment">#autoindex  on;  #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>; <span class="hljs-comment">#防止网络阻塞</span><br><span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">60</span>;<br><span class="hljs-comment">#keepalive超时时间，客户端到服务器端的连接持续有效时间,当出现对服务器的后,继请求时,keepalive-timeout功能可避免建立或重新建立连接。</span><br>    <span class="hljs-attribute">tcp_nodelay</span>   <span class="hljs-literal">on</span>; <span class="hljs-comment">#提高数据的实时响应性</span><br>   <span class="hljs-comment">#开启gzip压缩</span><br>   <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">gzip_min_length</span>  <span class="hljs-number">1k</span>;<br><span class="hljs-attribute">gzip_buffers</span>     <span class="hljs-number">4</span> <span class="hljs-number">16k</span>;<br><span class="hljs-attribute">gzip_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br><span class="hljs-attribute">gzip_comp_level</span>  <span class="hljs-number">4</span>; <span class="hljs-comment">#压缩级别大小，最大为9，值越小，压缩后比例越小，CPU处理更快。</span><br><span class="hljs-comment">#值越大，消耗CPU比较高。</span><br><span class="hljs-attribute">gzip_types</span>       text/plain application/x-javascript text/css application/xml;<br><span class="hljs-attribute">gzip_vary</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">10m</span>;      <span class="hljs-comment">#允许客户端请求的最大单文件字节数</span><br>    <span class="hljs-attribute">client_body_buffer_size</span> <span class="hljs-number">128k</span>;  <span class="hljs-comment">#缓冲区代理缓冲用户端请求的最大字节数，</span><br>    <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">120</span>;      <span class="hljs-comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span><br>    <span class="hljs-attribute">proxy_send_timeout</span> <span class="hljs-number">120</span>;         <span class="hljs-comment">#后端服务器数据回传时间(代理发送超时)</span><br>    <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">120</span>;         <span class="hljs-comment">#连接成功后，后端服务器响应时间(代理接收超时)</span><br>    <span class="hljs-attribute">proxy_buffer_size</span> <span class="hljs-number">4k</span>;          <span class="hljs-comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br>    <span class="hljs-attribute">proxy_buffers</span> <span class="hljs-number">4</span> <span class="hljs-number">32k</span>;           <span class="hljs-comment">#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span><br>    <span class="hljs-attribute">proxy_busy_buffers_size</span> <span class="hljs-number">64k</span>;   <span class="hljs-comment">#高负荷下缓冲大小（proxy_buffers*2）</span><br><br>    <span class="hljs-comment">#设定请求缓冲</span><br>    <span class="hljs-attribute">large_client_header_buffers</span>  <span class="hljs-number">4</span> <span class="hljs-number">4k</span>;<br><span class="hljs-attribute">client_header_buffer_size</span> <span class="hljs-number">4k</span>;<br><span class="hljs-comment">#客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k</span><br><span class="hljs-comment">#不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="hljs-attribute">open_file_cache</span> max=<span class="hljs-number">102400</span> inactive=<span class="hljs-number">20s</span>;<br><span class="hljs-comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="hljs-attribute">open_file_cache_valid</span> <span class="hljs-number">30s</span>;<br><span class="hljs-comment">#这个是指多长时间检查一次缓存的有效信息。</span><br><span class="hljs-attribute">open_file_cache_min_uses</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive</span><br>    <span class="hljs-comment">#包含其它配置文件，如自定义的虚拟主机</span><br>   <span class="hljs-comment">#include  vhosts.conf;</span><br><span class="hljs-comment">#这里为后端服务器wugk应用集群配置，根据后端实际情况修改即可，tdt_wugk为负载均衡名称，可以任意指定</span><br><span class="hljs-comment">#但必须跟vhosts.conf虚拟主机的pass段一致，否则不能转发后端的请求。weight配置权重，在fail_timeout内检查max_fails次数，失败则剔除均衡。</span><br><span class="hljs-attribute">upstream</span> tdt_wugk &#123;<br><span class="hljs-attribute">server</span>   <span class="hljs-number">127.0.0.1:8080</span> weight=<span class="hljs-number">1</span> max_fails=<span class="hljs-number">2</span> fail_timeout=<span class="hljs-number">30s</span>;<br><span class="hljs-attribute">server</span>   <span class="hljs-number">127.0.0.1:8081</span> weight=<span class="hljs-number">1</span> max_fails=<span class="hljs-number">2</span> fail_timeout=<span class="hljs-number">30s</span>;<br>&#125;<br>   <span class="hljs-comment">#虚拟主机配置</span><br><span class="hljs-section">server</span> &#123;<br><span class="hljs-comment">#侦听80端口</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-comment">#定义使用www.wuguangke.cn访问</span><br>        <span class="hljs-attribute">server_name</span>  www.wuguangke.cn;<br>        <span class="hljs-comment">#设定本虚拟主机的访问日志</span><br>        <span class="hljs-attribute">access_log</span>  logs/access.log  main;<br><span class="hljs-attribute">root</span>   /data/webapps/wugk;  <span class="hljs-comment">#定义服务器的默认网站根目录位置</span><br>        <span class="hljs-attribute">index</span> index.php index.html index.htm;   <span class="hljs-comment">#定义首页索引文件的名称</span><br>        <span class="hljs-comment">#默认请求</span><br>        <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /</span>&#123;<br>          <span class="hljs-attribute">root</span>   /data/www/wugk;      <span class="hljs-comment">#定义服务器的默认网站根目录位置</span><br>          <span class="hljs-attribute">index</span> index.php index.html index.htm;   <span class="hljs-comment">#定义首页索引文件的名称</span><br>          <span class="hljs-comment">#以下是一些反向代理的配置.</span><br>  <span class="hljs-attribute">proxy_next_upstream</span> http_502 http_504 <span class="hljs-literal">error</span> timeout invalid_header;<br>  <span class="hljs-comment">#如果后端的服务器返回502、504、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。</span><br>          <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;<br>          <span class="hljs-comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br>          <span class="hljs-attribute">proxy_set_header</span> Host $host;<br>          <span class="hljs-attribute">proxy_set_header</span> X-Real-IP $remote_addr;<br>          <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;<br>   <span class="hljs-attribute">proxy_pass</span>  http://tdt_wugk;     <span class="hljs-comment">#请求转向后端定义的均衡模块</span><br>       &#125;<br><span class="hljs-comment">#配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。</span><br><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$</span><br>&#123;<br><span class="hljs-attribute">root</span> /data/www/wugk;<br><span class="hljs-comment">#expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力。</span><br><span class="hljs-attribute">expires</span>      <span class="hljs-number">30d</span>;<br>&#125;<br>        <span class="hljs-comment">#PHP脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br>        <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ \.php$</span> &#123;<br>            <span class="hljs-attribute">root</span> /root;<br>            <span class="hljs-attribute">fastcgi_pass</span> <span class="hljs-number">127.0.0.1:9000</span>;<br>            <span class="hljs-attribute">fastcgi_index</span> index.php;<br>            <span class="hljs-attribute">fastcgi_param</span> SCRIPT_FILENAME /data/www/wugk$fastcgi_script_name;<br>            <span class="hljs-attribute">include</span> fastcgi_params;<br>        &#125;<br>        <span class="hljs-comment">#设定查看Nginx状态的地址</span><br>        <span class="hljs-attribute">location</span> /NginxStatus &#123;<br>            <span class="hljs-attribute">stub_status</span>  <span class="hljs-literal">on</span>;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四-nginx常用命令"><a href="#四-nginx常用命令" class="headerlink" title="四.nginx常用命令"></a>四.nginx常用命令</h1><p>nginx -v #查看版本号</p><p>nginx -V #查看版本号以及安装时安装的模块</p><p>nginx -s reload | stop 重新载入配置文件|停止nginx</p><p>nginx -t 检查配置文件语法是否正确</p><p>nginx 直接输入命令表示启动nginx进程</p><h1 id="五-nginx常用模块功能"><a href="#五-nginx常用模块功能" class="headerlink" title="五.nginx常用模块功能"></a>五.nginx常用模块功能</h1><h2 id="1-nginx目录索引"><a href="#1-nginx目录索引" class="headerlink" title="1.nginx目录索引"></a>1.nginx目录索引</h2><p>目录索引模块：ngx_http_autoindex_module</p><p>默认：编译进内核</p><p>编译参数：<code>--without-http_autoindex_module</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">autoindex <span class="hljs-keyword">on</span>;<br>加在对应<span class="hljs-keyword">location</span>里面即可实现目录索引浏览（autoindex也可加在http，<span class="hljs-keyword">server</span>里面，但一般不这么用）Syntax:autoindex <span class="hljs-keyword">on</span>|<span class="hljs-keyword">off</span>;<br><span class="hljs-keyword">default</span>： autoindex <span class="hljs-keyword">off</span>;<br>context: http <span class="hljs-keyword">server</span> <span class="hljs-keyword">location</span>常用参数<br>autoindex_exact_size <span class="hljs-keyword">off</span>;<br>默认为<span class="hljs-keyword">on</span>，显示出文件的确切大小，单位为bytes<br><span class="hljs-keyword">off</span>，显示文件的大概大小，单位为kb <span class="hljs-keyword">or</span> MB <span class="hljs-keyword">or</span> GBautoindex_localtime <span class="hljs-keyword">on</span>;<br>默认为<span class="hljs-keyword">off</span>，显示的文件时间为GMT时间<br>默认为<span class="hljs-keyword">on</span>，显示的文件时间为文件的服务器时间charset utf<span class="hljs-number">-8</span>,gbk;<br>默认中文目录乱码，添加防止乱码。<br></code></pre></td></tr></table></figure><p>示例：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109524.jpeg" alt="image.png"></p><p>nginx -s reload #重载配置文件</p><p>访问：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109551.jpeg" alt="image.png"></p><h2 id="2-nginx状态监控"><a href="#2-nginx状态监控" class="headerlink" title="2.nginx状态监控"></a>2.nginx状态监控</h2><p>状态监控模块：ngx_http_stub_status_module</p><p>默认：不编译进内核</p><p>编译参数：<code>--with-http_stub_status_module</code></p><p>配置实例</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">= /status</span> &#123;<br>stub_status;<br>access_log off;<br>&#125;<br><span class="hljs-comment">#启动状态时可关闭日志。</span><br></code></pre></td></tr></table></figure><p>访问：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109509.jpeg" alt="image.png"></p><p>因安全缘由，建议status状态页面仅内网开放访问或限制访问ip访问认证限制。</p><h2 id="3-nginx访问控制"><a href="#3-nginx访问控制" class="headerlink" title="3.nginx访问控制"></a>3.nginx访问控制</h2><p>基于IP的访问控制模块： http_access_module 默认：编译进内核 编译参数：<code>--without-http_access_module</code><br>基于用户登录认证模块： http_auth_basic_module 默认：编译进内核 编译参数：<code>--without-http_auth_basic_module</code></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP:"></a>IP:</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">允许:<br>syntax: allow address |<span class="hljs-type">CIDR</span> |unix:  |<span class="hljs-keyword">all</span>;<br><span class="hljs-keyword">Default</span>:-<br>context: httpx <span class="hljs-keyword">server</span>,<span class="hljs-keyword">location</span>,limit_except<br>拒绝:<br>syntax: deny address |<span class="hljs-type">CIDR</span> |unix:   |<span class="hljs-keyword">all</span>;<br>context: http, <span class="hljs-keyword">server</span>, <span class="hljs-keyword">location</span>, limit_except<br><span class="hljs-keyword">default</span>： -<br></code></pre></td></tr></table></figure><p>示例</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231110021.jpeg" alt="image.png"></p><p>本机访问（本机ip为10.10.10.214）</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109487.jpeg" alt="image.png"></p><p>已被拒绝，其他同网端服务器访问没问题。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231110203.jpeg" alt="image.png"></p><h3 id="登录认证访问："><a href="#登录认证访问：" class="headerlink" title="登录认证访问："></a>登录认证访问：</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//配置语法</span><br><span class="hljs-symbol">syntax:</span> auth_basic string|off;<br><span class="hljs-symbol">default:</span> auth_basic off;<br><span class="hljs-symbol">Context:</span><br>http, server， location，limit_except<br><span class="hljs-comment">//用户密码记录配置文件</span><br><span class="hljs-symbol">syntax:</span> auth_basic_user_file file;<br><span class="hljs-symbol">Default:</span> -<br><span class="hljs-symbol">Context:</span><br>http, server, location，limit_except<br></code></pre></td></tr></table></figure><p>yum -y install httpd-tools (安装http工具包)<br>htpasswd -b -c /x/x/x admin 123456</p><p>前面是用户后面是密码，生产用户密码文件</p><p>示例：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109831.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231110808.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109047.jpeg" alt="image.png"></p><h2 id="4-访问限制"><a href="#4-访问限制" class="headerlink" title="4.访问限制"></a>4.访问限制</h2><p>经常会遇到这种情况，服务器流量异常，负载过大等等。对于大流量恶意的攻击访问，会带来带宽的浪费，服务器压力，影响业务，往往考虑对同一个IP的连接数，并发数进行限制。</p><p>限制连接数：<code>ngx_http_limit_req_module</code></p><p>限制请求频率：<code>ngx_http_limit_conn_module</code></p><p>默认：编译进内核</p><p>编译参数：<code>--without-http_limit_conn_module</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">--without-http_limit_req_module</span><br></code></pre></td></tr></table></figure><p><a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html">limit_req_zone</a> 用来限制单位时间内的请求数，即速率限制,采用的<strong>漏桶算法 “leaky bucket”</strong></p><p><a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html">limit_conn_zone</a> 用来限制同一时间连接数，即并发限制</p><h3 id="limit-conn-zone"><a href="#limit-conn-zone" class="headerlink" title="limit_conn_zone:"></a>limit_conn_zone:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">句法：limit_conn_zone key zone=name:size;<br>默认：—<br>内容：http <br>Syntax: limit_conn zone number<br> Default: — <br>Context: http,server, location<br>可能有几个`limit_conn`指令。例如，以下配置将限制每个客户端IP与服务器的连接数，并同时限制与虚拟服务器的连接总数：<br>limit_conn_zone <span class="hljs-variable">$binary_remote_addr</span> zone=addr:10m;<br><br>server &#123;<br>    location /download/ &#123;<br>        limit_conn addr 1;<span class="hljs-comment">#一次每个IP地址只允许一个连接。</span><br>    &#125;<br>limit_conn_zone <span class="hljs-variable">$binary_remote_addr</span> zone=perip:10m;<br>limit_conn_zone <span class="hljs-variable">$server_name</span> zone=perserver:10m;<br><br>server &#123;<br>    ...<br>    limit_conn perip 10;<br>    limit_conn perserver 100;<br>&#125;<br></code></pre></td></tr></table></figure><p>当且仅当<code>limit_conn</code>当前级别上未定义任何指令时，这些指令才从先前的配置级别继承。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">句法：limit_conn_dry_run <span class="hljs-keyword">on</span> | <span class="hljs-keyword">off</span>;<br>默认：<br>limit_conn_dry_run <span class="hljs-keyword">off</span>;<br>内容：http，<span class="hljs-keyword">server</span>，<span class="hljs-keyword">location</span><br></code></pre></td></tr></table></figure><p>启用空运行模式。在这种模式下，连接数不受限制，但是，在共享内存区域中，过多连接的数将照常计算。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">句法：limit_conn_log_level <span class="hljs-keyword">info</span> | <span class="hljs-keyword">notice</span> | warn | error;<br>默认：<br>limit_conn_log_level error;<br>内容：http，<span class="hljs-keyword">server</span>，<span class="hljs-keyword">location</span><br></code></pre></td></tr></table></figure><p>为服务器限制连接数的情况设置所需的日志记录级别。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">句法：limit_conn_status code<span class="hljs-comment">;</span><br>默认：<br>limit_conn_status <span class="hljs-number">503</span><span class="hljs-comment">;</span><br>内容：http，server，location<br></code></pre></td></tr></table></figure><p>设置状态代码以响应被拒绝的请求而返回。</p><h3 id="limit-req-zone"><a href="#limit-req-zone" class="headerlink" title="limit_req_zone:"></a>limit_req_zone:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">句法：limit_req_zone key zone=name:size rate=rate [sync];<br>默认：—<br>内容：http<br><br>Sntax:limit_req zone=name [burst=number] [nodelay | delay=number];<br>Default:—<br>Context:http, server, location<br>http &#123;<br>    limit_req_zone <span class="hljs-variable">$binary_remote_addr</span> zone=one:10m rate=1r/s;<br><br>    ...<br><br>    server &#123;<br><br>        ...<br><br>        location /search/ &#123;<br>            limit_req zone=one burst=5;<br>        &#125;<br></code></pre></td></tr></table></figure><p>http{<br>//http段配置请求限制,rate限制速率，限制一秒钟最多一个IP请求<br>limit_req_zone $binary_remote_addr zone=req_zone:10m rate=1r/s;<br>…<br>server {<br>…<br>location / {<br>//1r/s只接收一个请求,其余请求拒绝处理并返回错误码给客户端..<br>limit_req zone=req_zone;<br>//请求超过1r/s,剩下的将被延迟处理,请求数超过burst定义的数量，多余的请求返回503<br>#limit_req zone=req_zone burst=3 nodelay;<br>}<br>}}<br>rate=1r/s表示每秒最大一个请求，burst=3表示请求队列最大为3</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">句法：limit_req_dry_run <span class="hljs-keyword">on</span> | <span class="hljs-keyword">off</span>;<br>默认：<br>limit_req_dry_run <span class="hljs-keyword">off</span>;<br>内容：http，<span class="hljs-keyword">server</span>，<span class="hljs-keyword">location</span><br></code></pre></td></tr></table></figure><p>启用空运行模式。在这种模式下，请求处理速率不受限制，但是，在共享内存区域中，过多请求的数量将照常计算。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">句法：limit_req_log_level <span class="hljs-keyword">info</span> | <span class="hljs-keyword">notice</span> | warn | error;<br>默认：<br>limit_req_log_level error;<br>内容：http，<span class="hljs-keyword">server</span>，<span class="hljs-keyword">location</span><br></code></pre></td></tr></table></figure><p>在服务器由于速率超出而拒绝处理请求或延迟请求处理的情况下，设置所需的日志记录级别。延迟的记录级别比拒绝的记录级别少1分；例如，如果<code>limit_req_log_level notice</code>指定“ ” ，则将延迟记录为该<code>info</code>级别。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">句法：limit_req_status code<span class="hljs-comment">;</span><br>默认：<br>limit_req_status <span class="hljs-number">503</span><span class="hljs-comment">;</span><br>内容：http，server，location<br></code></pre></td></tr></table></figure><p>设置状态代码以响应被拒绝的请求而返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$server_name</span> 表示服务器的变量<br><span class="hljs-variable">$binary_remote_addr</span> 变量长度是固定的4字节<br><span class="hljs-variable">$remote_addr</span> 变量长度是7-15字节<br>一个IP地址=32bit=4字节，所以一般用第一个变量即可<br>两个都是代表IP地址的变量，区别在于变量存储长度（也可直接换成某个IP地址，但是限制一般针对所有IP地址，而非一个ip地址，所以使用变量）<br></code></pre></td></tr></table></figure><h2 id="5-日志模块"><a href="#5-日志模块" class="headerlink" title="5.日志模块"></a>5.日志模块</h2><p>日志模块：</p><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">ngx_http_log_module</a></li></ul><p>默认：编译进内核（在官方文档的编译模块中，没有日志模块的编译或不编译进内核的选项）</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Syntax:log_format <span class="hljs-keyword">name</span> [escape=<span class="hljs-keyword">default</span>|json|<span class="hljs-keyword">none</span>] string ...;<br><span class="hljs-keyword">Default</span>:<br>log_format combined <span class="hljs-string">&quot;...&quot;</span>;<br>Context:http<br><br>Syntax:access_log path [<span class="hljs-keyword">format</span> [buffer=<span class="hljs-built_in">size</span>] [gzip[=level]] [<span class="hljs-keyword">flush</span>=time] [<span class="hljs-keyword">if</span>=condition]];<br>access_log off;<br><span class="hljs-keyword">Default</span>:<br>access_log logs/<span class="hljs-keyword">access</span>.<span class="hljs-built_in">log</span> combined;<br>Context:http, server, location, <span class="hljs-keyword">if</span> <span class="hljs-keyword">in</span> location, limit_except<br></code></pre></td></tr></table></figure><p>配置示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">   log_format  main  <span class="hljs-string">&#x27;<span class="hljs-subst">$remote_addr</span> - <span class="hljs-subst">$remote_user</span> [<span class="hljs-subst">$time_local</span>] &quot;<span class="hljs-subst">$request</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;<span class="hljs-subst">$status</span> <span class="hljs-subst">$body_bytes_sent</span> &quot;<span class="hljs-subst">$http_referer</span>&quot; &#x27;</span><br>                    <span class="hljs-string">&#x27;&quot;<span class="hljs-subst">$http_user_agent</span>&quot; &quot;<span class="hljs-subst">$http_x_forwarded_for</span>&quot;&#x27;</span>;<br><br>access_log logs/access.log main;<br></code></pre></td></tr></table></figure><p>log_format是定义的日志格式，access_log是存放的位置。main为日志的名称，下面通过这个main来进行调用</p><p>log_format 后面首先定义日志名称，然后’’中间代表日志显示格式，调用的是nginx变量，例如$remote_addr是客户端ip地址 , remote_user是客户端用户,下面是日志实际显示示例：</p><p><img src="https://b3logfile.com/file/2021/02/image-677a1224.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image.png"></p><p>nginx常见内置变量：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs gams">嵌入式变量<br>该ngx_http_core_module模块支持名称与Apache Server变量匹配的嵌入式变量。首先，这些是代表客户端请求标头字段的变量，例如<span class="hljs-symbol">$</span>http_user_agent，<span class="hljs-symbol">$</span>http_cookie等。另外还有其他变量：<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$arg</span>_name</span><br>name请求行中的 参数<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$args</span></span><br>请求行中的参数<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$binary</span>_remote_addr</span><br>客户端地址（二进制形式），对于IPv4地址，值的长度始终为<span class="hljs-number">4</span>个字节，对于IPv6地址，值的长度始终为<span class="hljs-number">16</span>个字节<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$body</span>_bytes_sent</span><br>发送给客户端的字节数，不计算响应头；此变量与 Apache模块 的“ %B”参数 兼容mod_log_config<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$bytes</span>_sent</span><br>发送给客户端的字节数（<span class="hljs-number">1.3</span><span class="hljs-number">.8</span>、<span class="hljs-number">1.2</span><span class="hljs-number">.5</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$connection</span></span><br>连接序列号（<span class="hljs-number">1.3</span><span class="hljs-number">.8</span>、<span class="hljs-number">1.2</span><span class="hljs-number">.5</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$connection</span>_requests</span><br>通过连接发出的当前请求数（<span class="hljs-number">1.3</span><span class="hljs-number">.8</span>、<span class="hljs-number">1.2</span><span class="hljs-number">.5</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$content</span>_length</span><br>“内容长度”请求标头字段<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$content</span>_type</span><br>“内容类型”请求标头字段<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$cookie</span>_name</span><br>该name饼干<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$document</span>_root</span><br>当前请求的根或别名指令的值<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$document</span>_uri</span><br>和...一样 <span class="hljs-symbol">$</span>uri<br><span class="hljs-meta"><span class="hljs-meta-keyword">$host</span></span><br>优先顺序如下：请求行中的主机名，或“主机”请求标头字段中的主机名，或与请求匹配的服务器名<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$hostname</span></span><br>主机名<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$http</span>_name</span><br>任意请求头字段；变量名称的最后一部分是字段名称，该字段名称已转换为小写，并用短划线代替了下划线<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$https</span></span><br>on如果连接以SSL模式运行，则为 “ ”，否则为空字符串<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$is</span>_args</span><br>“ ?”（如果请求行包含参数），否则为空字符串<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$limit</span>_rate</span><br>设置此变量将启用响应率限制；参见limit_rate<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$msec</span></span><br>以毫秒为单位的当前时间（以秒为单位）（<span class="hljs-number">1.3</span><span class="hljs-number">.9</span>，<span class="hljs-number">1.2</span><span class="hljs-number">.6</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$nginx</span>_version</span><br>Nginx版本<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$pid</span></span><br>工作进程的PID<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$pipe</span></span><br>“ p”如果请求被流水线.“ ”否则（<span class="hljs-number">1.3</span><span class="hljs-number">.12</span>，<span class="hljs-number">1.2</span><span class="hljs-number">.7</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$proxy</span>_protocol_addr</span><br>来自PROXY协议标头（<span class="hljs-number">1.5</span><span class="hljs-number">.12</span>）的客户端地址<br>必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$proxy</span>_protocol_port</span><br>PROXY协议标头（<span class="hljs-number">1.11</span><span class="hljs-number">.0</span>）中的客户端端口<br>必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$proxy</span>_protocol_server_addr</span><br>PROXY协议标头中的服务器地址（<span class="hljs-number">1.17</span><span class="hljs-number">.6</span>）<br>必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$proxy</span>_protocol_server_port</span><br>PROXY协议标头中的服务器端口（<span class="hljs-number">1.17</span><span class="hljs-number">.6</span>）<br>必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$query</span>_string</span><br>和...一样 <span class="hljs-symbol">$</span>args<br><span class="hljs-meta"><span class="hljs-meta-keyword">$realpath</span>_root</span><br>绝对路径名，对应于当前请求的 根或别名指令的值，所有符号链接都解析为真实路径<br><span class="hljs-meta"><span class="hljs-meta-keyword">$remote</span>_addr</span><br>客户地址<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$remote</span>_port</span><br>客户端口<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$remote</span>_user</span><br>基本身份验证随附的用户名<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span></span><br>完整的原始请求行<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_body</span><br>请求主体<br>当将请求正文读取到内存缓冲区时， 该变量的值可在proxy_pass， fastcgi_pass， uwsgi_pass和 scgi_pass指令处理的位置 使用。<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_body_file</span><br>带有请求正文的临时文件的名称<br>在处理结束时，需要删除文件。要始终将请求正文写入文件， 需要启用client_body_in_file_only。当在代理请求中或在对FastCGI / uwsgi / SCGI服务器的请求中传递临时文件的名称时，应分别通过 proxy_pass_request_body off， fastcgi_pass_request_body off， uwsgi_pass_request_body off或 scgi_pass_request_body off 指令来禁用传递请求正文。 。<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_completion</span><br>“ OK”（如果请求已完成），否则为空字符串<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_filename</span><br>基于root或<span class="hljs-keyword">alias</span> 指令以及请求URI 的当前请求的文件路径<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_id</span><br>从<span class="hljs-number">16</span>个随机字节生成的唯一请求标识符，以十六进制（<span class="hljs-number">1.11</span><span class="hljs-number">.0</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_length</span><br>请求长度（包括请求行，标头和请求正文）（<span class="hljs-number">1.3</span><span class="hljs-number">.12</span>，<span class="hljs-number">1.2</span><span class="hljs-number">.7</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_method</span><br>请求方法，通常是“ GET”或“ POST”<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_time</span><br>请求以毫秒为单位的处理时间（以秒为单位）（<span class="hljs-number">1.3</span><span class="hljs-number">.9</span>、<span class="hljs-number">1.2</span><span class="hljs-number">.6</span>）；从客户端读取第一个字节以来经过的时间<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$request</span>_uri</span><br>完整的原始请求URI（带有参数）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$scheme</span></span><br>请求方案，“ http”或“ https”<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$sent</span>_http_name</span><br>任意响应头字段；变量名称的最后一部分是字段名称，该字段名称已转换为小写，并用短划线代替了下划线<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$sent</span>_trailer_name</span><br>在响应末尾发送的任意字段（<span class="hljs-number">1.13</span><span class="hljs-number">.2</span>）；变量名称的最后一部分是字段名称，该字段名称已转换为小写，并用短划线代替了下划线<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$server</span>_addr</span><br>接受请求的服务器的地址<br>计算此变量的值通常需要一个系统调用。为避免系统调用，listen伪指令必须指定地址并使用bind参数。<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$server</span>_name</span><br>接受请求的服务器的名称<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$server</span>_port</span><br>接受请求的服务器的端口<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$server</span>_protocol</span><br>请求协议，通常是“ HTTP/<span class="hljs-number">1.0</span>”，“ HTTP/<span class="hljs-number">1.1</span>”或“ HTTP / <span class="hljs-number">2.0</span> ”<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$status</span></span><br>响应状态（<span class="hljs-number">1.3</span><span class="hljs-number">.2</span>、<span class="hljs-number">1.2</span><span class="hljs-number">.2</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$tcpinfo</span>_rtt， $tcpinfo_rttvar， $tcpinfo_snd_cwnd， $tcpinfo_rcv_space</span><br>有关客户端TCP连接的信息；在支持TCP_INFO套接字选项的 系统上可用<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$time</span>_iso8601</span><br>ISO <span class="hljs-number">8601</span>标准格式（<span class="hljs-number">1.3</span><span class="hljs-number">.12</span>，<span class="hljs-number">1.2</span><span class="hljs-number">.7</span>）的本地时间<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$time</span>_local</span><br>通用日志格式的本地时间（<span class="hljs-number">1.3</span><span class="hljs-number">.12</span>，<span class="hljs-number">1.2</span><span class="hljs-number">.7</span>）<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$uri</span></span><br>请求中的当前URI，已规范化<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">$uri</span>在请求处理期间，例如在进行内部重定向或使用索引文件时， 的值可能会更改。</span><br></code></pre></td></tr></table></figure><p>更多变量：<code>https://nginx.org/en/docs/http/ngx_http_core_module.html#var_status</code></p><p>error_log(核心模块):</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">Syntax</span>:error_log <span class="hljs-keyword">file</span> [level];<br>Default:<br>error_log logs/<span class="hljs-keyword">error</span>.<span class="hljs-keyword">log</span> <span class="hljs-keyword">error</span>;<br>Context:main, http, mail, stream, server, location<br></code></pre></td></tr></table></figure><h2 id="6-虚拟站点"><a href="#6-虚拟站点" class="headerlink" title="6.虚拟站点"></a>6.虚拟站点</h2><p>所属模块：ngx_http_core_module（server和location都属于该模块）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">Syntax:server &#123; ... &#125;<br>Default:—<br>Context:http<br><br>Syntax:server_name name ...;<br>Default:<br>server_name <span class="hljs-string">&quot;&quot;</span>;<br>Context:server<br><br>Syntax:listen address[:port] [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="hljs-built_in">bind</span>] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];<br>listen port [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="hljs-built_in">bind</span>] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];<br>listen unix:path [default_server] [ssl] [http2 | spdy] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="hljs-built_in">bind</span>] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];<br>Default:<br>listen *:80 | *:8000;<br>Context:server<br></code></pre></td></tr></table></figure><p>一个server表示一个虚拟主机，一个服务器可能有多个虚拟主机（多个网站），实现虚拟主机的方式有三种：</p><p>基于IP：</p><p>每个server监听不同的IP地址，用server_name来指定（域名和IP都是通过server_name指定）</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109366.jpeg" alt="image.png"></p><p>基于域名：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231111658.jpeg" alt="image.png"></p><p>需要注意的是基于域名的虚拟主机首先需要通过DNS能解析到，所以要么是已经购买的域名并且配置解析到该服务器的IP上，要么是本地内部DNS配置以后整个内网可以访问到。需要基于DNS解析。但这里是测试，所以把解析放在 /etc/hosts文件即可（linux在解析主机名时会优先去查看hosts文件是否有解析条目）。域名相较于IP和端口的优点是只需要一个端口和一个ip地址即可用于多个虚拟主机，但需要多个域名以区分访问地址。</p><p>基于端口：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109353.jpeg" alt="image.png"></p><p>修改listen后的数字即可，默认是80，如果是https的话需要监听443且拥有证书。改为非80（443）端口后再浏览器访问时需主动输入端口号，不然浏览器默认会访问80端口。</p><h2 id="7-location"><a href="#7-location" class="headerlink" title="7. location"></a>7. location</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Syntax:location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;<br>location @name &#123; ... &#125;<br>Default:—<br>Context:server, location<br></code></pre></td></tr></table></figure><p>location一般放置与server里面，一个server可以有多个location，location是用于匹配访问地址的uri</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">=  精确匹配。如果这个查询匹配，那么将停止搜索并立即处理此请求。<br>~  为区分大小写匹配(可用正则表达式)<br>~*  为不区分大小写匹配(可用正则表达式)<br>^~  如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式。<br></code></pre></td></tr></table></figure><p>location匹配优先级：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">```(location `=` ) &gt; (location `完整路径` ) &gt; (location `^~` 路径) &gt; (location `~`,`~*` 从上向下正则顺序，匹配在最后一条终止) &gt; (location 部分起始路径) &gt; (`/`)<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = / &#123;<br>[ configuration A ]<br>&#125;<br><br>location / &#123;<br>[ configuration B ]<br>&#125;<br><br>location /documents/ &#123;<br>[ configuration C ]<br>&#125;<br><br>location ^~ /images/ &#123;<br>[ configuration D ]<br>&#125;<br><br>location ~* \.(gif|jpg|jpeg)$ &#123;<br>[ configuration E ]<br>&#125;<br><br>The “/”  匹配 configuration A,<br>the “/index.html”  匹配 configuration B,<br>the “/documents/document.html”  匹配 configuration C,<br>the “/images/1.gif”  匹配 configuration D,<br>and the “/documents/1.jpg”  匹配 configuration E.<br></code></pre></td></tr></table></figure><p>locaiton定义以后还需要将其匹配到linux服务器上对应的文件，就需要用到两个配置参数，root和index</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Syntax:root path;<br><span class="hljs-keyword">Default</span>:<br>root html;<br>Context:http, server, location, <span class="hljs-keyword">if</span> <span class="hljs-keyword">in</span> location<br><span class="hljs-keyword">Module</span> ngx_http_index_module:(<span class="hljs-built_in">INDEX</span>非core模块，而是单独模块)<br>Syntax:<span class="hljs-built_in">index</span> <span class="hljs-keyword">file</span> ...;<br><span class="hljs-keyword">Default</span>:<br><span class="hljs-built_in">index</span> <span class="hljs-built_in">index</span>.html;<br>Context:http, server, location<br></code></pre></td></tr></table></figure><p>root是定义其的路径，如root /tmp 放在/的location里面则，当访问路径为根时，会访问到/tmp目录，但是到具体的访问文件时，是由index定义的，一般index定义为index.html或index.htm，如为.php会涉及到fastcgi协议，因为nginx本身只能处理静态html文件。</p><h2 id="8-rewrite"><a href="#8-rewrite" class="headerlink" title="8.rewrite"></a>8.rewrite</h2><p>所属模块：Module ngx_http_rewrite_module</p><p>默认：编译进模块 编译参数：<code>--without-http_rewrite_module</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">Syntax:rewrite regex replacement [flag];<br>Default:—<br>Context:server, location, <span class="hljs-keyword">if</span><br><br>rewrite的含义：该指令是实现URL重写的指令。<br>regex的含义：用于匹配URI的正则表达式。<br>replacement：将regex正则匹配到的内容替换成 replacement。<br>flag: flag标记。<br><br>flag有如下值：<br><br>last: 本条规则匹配完成后，继续向下匹配新的location URI 规则。(不常用)<br><span class="hljs-built_in">break</span>: 本条规则匹配完成即终止，不再匹配后面的任何规则(不常用)。<br>redirect: 返回302临时重定向，浏览器地址会显示跳转新的URL地址。<br>permanent: 返回301永久重定向。浏览器地址会显示跳转新的URL地址。<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">rewrite ^(<span class="hljs-regexp">/download/</span>.*)<span class="hljs-regexp">/media/</span>(.*)\..*$ <span class="hljs-variable">$1</span><span class="hljs-regexp">/mp3/</span><span class="hljs-variable">$2</span>.mp3 <span class="hljs-keyword">break</span>;<br>rewrite ^(<span class="hljs-regexp">/download/</span>.*)<span class="hljs-regexp">/audio/</span>(.*)\..*$ <span class="hljs-variable">$1</span><span class="hljs-regexp">/mp3/</span><span class="hljs-variable">$2</span>.ra  <span class="hljs-keyword">break</span>;<br>rewrite ^<span class="hljs-regexp">/(.*) http:/</span><span class="hljs-regexp">/www.test.com/</span><span class="hljs-variable">$1</span> permanent;<br></code></pre></td></tr></table></figure><p>服务器如需看rewrite日志需要做以下配置：</p><p>1.设置nginx的错误日志级别为notice<br>error_log /var/log/nginx/error.log notice;<br>2.在http模块层，增加一行rewrite_log日志<br>http{<br>…<br>rewrite_log on;<br>…<br>}</p><h3 id="if"><a href="#if" class="headerlink" title="if:"></a>if:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Syntax:<span class="hljs-keyword">if</span> (condition) &#123; ... &#125;<br>Default:—<br>Context:server, location<br></code></pre></td></tr></table></figure><p>指定的<code>condition</code>被评估。如果为true，则执行括号内指定的此模块伪指令，并在伪指令内为请求分配配置 <code>if</code>。<code>if</code>指令中的配置是从先前的配置级别继承的。</p><p>条件可以是以下任意一种：</p><ul><li><p>变量名；如果变量的值为空字符串或“</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p>  ”，则为false；否则为false 。</p><blockquote><p>在1.0.1版之前，任何以“ <code>0</code>”开头的字符串都被视为错误值。</p></blockquote></li><li><p>使用“ <code>=</code>”和“ <code>!=</code>”运算符将变量与字符串进行比较；</p></li><li><p>使用“ <code>~</code>”（区分大小写的匹配）和“ <code>~*</code>”（区分大小写的匹配）运算符将变量与正则表达式进行匹配。正则表达式可以包含捕获，这些捕获可用于以后在<code>$1</code>..<code>$9</code>变量中重用。负运算符“ <code>!~</code>”和“ <code>!~*</code>”也可用。如果正则表达式包含“ <code>&#125;</code>”或“ <code>;</code>”字符，则整个表达式应用单引号或双引号引起来。</p></li><li><p>使用“ <code>-f</code>”和“ <code>!-f</code>”运算符检查文件是否存在；</p></li><li><p>使用“ <code>-d</code>”和“ <code>!-d</code>”运算符检查目录是否存在；</p></li><li><p>使用“ <code>-e</code>”和“ <code>!-e</code>”运算符检查文件，目录或符号链接是否存在；</p></li><li><p>使用“ <code>-x</code>”和“ <code>!-x</code>”运算符检查可执行文件。</p></li></ul><p>例子：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs stata">#如果UA包含<span class="hljs-string">&quot;MSIE&quot;</span>，rewrite请求到/msid/目录下<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$http_user_agent</span> ~ MSIE) &#123;<br><br>    rewrite ^(.*)$ /msie/<span class="hljs-variable">$1</span> <span class="hljs-keyword">break</span>;<br><br>&#125;<br><br> <br><br>#如果cookie匹配正则，设置变量<span class="hljs-variable">$id</span>等于正则引用部分<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$http_cookie</span> ~* <span class="hljs-string">&quot;id=([^;]+)(?:;|$)&quot;</span>) &#123;<br><br>    <span class="hljs-keyword">set</span> <span class="hljs-variable">$id</span> <span class="hljs-variable">$1</span>;<br><br> &#125;  <br><br> <br><br>#如果提交方法为<span class="hljs-keyword">POST</span>，则返回状态405（Method not allowed）。<span class="hljs-keyword">return</span>不能返回301,302<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-keyword">POST</span>) &#123;<br><br>    <span class="hljs-keyword">return</span> 405;<br><br>&#125;<br><br> <br><br>#限速，<span class="hljs-variable">$slow</span>可以通过 <span class="hljs-keyword">set</span> 指令设置<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$slow</span>) &#123;<br><br>    limit_rate 10k;<br><br>&#125; <br><br> <br><br>#如果请求的文件名不存在，则反向代理到localhost 。这里的<span class="hljs-keyword">break</span>也是停止rewrite检查<br><br><span class="hljs-keyword">if</span> (!-f <span class="hljs-variable">$request_filename</span>)&#123;<br><br>    <span class="hljs-keyword">break</span>;<br><br>    proxy_pass  http:<span class="hljs-comment">//127.0.0.1;</span><br><br>&#125;  <br><br> <br><br>#如果<span class="hljs-keyword">query</span> string中包含<span class="hljs-string">&quot;post=140&quot;</span>，永久重定向到example.com<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$args</span> ~ <span class="hljs-keyword">post</span>=140)&#123;<br><br>    rewrite ^ http:<span class="hljs-comment">//example.com/ permanent;</span><br><br>&#125;  <br><br> <br><br>#防盗链<br><br>location ~* \.(gif|jpg|png|swf|flv)$ &#123;<br><br>    valid_referers none blocked www.jefflei.com www.leizhenfang.com;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$invalid_referer</span>) &#123;<br><br>        <span class="hljs-keyword">return</span> 404;<br><br>    &#125; <br><br>&#125;<br></code></pre></td></tr></table></figure><p>if可使用的全局变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs bash">变量名称<br><br>变量说明<br><br><span class="hljs-variable">$args</span><br><br>这个变量等于请求行中的参数，同<span class="hljs-variable">$query_string</span><br><br><span class="hljs-variable">$content_length</span><br><br>请求头中的Content-length字段<br><br><span class="hljs-variable">$content_type</span><br><br>请求头中的Content-Type字段<br><br><span class="hljs-variable">$document_root</span><br><br>当前请求在root指令中指定的值<br><br><span class="hljs-variable">$host</span><br><br>请求主机头字段，否则为服务器名称<br><br><span class="hljs-variable">$http_user_agent</span><br><br>客户端agent信息<br><br><span class="hljs-variable">$http_cookie</span><br><br>客户端cookie信息<br><br><span class="hljs-variable">$limit_rate</span><br><br>这个变量可以限制连接速率<br><br><span class="hljs-variable">$request_method</span><br><br>客户端请求的动作，通常为GET或POST<br><br><span class="hljs-variable">$remote_addr</span><br><br>客户端的IP地址<br><br><span class="hljs-variable">$remote_port</span><br><br>客户端的端口<br><br><span class="hljs-variable">$remote_user</span><br><br>已经经过Auth Basic Module验证的用户名<br><br><span class="hljs-variable">$request_filename</span><br><br>当前请求的文件路径，由root或<span class="hljs-built_in">alias</span>指令与URI请求生成<br><br><span class="hljs-variable">$scheme</span><br><br>HTTP方法（如http，https）<br><br><span class="hljs-variable">$server_protocol</span><br><br>请求使用的协议，通常是HTTP/1.0或HTTP/1.1<br><br><span class="hljs-variable">$server_addr</span><br><br>服务器地址，在完成一次系统调用后可以确定这个值<br><br><span class="hljs-variable">$server_name</span><br><br>服务器名称<br><br><span class="hljs-variable">$server_port</span><br><br>请求到达服务器的端口号<br><br><span class="hljs-variable">$request_uri</span><br><br>包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”<br><br><span class="hljs-variable">$uri</span><br><br>不带请求参数的当前URI，<span class="hljs-variable">$uri</span>不包含主机名，如”/foo/bar.html”<br><br><span class="hljs-variable">$document_uri</span><br><br>与<span class="hljs-variable">$uri</span>相同<br></code></pre></td></tr></table></figure><h2 id="9-proxy模块"><a href="#9-proxy模块" class="headerlink" title="9.proxy模块"></a>9.proxy模块</h2><p>所属模块：ngx_http_proxy_module</p><p>默认：编译进模块 编译参数：<code>--without-http_proxy_module</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">句法：proxy_pass URL;<br>默认：—<br>内容：location，<span class="hljs-keyword">if</span> <span class="hljs-keyword">in</span> location，limit_except<br><br>Syntax:proxy_set_header field value;<br>Default:<br>proxy_set_header Host <span class="hljs-variable">$proxy_host</span>;<br>proxy_set_header Connection close;<br>Context:http, server, location<br></code></pre></td></tr></table></figure><h3 id="proxy："><a href="#proxy：" class="headerlink" title="proxy："></a>proxy：</h3><p>proxy_pass和proxy_set_header是proxy模块中最常用到的两个功能</p><p>proxy_pass例子：</p><blockquote><p>proxy_pass http：// localhost：8000 / uri /;</p></blockquote><blockquote><p>proxy_pass http：//unix/tmp/backend.socket/uri/;</p></blockquote><p>一般放在location下面，当location匹配到对应的uri之后，如果下面是proxy_pass而不是root，就会通过nginx去反向代理到proxy_pass指定的地址上面去请求访问。</p><p>反代的地址可以是ip地址，域名，sock文件地址，也可以是upstream指定的名称。</p><p>这个upstream是nginx的另一个模块叫做：ngx_http_upstream_module</p><h3 id="ngx-http-upstream-module"><a href="#ngx-http-upstream-module" class="headerlink" title="ngx_http_upstream_module"></a>ngx_http_upstream_module</h3><p>upstream最重要的功能是定义一组后端服务器，然后proxy_pass可以根据upstream定义好的直接调用，完成以后proxy_pass收到请求会将反向代理到upstream所定义的一组服务器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Syntax:upstream name &#123; ... &#125;<br>Default:—<br>Context:http<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> backend &#123;<br>    <span class="hljs-attribute">server</span> backend1.example.com       weight=<span class="hljs-number">5</span>;<br>    <span class="hljs-attribute">server</span> backend2.example.com:<span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server</span> unix:/tmp/backend3;<br><br>    <span class="hljs-attribute">server</span> backup1.example.com:<span class="hljs-number">8080</span>   backup;<br>    <span class="hljs-attribute">server</span> backup2.example.com:<span class="hljs-number">8080</span>   backup;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>upstream定义了一组后端服务器后，当然也会有调度方式：</p><p>1.如不进行任何配置，默认的调度方式为轮训调度。</p><p>2.weight:设置后端服务器的权重，权重大的优先访问</p><p>server 192.168.0.15 weight=10;</p><p>3.ip_hash:每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</p><p>upstream backend {<br>ip_hash;<br>server 192.168.0.14:88;}</p><p>4.fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><p>upstream backend {</p><p>fair;</p><p>server 192.168.0.14:88;}</p><p>5.url_hash（第三方）<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><p>6.least_conn:</p><p>最少连接数,那个机器连接数少就分发（lc）<br>7.wlc:<br>加权最少连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">upstream backend &#123;<br>server squid1:3128;<br>server squid2:3128;<br><span class="hljs-built_in">hash</span> <span class="hljs-variable">$request_uri</span>;<br>hash_method crc32;<br>&#125;<br><span class="hljs-comment">#定义负载均衡设备的Ip及设备状态</span><br>upstream backend&#123;<br>ip_hash;<br>server 127.0.0.1:9090 down;<br>server 127.0.0.1:8080 weight=2;<br>server 127.0.0.1:6060;<br>server 127.0.0.1:7070 backup;<br>&#125;<br></code></pre></td></tr></table></figure><p>常用参数：down ,backup,fail_timeout=time,max_fails=number,wight,max_conns=number<br>down:<br>当前的server暂时不参与负载均衡<br>backup:<br>预留的备份服务器<br>max_fails:<br>允许请求失败的次数<br>fail_timeout:<br>经过max_fails夫败后,服务暂停时间<br>max_conns:<br>限制最大的接收连接数</p><h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header:"></a>proxy_set_header:</h3><p>这几个的参数的作用是向后端转发的时候添加头信息；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">proxy_set_header   Host    <span class="hljs-variable">$host</span>:<span class="hljs-variable">$server_port</span>;<br>proxy_set_header   X-Real-IP   <span class="hljs-variable">$remote_addr</span>;<br>proxy_set_header   X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br></code></pre></td></tr></table></figure><blockquote><p>本文要说明nginx中的Host、X-Real-IP、X-Forwarded-For。</p><p>先看一个配置示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs text">server &#123;<br>    listen       80;<br>    server_name  192.168.1.2;<br>    error_log   /usr/local/etc/nginx/logs/test.error.log;<br>    access_log  /usr/local/etc/nginx/logs/test.access.log;<br>    location / &#123;<br>        proxy_set_header   X-Real-IP        $remote_addr;<br>        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;<br>        proxy_set_header   Host             $http_host;<br>        proxy_set_header   X-NginX-Proxy    true;<br>        proxy_set_header   Connection &quot;&quot;;<br>        proxy_http_version 1.1;<br>        add_header Access-Control-Allow-Origin *;<br>        proxy_pass  http://127.0.0.1:8889;<br>    &#125;  <br>    location /app &#123;<br>        proxy_set_header   X-Real-IP        $remote_addr;<br>        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;<br>        proxy_set_header   Host             $proxy_host;<br>        proxy_set_header   X-NginX-Proxy    true;<br>        proxy_set_header   Connection &quot;&quot;;<br>        proxy_http_version 1.1;<br>        proxy_pass http://192.168.1.3;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端地址（请求服务的地址）：192.168.1.1</p><p>nignx服务器地址：192.168.1.2</p><p>后端服务器地址：192.168.1.3</p><p>首先说明proxy_set_header是用来设置请求头的，设置了请求头后，后端服务器就可以获取到这些变量值。</p><p><strong>一、X-Real-IP</strong></p><p>是指客户端的真实IP，如果设置了$remote_addr这个值，后端服务器就能获取到客户端的真实IP，也就是此例中的192.168.1.1</p><p><strong>二、Host</strong></p><p>host的值设置为$proxy<em>host，</em>是指proxy_pass中设置的host值，也就是192.168.1.3，也就是服务器的IP地址。</p><p>若客户端发过来的请求header中有HOST这个字段，$http_host和$host表示的就是原始请求host，比如请求的时候HOST的值是<a href="https://link.zhihu.com/?target=http://test.com">http://test.com</a>，那么反代后还是<a href="https://link.zhihu.com/?target=http://test.com">http://test.com</a>。</p><p>若客户端发过来的请求header中没有HOST这个字段，$host表示nginx代理服务器的地址，也就是此例中的192.168.1.2。</p><p>$http<em>host不是一个固定的变量，他其实是$http</em>_HEADER通配后的结果，这里的HEADER是一个通配符，通配的是请求头里的header属性，例如<code>$http_content_type</code>表示请求头里<code>content-type</code>属性的值，同理，<code>$http_host</code>指的就是请求头里的<code>host</code>属性。</p><p><strong>三、X-Forwarded-For</strong></p><p>这个变量的值有$proxy_add_x_forwarded_for和$remote_addr，在只有一个代理服务器的转发的情况下，两者的效果貌似差不多，都可以真实的显示出客户端原始ip。</p><p>举例说明，用户A的IP是192.168.1.1，请求一个经过两次nginx转发的应用，在第一台nginx中（192.168.1.2），配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;<br></code></pre></td></tr></table></figure><p>现在$proxy_add_x_forwarded_for变量的”X-Forwarded-For”部分是空的，所以只有$remote_addr，而$remote_addr的值是用户的ip，那么X-Forwarded-For变量的值就是用户的ip：192.168.1.1。</p><p>到第二台nginx，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;<br></code></pre></td></tr></table></figure><p>现在的$proxy_add_x_forwarded_for变量，X-Forwarded-For部分包含的是用户的真实ip，$remote_addr部分的值是上一台nginx的ip地址，那么X-Forwarded-For的值就变成了”用户的真实ip，第一台nginx的ip”，也就是“192.168.1.1， 192.168.1.2”</p><p>所以还是建议X-Forwarded-For的值设置成$proxy_add_x_forwarded_for。</p></blockquote><h3 id="nginx正向代理："><a href="#nginx正向代理：" class="headerlink" title="nginx正向代理："></a>nginx正向代理：</h3><p>示例配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs server">    listen       80;<br>    server_name  localhost;<br>resolver                       223.5.5.5;<br>location / &#123;<br>proxy_pass http://$http_host$request_uri;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中重要的配置主要是：proxy_pass和 resolver</p><p>proxy指定其正向代理所转发的地址 $http_host为其url</p><p>$request_uri为其请求的uri</p><p>resolver后面跟的是其转发时使用的dns地址，如没指定，nginx无法正常解析dns，则无法访问域名网站。</p><h2 id="10-四层负载均衡"><a href="#10-四层负载均衡" class="headerlink" title="10.四层负载均衡"></a>10.四层负载均衡</h2><p>proxy模块默认只支持七层代理，也就是基于http协议代理，如果想要进行四层转发的话（也就是对其他协议进行转发），可以用到stream模块：</p><p>所属模块：ngx_stream_core_module</p><p>默认：该<code>ngx_stream_core_module</code>模块自1.9.0版开始可用。默认情况下未构建此模块，应使用<code>--with-stream</code> 配置参数启用它 。使用官方源默认会编译该模块</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Syntax:</span><span class="hljs-class">stream </span>&#123; ... &#125;<br><span class="hljs-symbol">Default:</span>—<br><span class="hljs-symbol">Context:</span>main<br></code></pre></td></tr></table></figure><p>在配置文件里面，其模块位置于http同级，下面是示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span> auto;<br><br><span class="hljs-attribute">error_log</span> /var/log/nginx/error.log <span class="hljs-literal">info</span>;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-attribute">upstream</span> backend &#123;<br>        <span class="hljs-attribute">hash</span> $remote_addr consistent;<br><br>        <span class="hljs-attribute">server</span> backend1.example.com:<span class="hljs-number">12345</span> weight=<span class="hljs-number">5</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:12345</span>            max_fails=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30s</span>;<br>        <span class="hljs-attribute">server</span> unix:/tmp/backend3;<br>    &#125;<br><br>    <span class="hljs-attribute">upstream</span> dns &#123;<br>       <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.1:53535</span>;<br>       <span class="hljs-attribute">server</span> dns.example.com:<span class="hljs-number">53</span>;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">12345</span>;<br>        <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">1s</span>;<br>        <span class="hljs-attribute">proxy_timeout</span> <span class="hljs-number">3s</span>;<br>        <span class="hljs-attribute">proxy_pass</span> backend;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">127.0.0.1:53</span> udp reuseport;<br>        <span class="hljs-attribute">proxy_timeout</span> <span class="hljs-number">20s</span>;<br>        <span class="hljs-attribute">proxy_pass</span> dns;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> [::<span class="hljs-number">1</span>]:<span class="hljs-number">12345</span>;<br>        <span class="hljs-attribute">proxy_pass</span> unix:/tmp/stream.socket;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里于七层代理在配置文件上最大的区别就是http换成了stream</p><p>下面是我在本地做的一个实例：</p><p>效果为将一台服务器的ssh协议转发到后端两台服务器</p><p>调度器：10.10.10.105</p><p>后端服务器：10.10.10.187 ,10.10.10.243</p><p>调度服务器nginx 配置添加如下</p><blockquote><p>stream {<br>upstream backend {<br>server 10.10.10.187:22;<br>server 10.10.10.243:22;<br>}<br>server {<br>listen 88 ;<br>proxy_pass backend;<br>}<br>}</p></blockquote><p>三台服务器都是虚拟机，添加好配置以后使用xshell进行测试</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231111912.jpeg" alt="image.png"></p><p>在弹出的对话框输入账号密码，然后测试成功！</p><p><strong>需要注意的是经过测试，stream模块是转发请求而非代理，严格意义上来说是四层转发，其功能于lvs无异。</strong></p><p>11.HTTPS</p><p>https在http中加入TLS/SSL层，http为明文传输，而https为密文传输，也更为安全。https默认监听端口443，需要证书进行认证，一般证书都有第三方机构或CA颁发。</p><p>所属模块：http_ssl_module</p><p>默认：不编译进内核 编译参数：–with-http_ssl_module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">syntax: ssl on | off;<br>Default: ssl off;<br>context: http, server<br><br>syntax : ssl_certificate file;<br>Default: -<br>context: http, server<br><br>syntax: ssl_certificate_key file;<br>Default: -<br>context: http, server<br></code></pre></td></tr></table></figure><p>nginx.conf配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>        listen       443 ssl;<br>        server_name  www.oldboy.com;<br><br>        ssl_certificate      ssl_key/server.crt;<br>        ssl_certificate_key  ssl_key/server.key;<br><br>        ssl_session_cache    shared:SSL:1m;<br>        ssl_session_timeout  5m;<br>    <span class="hljs-comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br>    <span class="hljs-comment">#    ssl_prefer_server_ciphers  on;</span><br><br>        location / &#123;<br>            root   /code/https;<br>            index  index.html index.htm;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>其中ssl_certificate为证书文件，ssl_certificate_key为秘钥文件。</p><p>在公司内部使用时，也可使用私有证书（公网中无法验证证书）。</p><p>私有证书颁发步骤：</p><p>1.生成key秘钥<br>2.生成证书签名请求文件 csr<br>3.生成证书签名文件 ca</p><p>要求：<br>1.openssl大于1.0.2<br>[root@localhost ~]# openssl version<br>OpenSSL 1.1.1g FIPS 21 Apr 2020</p><p>2.nginx必须有ssl模块<br>nginx -V</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">生成RSA密钥(过程需要设置一个密码,记住这个密码)<br>openssl genrsa -des3 -out domain.key 1024<br><br>拷贝一个不需要输入密码的密钥文件<br>openssl rsa -<span class="hljs-keyword">in</span> domain.key -out domain_nopass.key<br>生成一个证书请求<br>openssl req -new -key domain.key -out domain.csr<br>这里会提示输入国家,地区组织,email等信息.最重要的一个是<span class="hljs-string">&quot;common name&quot;</span>,需要与网站域名相同.<br><br>Enter pass phrase <span class="hljs-keyword">for</span> domain.key:              <span class="hljs-comment"># 之前设置的密码</span><br>-----<br>Country Name (2 letter code) [XX]:CN            <span class="hljs-comment"># 国家</span><br>State or Province Name (full name) []:Jilin         <span class="hljs-comment"># 地区或省份</span><br>Locality Name (eg, city) [Default City]:Changchun      <span class="hljs-comment"># 地区局部名</span><br>Organization Name (eg, company) [Default Company Ltd]:Python <span class="hljs-comment"># 机构名称</span><br>Organizational Unit Name (eg, section) []:Python      <span class="hljs-comment"># 组织单位名称</span><br>Common Name (eg, your name or your server<span class="hljs-string">&#x27;s hostname) []:domain.com # 网站域名</span><br><span class="hljs-string">Email Address []:123@domain.com               # 邮箱</span><br><span class="hljs-string">A challenge password []:                  # 私钥保护密码,可直接回车</span><br><span class="hljs-string">An optional company name []:                # 一个可选公司名称,可直接回车</span><br><span class="hljs-string"></span><br><span class="hljs-string">输入完这些就会生成一个domain.csr文件,提交给ssl提供商的时候就是这个csr文件.当然这里并没有向任何证书提供商申请,而是自己签发证书.</span><br><span class="hljs-string"></span><br><span class="hljs-string">使用上面的密钥和CSR对证书签名</span><br><span class="hljs-string">openssl x509 -req -days 365 -in domain.csr -signkey domain.key -out domain.crt</span><br><span class="hljs-string">最后将crt文件与key文件放入nginx配置文件中去</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rsync</title>
    <link href="/2021/12/23/rsync_hexo/"/>
    <url>/2021/12/23/rsync_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-rsync简介"><a href="#1-rsync简介" class="headerlink" title="1.rsync简介"></a>1.rsync简介</h1><p>rysnc是一种备份工具。支持增量备份和差异备份。rsync有三种备份方式，第一种是本地备份类似与cp命令，第二种是远程备份，类似与scp，使用的是ssh传输通道（需要进行ssh身份验证）。第三种是守护进程模式，需要有一台linux主机作为服务器监听端口，其他主要通过服务器的ip和端口进行访问（备份）操作</p><h1 id="2-rsync用法"><a href="#2-rsync用法" class="headerlink" title="2.rsync用法"></a>2.rsync用法</h1><h2 id="2-1选项"><a href="#2-1选项" class="headerlink" title="2.1选项"></a>2.1选项</h2><p>rsync有许多选项：</p><p>-n: 在不确定命令是否能按意愿执行时，务必要事先测试；-n可以完成此功能；<br>-v: –verbose，详细输出模式<br>-q: –quiet，静默模式<br>-c: –checksum，开启校验功能，强制对文件传输进行校验<br>-r: –recursive，递归复制；<br>-a: –archives，归档，保留文件的原有属性<br>-p: –perms 保留文件的权限<br>-t: –times 保留文件的时间戳<br>-l: –links 保留文件的符号链接<br>-g: –group 保留文件的属组<br>-o: –owner 保留文件的属主<br>-D： –devices 保留设备文件<br>-H, –hard-links 保留硬链结;<br>-S, –sparse 对稀疏文件进行特殊处理以节省DST的 空间;<br>-e ssh: 表示使用ssh协议作承载<br>-z: 对文件压缩后传输<br>–progress：显示进度条<br>–stats: 显示如何执行压缩和传输<br>–delete：删除那些DST中有而SRC没有的文件，即删除DST中多余的文件</p><h2 id="2-2命令格式"><a href="#2-2命令格式" class="headerlink" title="2.2命令格式"></a>2.2命令格式</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Local:  rsync <span class="hljs-comment">[OPTION...]</span> SRC... <span class="hljs-comment">[DEST]</span><br> <br>Access via remote shell:<br>  Pull: rsync <span class="hljs-comment">[OPTION...]</span> <span class="hljs-comment">[USER@]</span>HOST:SRC... <span class="hljs-comment">[DEST]</span><br>  Push: rsync <span class="hljs-comment">[OPTION...]</span> SRC... <span class="hljs-comment">[USER@]</span>HOST:DEST<br> <br>Access via rsync daemon:<br>  Pull: rsync <span class="hljs-comment">[OPTION...]</span> <span class="hljs-comment">[USER@]</span>HOST::SRC... <span class="hljs-comment">[DEST]</span><br>        rsync <span class="hljs-comment">[OPTION...]</span> rsync://<span class="hljs-comment">[USER@]</span>HOST<span class="hljs-comment">[:PORT]</span>/SRC... <span class="hljs-comment">[DEST]</span><br>  Push: rsync <span class="hljs-comment">[OPTION...]</span> SRC... <span class="hljs-comment">[USER@]</span>HOST::DEST<br>        rsync <span class="hljs-comment">[OPTION...]</span> SRC... rsync://<span class="hljs-comment">[USER@]</span>HOST<span class="hljs-comment">[:PORT]</span>/DEST<br></code></pre></td></tr></table></figure><p>由此语法可知，rsync有三种工作方式：</p><p>(1).本地文件系统上实现同步。命令行语法格式为上述”Local”段的格式。</p><p>(2).本地主机使用远程shell和远程主机通信。命令行语法格式为上述”Access via remote shell”段的格式。</p><p>(3).本地主机通过网络套接字连接远程主机上的rsync daemon。命令行语法格式为上述”Access via rsync daemon”段的格式。</p><p>前两者的本质是通过管道通信，即使是远程shell。而方式(3)则是让远程主机上运行rsync服务，使其监听在一个端口上，等待客户端的连接。</p><h2 id="2-3-配置文件"><a href="#2-3-配置文件" class="headerlink" title="2.3 配置文件"></a>2.3 配置文件</h2><p>rsync配置文件一般为/etc/rsyncd.conf:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle">fake <span class="hljs-keyword">super</span> = yes<br>uid = rsync<br>gid = rsync<br>use chroot = no<br>max connections = <span class="hljs-number">10</span><br>timeout = <span class="hljs-number">600</span><br>motd <span class="hljs-keyword">file</span> = <span class="hljs-regexp">/var/</span>rsyncd/rsyncd.moth<br>pid <span class="hljs-keyword">file</span> = <span class="hljs-regexp">/var/</span>rsyncd/rsync.pid<br>lock <span class="hljs-keyword">file</span> = <span class="hljs-regexp">/var/</span>run/rsync.lock<br>log <span class="hljs-keyword">file</span> = <span class="hljs-regexp">/var/</span>rsyncd/rsyncd.log<br>dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2<br>[backup]<br>path = /backup<br>igonre errors<br><span class="hljs-keyword">read</span> only = <span class="hljs-keyword">false</span><br><span class="hljs-keyword">write</span> only = <span class="hljs-keyword">false</span><br>list = <span class="hljs-keyword">false</span><br>auth users = rsyncd_backup<br>secrets <span class="hljs-keyword">file</span> = <span class="hljs-regexp">/etc/</span>rsyncd.passwd<br></code></pre></td></tr></table></figure><h3 id="rsyncd-conf配置文件常用参数说明"><a href="#rsyncd-conf配置文件常用参数说明" class="headerlink" title="rsyncd.conf配置文件常用参数说明"></a>rsyncd.conf配置文件常用参数说明</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> rsyncd.conf参数 </span>|<span class="hljs-string"> 参数说明 </span>|<br>|<span class="hljs-string"> - </span>|<span class="hljs-string"> - </span>|<br>|<span class="hljs-string"> uid=rsync </span>|<span class="hljs-string"> rsync使用的用户。 </span>|<br>|<span class="hljs-string"> gid=rsync </span>|<span class="hljs-string"> rsync使用的用户组（用户所在的组） </span>|<br>|<span class="hljs-string"> use chroot=no </span>|<span class="hljs-string"> 如果为true，daemon会在客户端传输文件前“chroot to the path”。这是一种安全配置，因为我们大多数都在内网，所以不配也没关系 </span>|<br>|<span class="hljs-string"> max connections=200 </span>|<span class="hljs-string"> 设置最大连接数，默认0，意思无限制，负值为关闭这个模块 </span>|<br>|<span class="hljs-string"> timeout=400 </span>|<span class="hljs-string"> 默认为0，表示no timeout，建议300-600（5-10分钟） </span>|<br>|<span class="hljs-string"> pid file </span>|<span class="hljs-string"> rsync daemon启动后将其进程pid写入此文件。如果这个文件存在，rsync不会覆盖该文件，而是会终止 </span>|<br>|<span class="hljs-string"> lock file </span>|<span class="hljs-string"> 指定lock文件用来支持“max connections”参数，使得总连接数不会超过限制 </span>|<br>|<span class="hljs-string"> log file </span>|<span class="hljs-string"> 不设或者设置错误，rsync会使用rsyslog输出相关日志信息 </span>|<br>|<span class="hljs-string"> ignore errors </span>|<span class="hljs-string"> 忽略I/O错误 </span>|<br>|<span class="hljs-string"> read only=false </span>|<span class="hljs-string"> 指定客户端是否可以上传文件，默认对所有模块为true </span>|<br>|<span class="hljs-string"> list=false </span>|<span class="hljs-string"> 是否允许客户端可以查看可用模块列表，默认为可以 </span>|<br>|<span class="hljs-string"> hosts allow </span>|<span class="hljs-string"> 指定可以联系的客户端主机名或和ip地址或地址段，默认情况没有此参数，即都可以连接 </span>|<br>|<span class="hljs-string"> hosts deny </span>|<span class="hljs-string"> 指定不可以联系的客户端主机名或ip地址或地址段，默认情况没有此参数，即都可以连接 </span>|<br>|<span class="hljs-string"> auth users </span>|<span class="hljs-string"> 指定以空格或逗号分隔的用户可以使用哪些模块，用户不需要在本地系统中存在。默认为所有用户无密码访问 </span>|<br>|<span class="hljs-string"> secrets file </span>|<span class="hljs-string"> 指定用户名和密码存放的文件，格式；用户名；密码，密码不超过8位 </span>|<br>|<span class="hljs-string"> [backup] </span>|<span class="hljs-string"> 这里就是模块名称，需用中括号扩起来，起名称没有特殊要求，但最好是有意义的名称，便于以后维护 </span>|<br>|<span class="hljs-string"> path </span>|<span class="hljs-string"> 这个模块中，daemon使用的文件系统或目录，目录的权限要注意和配置文件中的权限一致，否则会遇到读写的问题 </span>|<br></code></pre></td></tr></table></figure><h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3.实验"></a>3.实验</h1><h2 id="3-1-本地传输"><a href="#3-1-本地传输" class="headerlink" title="3.1 本地传输"></a>3.1 本地传输</h2><p>文件同步<br>rsync -avz /etc/fstab /data/<br>目录同步<br>rsync -avz /data /opt<br>data 后面加/表示将data下的内容同步过去 不加/表示将data目录同步过去</p><p>–delete 让目标目录与原目录数据同步</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032537.jpeg" alt="image.png"></p><h2 id="3-2远程传输"><a href="#3-2远程传输" class="headerlink" title="3.2远程传输"></a>3.2远程传输</h2><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032672.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032782.jpeg" alt="image.png"></p><p>备注：需要注意的是，远程传输方式使用的是ssh传输通道，ssh传输通道本身传输数据加密的，是安全的，但也有几个缺点：</p><p>1.用户权限问题<br>2.用户身份暴露（安全隐患）<br>3.文件路径暴露（安全隐患）</p><p>tcp传输过程，每传输一个数据都会有连接的建立，维护，断开过程。所以传输多个文件会比较慢</p><p>且两边都需要安装rsync程序。</p><p>第一次传输需要进行秘钥确定，且每次登陆需要输入密码，如不想输入密码，可生成秘钥并发送到远程主机。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032617.jpeg" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231034667.png" alt="image-20211123103427345"></p><p>使用ssh-keygen生成秘钥，并使用ssh-copy-id 发送至远程主机</p><p>此时传输数据便不会提示输入密码（ssh登陆亦是如此）</p><h2 id="3-3-守护进程方式"><a href="#3-3-守护进程方式" class="headerlink" title="3.3 守护进程方式"></a>3.3 守护进程方式</h2><p>守护进程方式需要一台机器作为server端，启动rsync deamon程序，监听端口，通过ip+socket来进行交互。</p><p>1.rpm -ql rsync查看rsync是否有安装（有的rsync把rsync与rsync-deamon分开，需要注意下）</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231034944.jpeg" alt="image.png"></p><p>如果没有的话则需要安装</p><p>yum -y install rsync-deamon rsync</p><p>2.编辑配置文件</p><p>vim /etc/rsyncd.conf<br>3.创建程序用户<br>useradd -M -s /sbin/nologin rsync<br>chown -R rsync.rsync /backup<br>4.创建目录<br>mkdir /backup &amp;&amp; chown -R rsync.rsync /backup<br>5.创建虚拟用户认证文件<br>echo “rsync_backup:1” &gt; /etc/rsync.password<br>chmod 600 rsync.password<br>6.启动守护进程<br>systemctl start rsyncd</p><p>使用rsync带上参数–password-file=xxx指定密码文件可以免输入密码</p><p>首先 echo 123456 &gt;　/etc/rsync_password; chmod 600 /etc/rsync_password</p><p>然后 rsync -avz xxx <a href="mailto:rsyncd_backup@192.168.1.1">rsyncd_backup@192.168.1.1</a>::bakcup –password-file=/etc/rsync_password</p><p>或者设置环境变量：</p><p>export RSYNC_PASSWORD =123456</p><p>这样不用跟上参数也可以免密码传输</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vmware问题及解决方法</title>
    <link href="/2021/12/23/vmware%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95_hexo/"/>
    <url>/2021/12/23/vmware%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="ovf导入到vsphere-client失败"><a href="#ovf导入到vsphere-client失败" class="headerlink" title="ovf导入到vsphere client失败"></a>ovf导入到vsphere client失败</h1><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049312.jpeg" alt="image.png"></p><h2 id="具体问题："><a href="#具体问题：" class="headerlink" title="具体问题："></a>具体问题：</h2><p>导入镜像到客户方的服务器，客户方使用的是esxi，然后这台计算机通过vsphereclient连接到server的，需要将已经准备好的ova导入到客户方，但在ovf部署时出现该报错。</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>这个问题是说OVF文件的hash值，与.mf文件中记录的hash值不同导致。解决方法简单，可以重新生成OVF文件的hash(256)值，也可以直接把.mf文件删掉。</p><p>直接删除掉.mf文件即可，如为.ova文件则改名为.rar，解压以后将其中的.mf删掉然后导入其中的.ovf文件。</p><h2 id="其他报错："><a href="#其他报错：" class="headerlink" title="其他报错："></a>其他报错：</h2><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231050340.jpeg" alt="image.png"></p><p>这个错误的意思是说，用VWware导出的OVF文件中，有些功能设置在vSphere中无法找到，即功能模块不兼容的情况。这时就需要修改OVF文件，把用不上的功能设置点去掉。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049355.jpeg" alt="image.png"></p><p>打开ovf文件，找到vmx-16的system项设置，这里意思是vmx输出的ovf模板兼容类型是16版本，而vSphere不支持这么高版本，所以只要把它降低就行了。由于不知道服务器上部署的是什么版本，所以这里可以逐个降低进行尝试，直到可以为止。我的最高兼容11版本。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049410.jpeg" alt="image.png"></p><p>修改之后就可以了：</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231050117.jpeg" alt="image.png"></p><p>然后一路向下，根据提示进行部署。</p><p>然后又出现一个设备配置无效的错误；</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049322.jpeg" alt="image.png"></p><p>这个错误的意思是说，用VWware导出的OVF文件中，有些功能设置在vSphere中无法找到，即功能模块不兼容的情况。这时就需要修改OVF文件，把用不上的功能设置点去掉。</p><p>这里要注意一个点，就是仅靠这个错误提示：设备“0”的配置无效，是无法确切定位到哪个功能在vSphere中是不受支持的，所以还是要逐个尝试，直到找到为止。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049694.jpeg" alt="image.png"></p><p>ovf里面的每个item都是一个功能点配置信息，逐个删除、恢复进行尝试，我这里是这一项配置不兼容。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049720.jpeg" alt="image.png"></p><p>直接删掉，再导入，就成功了。</p><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049641.jpeg" alt="image.png"></p><h1 id="FTP上传或下载文件提示错误：421-Data-timeout-Reconnect-Sorry的解决方法"><a href="#FTP上传或下载文件提示错误：421-Data-timeout-Reconnect-Sorry的解决方法" class="headerlink" title="FTP上传或下载文件提示错误：421 Data timeout. Reconnect. Sorry的解决方法"></a>FTP上传或下载文件提示错误：421 Data timeout. Reconnect. Sorry的解决方法</h1><p>data_connection_timeout，网上是这样解释这个参数的：数据连接后数据连接等待的空闲时间超时，超过时间后，数据连接将断开连接；我发现这个参数在vsftpd安装之后的默认值是1，也就是说，在数据连接后数据连接等待空闲时间超过1秒后，数据连接将断开，那么看来可能就是这个问题导致的，我将参数值改为10之后，发现文件传输马上正常了。</p><p>总结：ftp传输文件错误“421 Data timeout. Reconnect”，代表数据连接超时，连接被服务器强制断开了，只要我们找到vsftpd.conf文件，将文件里面的data_connection_timeout参数值改大一点的就可以解决问题了，特别是当我们网络环境不好的时候特别容易出现这个问题。</p><h1 id="windows-VMWARE虚拟机开机自启动设置"><a href="#windows-VMWARE虚拟机开机自启动设置" class="headerlink" title="windows VMWARE虚拟机开机自启动设置"></a>windows VMWARE虚拟机开机自启动设置</h1><p>在<strong>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</strong> 或 <strong>%programdata%\Microsoft\Windows\Start Menu\Programs\Startup</strong></p><p>里面写入start.bat(名字自定义，需设置为bat脚本执行文件)</p><p><strong>“C:\Program Files (x86)\VMware\VMware Workstation\vmware.exe” -X “C:\Users\93202\Documents\Virtual Machines\macOS 10.12\macOS 10.12.vmx”</strong></p><p>里面的内容指定其vmware位置和需要启动的虚拟机镜像位置</p><p>网上有很多用start参数启动的，但应该是版本问题，我用start测试都会失败，所以这里用-x</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>增加Swap分区</title>
    <link href="/2021/12/23/%E5%A2%9E%E5%8A%A0Swap%E5%88%86%E5%8C%BA_hexo/"/>
    <url>/2021/12/23/%E5%A2%9E%E5%8A%A0Swap%E5%88%86%E5%8C%BA_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="增加Swap分区"><a href="#增加Swap分区" class="headerlink" title="增加Swap分区"></a>增加Swap分区</h1><p>1.创建交换分区的文件:增加1G大小的交换分区，则命令写法如下，其中的 count 等于想要的块大小。</p><p>dd if=/dev/zero of=/home/swap bs=1M count=1024</p><p>2.设置交换分区文件:</p><p>mkswap /home/swap #建立swap的文件系统</p><p>3.立即启用交换分区文件:</p><p>swapon /home/swap #启用swap文件</p><p>4.使系统开机时自启用，在文件 /etc/fstab 中添加一行：<br>/home/swap swap swap defaults 0 0</p><p>三、修改 Swap 的使用优先级 swappiness</p><p>swappiness=0 表示最大限度使用物理内存，swappiness＝100 表示积极的使用swap分区，并且把内存上的数据及时的搬运到 swap。</p><p>cat /proc/sys/vm/swappiness #查看系统默认的 swappiness 值</p><p>sudo sysctl vm.swappiness=10 #修改swappiness值为10，临时性的修改，重启系统后会恢复默认值</p><p>sudo vi /etc/sysctl.conf</p><p>#在文档的最后加上这样一行（永久修改 swappiness）:<br>vm.swappiness = 10<br>\3. # sudo sysctl -p #使 /etc/sysctl.conf 的修改立即生效</p><p>推荐的 Swap 和 Ram 之间的大小关系</p><table><thead><tr><th>RAM</th><th>Swap Space</th></tr></thead><tbody><tr><td>Between 1024 MB and 2048 MB</td><td>1.5 times the size of RAM</td></tr><tr><td>Between 2049 MB and 8192 MB</td><td>Equal to the size of RAM</td></tr><tr><td>More than 8192 MB</td><td>0.75 times the size of RAM</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2021/11/18/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_hexo/"/>
    <url>/2021/11/18/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程本质上就是程序数据从硬盘中读取到内存中运行，从而形成一个进程。</p><h2 id="进程运行三种状态："><a href="#进程运行三种状态：" class="headerlink" title="进程运行三种状态："></a>进程运行三种状态：</h2><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhbmdoYW9kcmVhbQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>1、就绪状态。某些进程“万事俱备”(必要资源)，只差CPU。（就绪队列）      </p><p> 2、执行状态。某进程占有CPU并在CPU上执行其程序。      </p><p> 3、阻塞状态。某些进程由于某种原因不能继续运行下去，等待处 理问题。也称为等待状态或封锁状态。如：请求I/O。（多个等待队列）      </p><h3 id="进程状态转换的原因："><a href="#进程状态转换的原因：" class="headerlink" title="进程状态转换的原因："></a>进程状态转换的原因：</h3><p>1）就绪-→执行：</p><p>对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p><p>2）执行-→阻塞：</p><p>正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态。</p><p>如：进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；</p><p>3）阻塞-→就绪：</p><p>处于阻塞状态的进程，在其等待的事件已经完成，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p><p>4）执行-→就绪：</p><p>正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞是用来定义程序的运行状态：</p><p>​    阻塞:阻塞态<br>​            非阻塞:就绪态、运行态</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a><strong>同步和异步</strong></h3><p>正常情况下，一个进程运行首先进入就绪态，因一个cpu不能同时调度多个作业，所以需要排队等待进入运行态。进入运行态时，此时的进程正在被cpu调度运行。当进程进入i/o状态时，此时该进程就会从运行态变为阻塞态（系统此时会把cpu分给其他进程）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;&quot;&quot;描述的是任务的提交方式&quot;&quot;&quot;</span><br>同步:任务提交之后，原地等待任务的返回结果，等待的过程中不做任何事(干等)<br>  程序层面上表现出来的感觉就是卡住了<br><br>异步:任务提交之后，不原地等待任务的返回结果，直接去做其他事情<br>  我提交的任务结果如何获取？<br>    任务的返回结果会有一个异步回调机制自动处理<br></code></pre></td></tr></table></figure><h2 id="开启进程的两种方式"><a href="#开启进程的两种方式" class="headerlink" title="开启进程的两种方式"></a>开启进程的两种方式</h2><p>定心丸:代码开启进程和线程的方式，代码书写基本是一样的，你学会了如何开启进程就学会了如何开启线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s is running&#x27;</span>%name)<br>    time.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s is over&#x27;</span>%name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 1 创建一个对象</span><br>    p = Process(target=task, args=(<span class="hljs-string">&#x27;jason&#x27;</span>,))<br>    <span class="hljs-comment"># 容器类型哪怕里面只有1个元素 建议要用逗号隔开</span><br>    <span class="hljs-comment"># 2 开启进程</span><br>    p.start()  <span class="hljs-comment"># 告诉操作系统帮你创建一个进程  异步</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主&#x27;</span>)<br>    <br>    <br><span class="hljs-comment"># 第二种方式 类的继承</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcess</span>(<span class="hljs-params">Process</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello bf girl&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;get out!&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = MyProcess()<br>    p.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">创建进程就是在内存中申请一块内存空间将需要运行的代码丢进去</span><br><span class="hljs-string">一个进程对应在内存中就是一块独立的内存空间</span><br><span class="hljs-string">多个进程对应在内存中就是多块独立的内存空间</span><br><span class="hljs-string">进程与进程之间数据默认情况下是无法直接交互,如果想交互可以借助于第三方工具、模块</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>join是让主进程等待子进程代码运行结束之后，再继续运行。不影响其他子进程的执行</p><p>下面的代码当主进程P.start执行运行子进程代码后，主进程并不会等子进程运行完再往下运行，所以正常情况下程序输出‘主进程已经结束这句话不会再最后面’，如果想让主进程等待子进程执行完字节代码再往下执行就在再需要等待子进程执行完再执行的主代码前面加上join方法</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109103747341.png" alt="image-20211109103747341"></p><p>方法如下，此时主进程会等待子进程执行完再打印’主进程已经结束’。</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109104132647.png" alt="image-20211109104132647"></p><h2 id="管理进程pid"><a href="#管理进程pid" class="headerlink" title="管理进程pid"></a>管理进程pid</h2><p>​    方法: os.getpid,os.getppid,进程对象.terminate,进程对象.is_alive</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">一台计算机上面运行着很多进程，那么计算机是如何区分并管理这些进程服务端的呢？</span><br><span class="hljs-string">计算机会给每一个运行的进程分配一个PID号 </span><br><span class="hljs-string">如何查看</span><br><span class="hljs-string">windows电脑 </span><br><span class="hljs-string">进入cmd输入tasklist即可查看</span><br><span class="hljs-string">tasklist |findstr PID查看具体的进程</span><br><span class="hljs-string">mac电脑 </span><br><span class="hljs-string">进入终端之后输入ps aux</span><br><span class="hljs-string">ps aux|grep PID查看具体的进程 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, current_process<br>current_process().pid  <span class="hljs-comment"># 查看当前进程的进程号</span><br><br><span class="hljs-keyword">import</span> os<br>os.getpid()  <span class="hljs-comment"># 查看当前进程进程号</span><br>os.getppid()  <span class="hljs-comment"># 查看当前进程的父进程进程号</span><br><br><br>p.terminate()  <span class="hljs-comment"># 杀死当前进程</span><br><span class="hljs-comment"># 是告诉操作系统帮你去杀死当前进程 但是需要一定的时间 而代码的运行速度极快</span><br>time.sleep(<span class="hljs-number">0.1</span>)<br><span class="hljs-built_in">print</span>(p.is_alive())  <span class="hljs-comment"># 判断当前进程是否存活</span><br></code></pre></td></tr></table></figure><h3 id="僵尸进程与孤儿进程-了解"><a href="#僵尸进程与孤儿进程-了解" class="headerlink" title="僵尸进程与孤儿进程(了解)"></a>僵尸进程与孤儿进程(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 僵尸进程</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">死了但是没有死透</span><br><span class="hljs-string">当你开设了子进程之后 该进程死后不会立刻释放占用的进程号</span><br><span class="hljs-string">因为我要让父进程能够查看到它开设的子进程的一些基本信息 占用的pid号 运行时间。。。</span><br><span class="hljs-string">所有的进程都会步入僵尸进程</span><br><span class="hljs-string">父进程不死并且在无限制的创建子进程并且子进程也不结束</span><br><span class="hljs-string">回收子进程占用的pid号</span><br><span class="hljs-string">父进程等待子进程运行结束</span><br><span class="hljs-string">父进程调用join方法</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 孤儿进程</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">子进程存活，父进程意外死亡</span><br><span class="hljs-string">操作系统会开设一个“儿童福利院”专门管理孤儿进程回收相关资源</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>在python中，当子进程设置守护进程以后，如果主进程结束，此时子进程也会立即结束，主进程不会在等待子进程运行完毕。这里设置守护进程必须在子进程启动以前设置，否则报错。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> multiprocessing import Process<br>import time<br><br>def ceshi():<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;子进程正在运行&#x27;</span>)<br>time.sleep(3)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;子进程已经结束&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>P = Process(<span class="hljs-attribute">target</span>=ceshi,)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;主进程正在运行&#x27;</span>)<br>P.daemon = <span class="hljs-literal">True</span><br>P.start()<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;主进程已经结束&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111009514.png" alt="image-20211109111009514"></p><p>这里甚至子进程都没有运行出来就结束了（主进程运行速度太快了，子进程刚创建还没来得及运行，主进程就结束了，并直接结束了子进程。）</p><p>如果这里主进程sleep1秒的话，则子进程就开始运行了。</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111117503.png" alt="image-20211109111117503"></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>多个进程操作同一份数据的时候，会出现数据错乱的问题</p><p>针对上述问题，解决方式就是加锁处理:<strong>将并发变成串行，牺牲效率但是保证了数据的安全</strong></p><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">from</span> multiprocessing import Process<br>def write(<span class="hljs-selector-tag">i</span>):<br>with <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) as f:<br>f.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">str</span>(i))<br>def <span class="hljs-built_in">read</span>():<br>with <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) as f:<br>i=f.<span class="hljs-built_in">read</span>()<br>return i<br>#定义读和写两个函数<br>def <span class="hljs-built_in">ceshi</span>():<br>i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">read</span>())<br>if i == <span class="hljs-number">1</span>:<br>i -= <span class="hljs-number">1</span><br><span class="hljs-built_in">write</span>(i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试1判断i=1，则将i-1&#x27;</span>)<br><br>def <span class="hljs-built_in">ceshi2</span>():<br>i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">read</span>())<br>if i == <span class="hljs-number">1</span>:<br>i -= <span class="hljs-number">1</span><br><span class="hljs-built_in">write</span>(i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试2判断i=1，则将i-1&#x27;</span>)<br><br>#两个测试函数分别判断i是否等于<span class="hljs-number">1</span>，如果为<span class="hljs-number">1</span>则修改<br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>i=<span class="hljs-number">1</span><br><span class="hljs-built_in">write</span>(i)<br>#读取文件时先将<span class="hljs-number">1</span>设置为<span class="hljs-number">1</span><br>P = <span class="hljs-built_in">Process</span>(target=ceshi,)<br>P2 = <span class="hljs-built_in">Process</span>(target=ceshi2,)<br>P.<span class="hljs-built_in">start</span>()<br>P2.<span class="hljs-built_in">start</span>()<br>P.<span class="hljs-built_in">join</span>()<br>P2.<span class="hljs-built_in">join</span>()<br>i = <span class="hljs-built_in">read</span>() #等两个文件操作完再读取文件<br><span class="hljs-built_in">print</span>(f<span class="hljs-string">&#x27;主进程已经结束,i的值为&#123;i&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>两个子进程运行时，都会读取判断文件ceshi.txt里面的值是否为1，如果某一个文件先读取，那么只有一个文件能修改到值，那程序无任何问题，但当两个子进程同时读取文件时，就会出现两个进程都判断其值为1且对其进行修改值操作，显然对于程序来说，不应如此。例如火车抢票，此时票数为1，抢到票时火车的票就-1，如果两个人都同时抢票发现这个时候票为1，于是就都会抢票成功，显然这是一个bug，此时应该在上面加上锁。</p><p><strong>改为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process,Lock<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">i</span>):</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>f.write(<span class="hljs-built_in">str</span>(i))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>():</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ceshi.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>i=f.read()<br><span class="hljs-keyword">return</span> i<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ceshi</span>(<span class="hljs-params">lock</span>):</span><br>l=run(lock)<br><span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试1判断i=1，则将i-1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ceshi2</span>(<span class="hljs-params">lock</span>):</span><br>l=run(lock)<br><span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试2判断i=1，则将i-1&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">lock</span>):</span><br>lock.acquire()<br>i = <span class="hljs-built_in">int</span>(read())<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>i -= <span class="hljs-number">1</span><br>write(i)<br>lock.release()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>i=<span class="hljs-number">1</span><br>write(i)<br>lock = Lock()<br>P = Process(target=ceshi,args=(lock,))<br>P2 = Process(target=ceshi2,args=(lock,))<br>P.start()<br>P2.start()<br>P.join()<br>P2.join()<br>i = read()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;主进程已经结束,i的值为<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>从run函数可以看到，此时读和写都从并发改为串行了，此时只能一个一个读然后再写，真正再项目环境可以把读写分开，以免一个人在读数据时其他人都要等着，应该是一个人在写数据时再上锁。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h4 id="队列Queue模块"><a href="#队列Queue模块" class="headerlink" title="队列Queue模块"></a>队列Queue模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">管道:subprocess </span><br><span class="hljs-string">stdin stdout stderr</span><br><span class="hljs-string">队列:管道+锁</span><br><span class="hljs-string"></span><br><span class="hljs-string">队列:先进先出</span><br><span class="hljs-string">堆栈:先进后出</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Queue<br><br><span class="hljs-comment"># 创建一个队列</span><br>q = Queue(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 括号内可以传数字 标示生成的队列最大可以同时存放的数据量</span><br><br><span class="hljs-comment"># 往队列中存数据</span><br>q.put(<span class="hljs-number">111</span>)<br>q.put(<span class="hljs-number">222</span>)<br>q.put(<span class="hljs-number">333</span>)<br><span class="hljs-comment"># print(q.full())  # 判断当前队列是否满了</span><br><span class="hljs-comment"># print(q.empty())  # 判断当前队列是否空了</span><br>q.put(<span class="hljs-number">444</span>)<br>q.put(<span class="hljs-number">555</span>)<br><span class="hljs-comment"># print(q.full())  # 判断当前队列是否满了</span><br><br><span class="hljs-comment"># q.put(666)  # 当队列数据放满了之后 如果还有数据要放程序会阻塞 直到有位置让出来 不会报错</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">存取数据 存是为了更好的取</span><br><span class="hljs-string">千方百计的存、简单快捷的取</span><br><span class="hljs-string"></span><br><span class="hljs-string">同在一个屋檐下</span><br><span class="hljs-string">差距为何那么大</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 去队列中取数据</span><br>v1 = q.get()<br>v2 = q.get()<br>v3 = q.get()<br>v4 = q.get()<br>v5 = q.get()<br><span class="hljs-comment"># print(q.empty())</span><br><span class="hljs-comment"># V6 = q.get_nowait()  # 没有数据直接报错queue.Empty</span><br><span class="hljs-comment"># v6 = q.get(timeout=3)  # 没有数据之后原地等待三秒之后再报错  queue.Empty</span><br><span class="hljs-keyword">try</span>:<br>    v6 = q.get(timeout=<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(v6)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一滴都没有了!&#x27;</span>)<br><br><span class="hljs-comment"># # v6 = q.get()  # 队列中如果已经没有数据的话 get方法会原地阻塞</span><br><span class="hljs-comment"># print(v1, v2, v3, v4, v5, v6)</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">q.full()</span><br><span class="hljs-string">q.empty()</span><br><span class="hljs-string">q.get_nowait()</span><br><span class="hljs-string">在多进程的情况下是不精确</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Queue, Process<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">研究思路</span><br><span class="hljs-string">    1.主进程跟子进程借助于队列通信</span><br><span class="hljs-string">    2.子进程跟子进程借助于队列通信</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">q</span>):</span><br>    q.put(<span class="hljs-string">&#x27;我是23号技师 很高兴为您服务&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">q</span>):</span><br>    <span class="hljs-built_in">print</span>(q.get())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = Queue()<br>    p = Process(target=producer,args=(q,))<br>    p1 = Process(target=consumer,args=(q,))<br>    p.start()<br>    p1.start()<br></code></pre></td></tr></table></figure><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">生产者:生产/制造东西的</span><br><span class="hljs-string">消费者:消费/处理东西的</span><br><span class="hljs-string">该模型除了上述两个之外还需要一个媒介</span><br><span class="hljs-string">生活中的例子做包子的将包子做好后放在蒸笼(媒介)里面，买包子的取蒸笼里面拿</span><br><span class="hljs-string">厨师做菜做完之后用盘子装着给你消费者端过去</span><br><span class="hljs-string">生产者和消费者之间不是直接做交互的，而是借助于媒介做交互</span><br><span class="hljs-string"></span><br><span class="hljs-string">生产者(做包子的) + 消息队列(蒸笼) + 消费者(吃包子的)</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue, JoinableQueue<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">name,food,q</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        data = <span class="hljs-string">&#x27;%s生产了%s%s&#x27;</span>%(name,food,i)<br>        <span class="hljs-comment"># 模拟延迟</span><br>        time.sleep(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-comment"># 将数据放入 队列中</span><br>        q.put(data)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">name,q</span>):</span><br>    <span class="hljs-comment"># 消费者胃口很大 光盘行动</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        food = q.get()  <span class="hljs-comment"># 没有数据就会卡住</span><br>        <span class="hljs-comment"># 判断当前是否有结束的标识</span><br>        <span class="hljs-comment"># if food is None:break</span><br>        time.sleep(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s吃了%s&#x27;</span>%(name,food))<br>        q.task_done()  <span class="hljs-comment"># 告诉队列你已经从里面取出了一个数据并且处理完毕了</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># q = Queue()</span><br>    q = JoinableQueue()<br>    p1 = Process(target=producer,args=(<span class="hljs-string">&#x27;大厨egon&#x27;</span>,<span class="hljs-string">&#x27;包子&#x27;</span>,q))<br>    p2 = Process(target=producer,args=(<span class="hljs-string">&#x27;马叉虫tank&#x27;</span>,<span class="hljs-string">&#x27;泔水&#x27;</span>,q))<br>    c1 = Process(target=consumer,args=(<span class="hljs-string">&#x27;春哥&#x27;</span>,q))<br>    c2 = Process(target=consumer,args=(<span class="hljs-string">&#x27;新哥&#x27;</span>,q))<br>    p1.start()<br>    p2.start()<br>    <span class="hljs-comment"># 将消费者设置成守护进程</span><br>    c1.daemon = <span class="hljs-literal">True</span><br>    c2.daemon = <span class="hljs-literal">True</span><br>    c1.start()<br>    c2.start()<br>    p1.join()<br>    p2.join()<br>    <span class="hljs-comment"># 等待生产者生产完毕之后 往队列中添加特定的结束符号</span><br>    <span class="hljs-comment"># q.put(None)  # 肯定在所有生产者生产的数据的末尾</span><br>    <span class="hljs-comment"># q.put(None)  # 肯定在所有生产者生产的数据的末尾</span><br>    q.join()  <span class="hljs-comment"># 等待队列中所有的数据被取完再执行往下执行代码</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    JoinableQueue 每当你往该队列中存入数据的时候 内部会有一个计数器+1</span><br><span class="hljs-string">    没当你调用task_done的时候 计数器-1</span><br><span class="hljs-string">    q.join() 当计数器为0的时候 才往后运行</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 只要q.join执行完毕 说明消费者已经处理完数据了  消费者就没有存在的必要了</span><br><br></code></pre></td></tr></table></figure><h1 id="线程理论"><a href="#线程理论" class="headerlink" title="线程理论"></a>线程理论</h1><ul><li><p>什么是线程</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">进程:资源单位</span><br><span class="hljs-string">线程:执行单位</span><br><span class="hljs-string"></span><br><span class="hljs-string">将操作系统比喻成一个大的工厂</span><br><span class="hljs-string">那么进程就相当于工厂里面的车间</span><br><span class="hljs-string">而线程就是车间里面的流水线</span><br><span class="hljs-string"></span><br><span class="hljs-string">每一个进程肯定自带一个线程</span><br><span class="hljs-string"></span><br><span class="hljs-string">再次总结:</span><br><span class="hljs-string">进程:资源单位(起一个进程仅仅只是在内存空间中开辟一块独立的空间)</span><br><span class="hljs-string">线程:执行单位(真正被cpu执行的其实是进程里面的线程，线程指的就是代码的执行过程，执行代码中所需要使用到的资源都找所在的进程索要)</span><br><span class="hljs-string"></span><br><span class="hljs-string">进程和线程都是虚拟单位，只是为了我们更加方便的描述问题</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>为何要有线程</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">开设进程</span><br><span class="hljs-string">1.申请内存空间耗资源</span><br><span class="hljs-string">2.“拷贝代码”   耗资源</span><br><span class="hljs-string">开线程</span><br><span class="hljs-string">一个进程内可以开设多个线程，在用一个进程内开设多个线程无需再次申请内存空间操作</span><br><span class="hljs-string"></span><br><span class="hljs-string">总结:</span><br><span class="hljs-string">开设线程的开销要远远的小于进程的开销</span><br><span class="hljs-string">同一个进程下的多个线程数据是共享的!!!</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>我们要开发一款文本编辑器<br>获取用户输入的功能<br>  实时展示到屏幕的功能<br>  自动保存到硬盘的功能<br>针对上面这三个功能，开设进程还是线程合适？？？<br>开三个线程处理上面的三个功能更加的合理<br></code></pre></td></tr></table></figure></li><li><p>如何使用</p></li></ul><h2 id="开启线程的两种方式"><a href="#开启线程的两种方式" class="headerlink" title="开启线程的两种方式"></a>开启线程的两种方式</h2><h3 id="导入模块式"><a href="#导入模块式" class="headerlink" title="导入模块式"></a>导入模块式</h3><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211111094637428.png" alt="image-20211111094637428"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import Thread<br>duxiangming=<span class="hljs-constructor">Thread(<span class="hljs-params">target</span>=<span class="hljs-params">ceshi</span>,<span class="hljs-params">args</span>=(<span class="hljs-params">i</span>,)</span>)<br></code></pre></td></tr></table></figure><h3 id="集成类式"><a href="#集成类式" class="headerlink" title="集成类式"></a>集成类式</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-class"><span class="hljs-keyword">class</span> ceshi(<span class="hljs-type">Thread</span>):</span><br><span class="hljs-class">    def run(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        print(&#x27;<span class="hljs-title">g&#x27;</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">if __name__ == &#x27;__main__&#x27;:</span><br><span class="hljs-class">    for i in range(5):</span><br><span class="hljs-class">        cs = ceshi()</span><br><span class="hljs-class">        cs.start()</span><br></code></pre></td></tr></table></figure><h2 id="线程与进程区别"><a href="#线程与进程区别" class="headerlink" title="线程与进程区别"></a>线程与进程区别</h2><p>在使用方法上，例如join，互斥锁，join方法，queue消息队列都与进程一致。两者的区别在于线程无需开辟新的内存空间，进程的创建需要开启新的内存空间，因此线程相较于进程来讲，其创建的开销要小很多，但是由于cpython（python用的最多的解释器）的GIL解释器锁的原因，python线程无法实现真正的多线程（利用多核），只能单核使用，但由于其线程创建开销少，所以还是适用于密集型i/o程序，如果是密集型运算程序，还是需要使用多进程。</p><h3 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">python解释器其实有多个版本<br>Cpython<br>Jpython<br>Pypypython<br>但是普遍使用的都是CPython解释器<br><br>在CPython解释器中GIL是一把互斥锁，用来阻止同一个进程下的多个线程的同时执行<br>同一个进程下的多个线程无法利用多核优势！！！<br>疑问:python的多线程是不是一点用都没有？？？无法利用多核优势<br><br>因为cpython中的内存管理不是线程安全的<br>内存管理(垃圾回收机制)<br><span class="hljs-number">1</span>.应用计数<br><span class="hljs-number">2</span>.标记清楚<br><span class="hljs-number">3</span>.分代回收<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>重点:<br><span class="hljs-number">1</span>.GIL不是python的特点而是CPython解释器的特点<br><span class="hljs-number">2</span>.GIL是保证解释器级别的数据的安全<br><span class="hljs-number">3</span>.GIL会导致同一个进程下的多个线程的无法同时执行即无法利用多核优势(******)<br><span class="hljs-number">4</span>.针对不同的数据还是需要加不同的锁处理 <br><span class="hljs-number">5</span>.解释型语言的通病:同一个进程下多个线程无法利用多核优势<br></code></pre></td></tr></table></figure><h3 id="GIL与普通互斥锁的区别"><a href="#GIL与普通互斥锁的区别" class="headerlink" title="GIL与普通互斥锁的区别"></a>GIL与普通互斥锁的区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread,Lock<br><span class="hljs-keyword">import</span> time<br><br><br>mutex = Lock()<br>money = <span class="hljs-number">100</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>():</span><br>    <span class="hljs-keyword">global</span> money<br>    <span class="hljs-comment"># with mutex:</span><br>    <span class="hljs-comment">#     tmp = money</span><br>    <span class="hljs-comment">#     time.sleep(0.1)</span><br>    <span class="hljs-comment">#     money = tmp -1</span><br>    mutex.acquire()<br>    tmp = money<br>    time.sleep(<span class="hljs-number">0.1</span>)  <span class="hljs-comment"># 只要你进入IO了 GIL会自动释放</span><br>    money = tmp - <span class="hljs-number">1</span><br>    mutex.release()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        t = Thread(target=task)<br>        t.start()<br>        t_list.append(t)<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> t_list:<br>        t.join()<br>    <span class="hljs-built_in">print</span>(money)<br><br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">100个线程起起来之后  要先去抢GIL</span><br><span class="hljs-string">我进入io GIL自动释放 但是我手上还有一个自己的互斥锁</span><br><span class="hljs-string">其他线程虽然抢到了GIL但是抢不到互斥锁 </span><br><span class="hljs-string">最终GIL还是回到你的手上 你去操作数据</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="进程池与线程池"><a href="#进程池与线程池" class="headerlink" title="进程池与线程池"></a>进程池与线程池</h3><p>先回顾之前TCP服务端实现并发的效果是怎么玩的</p><p>每来一个人就开设一个进程或者线程去处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">无论是开设进程也好还是开设线程也好 是不是都需要消耗资源</span><br><span class="hljs-string">只不过开设线程的消耗比开设进程的稍微小一点而已</span><br><span class="hljs-string"></span><br><span class="hljs-string">我们是不可能做到无限制的开设进程和线程的 因为计算机硬件的资源更不上！！！</span><br><span class="hljs-string">硬件的开发速度远远赶不上软件呐</span><br><span class="hljs-string"></span><br><span class="hljs-string">我们的宗旨应该是在保证计算机硬件能够正常工作的情况下最大限度的利用它</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 池的概念</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">什么是池?</span><br><span class="hljs-string">池是用来保证计算机硬件安全的情况下最大限度的利用计算机</span><br><span class="hljs-string">它降低了程序的运行效率但是保证了计算机硬件的安全 从而让你写的程序能够正常运行</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-comment"># pool = ThreadPoolExecutor(5)  # 池子里面固定只有五个线程</span><br><span class="hljs-comment"># 括号内可以传数字 不传的话默认会开设当前计算机cpu个数五倍的线程</span><br>pool = ProcessPoolExecutor(<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 括号内可以传数字 不传的话默认会开设当前计算机cpu个数进程</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">池子造出来之后 里面会固定存在五个线程</span><br><span class="hljs-string">这个五个线程不会出现重复创建和销毁的过程</span><br><span class="hljs-string">池子造出来之后 里面会固定的几个进程</span><br><span class="hljs-string">这个几个进程不会出现重复创建和销毁的过程</span><br><span class="hljs-string"></span><br><span class="hljs-string">池子的使用非常的简单</span><br><span class="hljs-string">你只需要将需要做的任务往池子中提交即可 自动会有人来服务你</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">print</span>(n,os.getpid())<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> n**n<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_back</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call_back&gt;&gt;&gt;:&#x27;</span>,n.result())<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">任务的提交方式</span><br><span class="hljs-string">    同步:提交任务之后原地等待任务的返回结果 期间不做任何事</span><br><span class="hljs-string">    异步:提交任务之后不等待任务的返回结果 执行继续往下执行</span><br><span class="hljs-string">        返回结果如何获取？？？</span><br><span class="hljs-string">        异步提交任务的返回结果 应该通过回调机制来获取</span><br><span class="hljs-string">        回调机制</span><br><span class="hljs-string">            就相当于给每个异步任务绑定了一个定时炸弹</span><br><span class="hljs-string">            一旦该任务有结果立刻触发爆炸</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># pool.submit(task, 1)  # 朝池子中提交任务  异步提交</span><br>    <span class="hljs-comment"># print(&#x27;主&#x27;)</span><br>    t_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <span class="hljs-comment"># 朝池子中提交20个任务</span><br>        <span class="hljs-comment"># res = pool.submit(task, i)  # &lt;Future at 0x100f97b38 state=running&gt;</span><br>        res = pool.submit(task, i).add_done_callback(call_back)<br>        <span class="hljs-comment"># print(res.result())  # result方法   同步提交</span><br>        <span class="hljs-comment"># t_list.append(res)</span><br>    <span class="hljs-comment"># 等待线程池中所有的任务执行完毕之后再继续往下执行</span><br>    <span class="hljs-comment"># pool.shutdown()  # 关闭线程池  等待线程池中所有的任务运行完毕</span><br>    <span class="hljs-comment"># for t in t_list:</span><br>    <span class="hljs-comment">#     print(&#x27;&gt;&gt;&gt;:&#x27;,t.result())  # 肯定是有序的</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">程序有并发变成了串行</span><br><span class="hljs-string">任务的为什么打印的是None</span><br><span class="hljs-string">res.result() 拿到的就是异步提交的任务的返回结果</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor<br>pool = ProcessPoolExecutor(<span class="hljs-number">5</span>)<br>pool.submit(task, i).add_done_callback(call_back)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型</title>
    <link href="/2021/11/18/IO%E6%A8%A1%E5%9E%8B_hexo/"/>
    <url>/2021/11/18/IO%E6%A8%A1%E5%9E%8B_hexo/</url>
    
    <content type="html"><![CDATA[<h3 id="IO模型简介"><a href="#IO模型简介" class="headerlink" title="IO模型简介"></a>IO模型简介</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">我们这里研究的IO模型都是针对网络IO的</span><br><span class="hljs-string">Stevens在文章中一共比较了五种IO Model：</span><br><span class="hljs-string">    * blocking IO           阻塞IO</span><br><span class="hljs-string">    * nonblocking IO      非阻塞IO</span><br><span class="hljs-string">    * IO multiplexing      IO多路复用</span><br><span class="hljs-string">    * signal driven IO     信号驱动IO</span><br><span class="hljs-string">    * asynchronous IO    异步IO</span><br><span class="hljs-string">    由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">#1）等待数据准备 (Waiting for the data to be ready)</span><br><span class="hljs-comment">#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</span><br><br>同步异步<br>阻塞非阻塞<br>常见的网络阻塞状态:<br>  accept<br>    recv<br>    recvfrom<br>    <br>    send虽然它也有io行为 但是不在我们的考虑范围<br></code></pre></td></tr></table></figure><h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>最广泛的模型是阻塞I/O模型，默认情况下，所有套接口都是阻塞的。 进程调用recvfrom系统调用，整个过程是阻塞的，直到数据复制到进程缓冲区时才返回（当然，系统调用被中断也会返回）。</p><p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110813568-874888915.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">我们之前写的都是阻塞IO模型  协程除外</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> socket<br><br><br>server = socket.socket()<br>server.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>))<br>server.listen(<span class="hljs-number">5</span>)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    conn, addr = server.accept()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            data = conn.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<span class="hljs-keyword">break</span><br>            <span class="hljs-built_in">print</span>(data)<br>            conn.send(data.upper())<br>        <span class="hljs-keyword">except</span> ConnectionResetError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">break</span><br>    conn.close()<br>    <br><span class="hljs-comment"># 在服务端开设多进程或者多线程 进程池线程池 其实还是没有解决IO问题</span><br>该等的地方还是得等 没有规避<br>只不过多个人等待的彼此互不干扰<br></code></pre></td></tr></table></figure><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>当我们把一个套接口设置为非阻塞时，就是在告诉内核，当请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。当数据没有准备好时，内核立即返回EWOULDBLOCK错误，第四次调用系统调用时，数据已经存在，这时将数据复制到进程缓冲区中。这其中有一个操作时轮询（polling）。</p><p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110823926-1104935376.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">要自己实现一个非阻塞IO模型</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> time<br><br><br>server = socket.socket()<br>server.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8081</span>))<br>server.listen(<span class="hljs-number">5</span>)<br>server.setblocking(<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 将所有的网络阻塞变为非阻塞</span><br>r_list = []<br>del_list = []<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        conn, addr = server.accept()<br>        r_list.append(conn)<br>    <span class="hljs-keyword">except</span> BlockingIOError:<br>        <span class="hljs-comment"># time.sleep(0.1)</span><br>        <span class="hljs-comment"># print(&#x27;列表的长度:&#x27;,len(r_list))</span><br>        <span class="hljs-comment"># print(&#x27;做其他事&#x27;)</span><br>        <span class="hljs-keyword">for</span> conn <span class="hljs-keyword">in</span> r_list:<br>            <span class="hljs-keyword">try</span>:<br>                data = conn.recv(<span class="hljs-number">1024</span>)  <span class="hljs-comment"># 没有消息 报错</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 客户端断开链接</span><br>                    conn.close()  <span class="hljs-comment"># 关闭conn</span><br>                    <span class="hljs-comment"># 将无用的conn从r_list删除</span><br>                    del_list.append(conn)<br>                    <span class="hljs-keyword">continue</span><br>                conn.send(data.upper())<br>            <span class="hljs-keyword">except</span> BlockingIOError:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">except</span> ConnectionResetError:<br>                conn.close()<br>                del_list.append(conn)<br>        <span class="hljs-comment"># 挥手无用的链接</span><br>        <span class="hljs-keyword">for</span> conn <span class="hljs-keyword">in</span> del_list:<br>            r_list.remove(conn)<br>        del_list.clear()<br><br><span class="hljs-comment"># 客户端</span><br><span class="hljs-keyword">import</span> socket<br><br><br>client = socket.socket()<br>client.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8081</span>))<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    client.send(<span class="hljs-string">b&#x27;hello world&#x27;</span>)<br>    data = client.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">虽然非阻塞IO给你的感觉非常的牛逼</span><br><span class="hljs-string">但是该模型会长时间占用着CPU并且不干活 让CPU不停的空转</span><br><span class="hljs-string">我们实际应用中也不会考虑使用非阻塞IO模型</span><br><span class="hljs-string"></span><br><span class="hljs-string">任何的技术点都有它存在的意义 </span><br><span class="hljs-string">实际应用或者是思想借鉴</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>此模型用到select和poll函数，这两个函数也会使进程阻塞，select先阻塞，有活动套接字才返回，但是和阻塞I/O不同的是，<strong>这两个函数可以同时阻塞多个I/O操作</strong>，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写（<strong>就是监听多个socket</strong>）。select被调用后，进程会被阻塞，内核监视所有select负责的socket，当有任何一个socket的数据准备好了，select就会返回套接字可读，我们就可以调用recvfrom处理数据。<br><strong>正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用。</strong></p><p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110830667-163640114.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">当监管的对象只有一个的时候 其实IO多路复用连阻塞IO都比比不上！！！</span><br><span class="hljs-string">但是IO多路复用可以一次性监管很多个对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">server = socket.socket()</span><br><span class="hljs-string">conn,addr = server.accept()</span><br><span class="hljs-string"></span><br><span class="hljs-string">监管机制是操作系统本身就有的 如果你想要用该监管机制(select)</span><br><span class="hljs-string">需要你导入对应的select模块</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> select<br><br><br>server = socket.socket()<br>server.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>))<br>server.listen(<span class="hljs-number">5</span>)<br>server.setblocking(<span class="hljs-literal">False</span>)<br>read_list = [server]<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r_list, w_list, x_list = select.select(read_list, [], [])<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    帮你监管</span><br><span class="hljs-string">    一旦有人来了 立刻给你返回对应的监管对象</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># print(res)  # ([&lt;socket.socket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;127.0.0.1&#x27;, 8080)&gt;], [], [])</span><br>    <span class="hljs-comment"># print(server)</span><br>    <span class="hljs-comment"># print(r_list)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> r_list:  <span class="hljs-comment">#</span><br>        <span class="hljs-string">&quot;&quot;&quot;针对不同的对象做不同的处理&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">is</span> server:<br>            conn, addr = i.accept()<br>            <span class="hljs-comment"># 也应该添加到监管的队列中</span><br>            read_list.append(conn)<br>        <span class="hljs-keyword">else</span>:<br>            res = i.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:<br>                i.close()<br>                <span class="hljs-comment"># 将无效的监管对象 移除</span><br>                read_list.remove(i)<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-built_in">print</span>(res)<br>            i.send(<span class="hljs-string">b&#x27;heiheiheiheihei&#x27;</span>)<br><br> <span class="hljs-comment"># 客户端</span><br><span class="hljs-keyword">import</span> socket<br><br><br>client = socket.socket()<br>client.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>))<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>    client.send(<span class="hljs-string">b&#x27;hello world&#x27;</span>)<br>    data = client.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">监管机制其实有很多</span><br><span class="hljs-string">select机制  windows linux都有</span><br><span class="hljs-string"></span><br><span class="hljs-string">poll机制    只在linux有   poll和select都可以监管多个对象 但是poll监管的数量更多</span><br><span class="hljs-string"></span><br><span class="hljs-string">上述select和poll机制其实都不是很完美 当监管的对象特别多的时候</span><br><span class="hljs-string">可能会出现 极其大的延时响应</span><br><span class="hljs-string"></span><br><span class="hljs-string">epoll机制   只在linux有</span><br><span class="hljs-string">它给每一个监管对象都绑定一个回调机制</span><br><span class="hljs-string">一旦有响应 回调机制立刻发起提醒</span><br><span class="hljs-string"></span><br><span class="hljs-string">针对不同的操作系统还需要考虑不同检测机制 书写代码太多繁琐</span><br><span class="hljs-string">有一个人能够根据你跑的平台的不同自动帮你选择对应的监管机制</span><br><span class="hljs-string">selectors模块</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h3><p>　　首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。</p><p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110837225-1379057547.png" alt="img"></p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>　　这个模型工作机制是：告诉内核启动某个操作，并让内核在整个操作(包括第二阶段，即将数据从内核拷贝到进程缓冲区中)完成后通知我们。</p><p>这种模型和前一种模型区别在于：信号驱动I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。</p><p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110843727-154944469.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">异步IO模型是所有模型中效率最高的 也是使用最广泛的</span><br><span class="hljs-string">相关的模块和框架</span><br><span class="hljs-string">模块:asyncio模块</span><br><span class="hljs-string">异步框架:sanic tronado twisted</span><br><span class="hljs-string">速度快！！！</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-meta">@asyncio.coroutine</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world %s&#x27;</span>%threading.current_thread())<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> asyncio.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 换成真正的IO操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world %s&#x27;</span> % threading.current_thread())<br><br><br>loop = asyncio.get_event_loop()<br>tasks = [hello(),hello()]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()<br></code></pre></td></tr></table></figure><p><strong>高性能IO模型浅析</strong> </p><p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：</p><p>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。</p><p>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非<a href="http://lib.csdn.net/base/javase">Java</a>的NIO（New IO）库。</p><p>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，Java中的Selector和<a href="http://lib.csdn.net/base/linux">Linux</a>中的epoll都是这种模型。</p><p>（4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。 </p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql for python</title>
    <link href="/2021/11/18/mysql%20for%20python_hexo/"/>
    <url>/2021/11/18/mysql%20for%20python_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-for-python"><a href="#mysql-for-python" class="headerlink" title="mysql for python"></a>mysql for python</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>数据库是一种按照数据结构来组织、存储和管理数据的仓库，一般数据库软件均为C/S架构，目前数据库软件分为两种，关系型数据库与非关系型数据，常见的关系型数据库有：mysql(mariadb),oracle,pgsql等，非关系型数据库有mongodb,redis(也是消息队列)。</p><p>mysql是目前互联网公司中最常用的关系型数据库之一。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>日常生活中文件格式有很多中，并且针对不同的文件格式会有对应不同存储方式和处理机制(txt,pdf,word,mp4…)</p><p>针对不同的数据应该有对应的不同的处理机制来存储</p><p>存储引擎就是不同的处理机制</p><p><strong>MySQL主要存储引擎</strong></p><ul><li><p>Innodb</p><p>  是MySQL5.5版本及之后默认的存储引擎</p><p>  存储数据更加的安全</p></li><li><p>myisam</p><p>  是MySQL5.5版本之前默认的存储引擎</p><p>  速度要比Innodb更快 但是我们更加注重的是数据的安全</p></li><li><p>memory</p><p>  内存引擎(数据全部存放在内存中) 断电数据丢失</p></li><li><p>blackhole</p><p>  无论存什么，都立刻消失(黑洞)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># 查看所有的存储引擎</span><br><span class="hljs-string">show engines;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 不同的存储引擎在存储表的时候 异同点</span><br><span class="hljs-string">create table t1(id int) engine=innodb;</span><br><span class="hljs-string">create table t2(id int) engine=myisam;</span><br><span class="hljs-string">create table t3(id int) engine=blackhole;</span><br><span class="hljs-string">create table t4(id int) engine=memory;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 存数据</span><br><span class="hljs-string">insert into t1 values(1);</span><br><span class="hljs-string">insert into t2 values(1);</span><br><span class="hljs-string">insert into t3 values(1);</span><br><span class="hljs-string">insert into t4 values(1);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h3><p>DQL：数据查询语言，用于对数据进行查询，如select<br>        DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete<br>        TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback<br>        DCL：数据控制语言，进行授权与权限回收，如grant、revoke<br>        DDL：数据定义语言，进行数据库、表的管理等，如create、drop</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><ul><li><p>分类</p><p>  TINYINT SMALLINT MEDUIMINT INT BIGINT</p></li><li><p>作用</p><p>  存储年龄、等级、id、号码等等</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">以TINYINT </span><br><span class="hljs-string">是否有符号</span><br><span class="hljs-string">默认情况下是带符号的</span><br><span class="hljs-string">超出会如何</span><br><span class="hljs-string">超出限制只存最大可接受值</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table t9(<span class="hljs-built_in">id</span> tinyint);<br>insert into t9 values(-<span class="hljs-number">129</span>),(<span class="hljs-number">256</span>);<br><br><span class="hljs-comment"># 约束条件之unsigned 无符号</span><br>create table t10(<span class="hljs-built_in">id</span> tinyint unsigned);<br><br><br>create table t11(<span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>);<br><span class="hljs-comment"># int默认也是带符号的  </span><br><span class="hljs-comment"># 整型默认情况下都是带有符号的</span><br><br><span class="hljs-comment"># 针对整型 括号内的宽度到底是干嘛的</span><br>create table t12(<span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">8</span>));<br>insert into t12 values(<span class="hljs-number">123456789</span>);<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">特例:只有整型括号里面的数字不是表示限制位数</span><br><span class="hljs-string">id int(8)</span><br><span class="hljs-string">如果数字没有超出8位 那么默认用空格填充至8位</span><br><span class="hljs-string">如果数字超出了8位 那么有几位就存几位(但是还是要遵守最大范围)</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table t13(<span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">8</span>) unsigned zerofill);<br><span class="hljs-comment"># 用0填充至8位</span><br><br><span class="hljs-comment"># 总结:</span><br>针对整型字段 括号内无需指定宽度 因为它默认的宽度以及足够显示所有的数据了<br></code></pre></td></tr></table></figure><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul><li><p>分类</p><p>  FLOAT、DOUBLE、DECIMAL</p></li><li><p>作用</p><p>  身高、体重、薪资</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 存储限制</span><br><span class="hljs-built_in">float</span>(<span class="hljs-number">255</span>,<span class="hljs-number">30</span>)  <span class="hljs-comment"># 总共255位 小数部分占30位</span><br>double(<span class="hljs-number">255</span>,<span class="hljs-number">30</span>)  <span class="hljs-comment"># 总共255位 小数部分占30位</span><br>decimal(<span class="hljs-number">65</span>,<span class="hljs-number">30</span>)  <span class="hljs-comment"># 总共65位 小数部分占30位</span><br><br><span class="hljs-comment"># 精确度验证</span><br>create table t15(<span class="hljs-built_in">id</span> <span class="hljs-built_in">float</span>(<span class="hljs-number">255</span>,<span class="hljs-number">30</span>));<br>create table t16(<span class="hljs-built_in">id</span> double(<span class="hljs-number">255</span>,<span class="hljs-number">30</span>));<br>create table t17(<span class="hljs-built_in">id</span> decimal(<span class="hljs-number">65</span>,<span class="hljs-number">30</span>));<br><span class="hljs-string">&quot;&quot;&quot;你们在前期不要给我用反向键 所有的命令全部手敲！！！增加熟练度&quot;&quot;&quot;</span><br><br>insert into t15 values(<span class="hljs-number">1.111111111111111111111111111111</span>);<br>insert into t16 values(<span class="hljs-number">1.111111111111111111111111111111</span>);<br>insert into t17 values(<span class="hljs-number">1.111111111111111111111111111111</span>);<br><br><span class="hljs-built_in">float</span> &lt; double &lt; decimal<br><span class="hljs-comment"># 要结合实际应用场景 三者都能使用</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul><li><p>分类</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">char</span><br><span class="hljs-string">定长</span><br><span class="hljs-string">char(4) 数据超过四个字符直接报错 不够四个字符空格补全</span><br><span class="hljs-string">varchar</span><br><span class="hljs-string">变长</span><br><span class="hljs-string">varchar(4)  数据超过四个字符直接报错 不够有几个存几个</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table t18(name char(<span class="hljs-number">4</span>));<br>create table t19(name varchar(<span class="hljs-number">4</span>));<br><br>insert into t18 values(<span class="hljs-string">&#x27;a&#x27;</span>);<br>insert into t19 values(<span class="hljs-string">&#x27;a&#x27;</span>);<br><br><span class="hljs-comment"># 介绍一个小方法 char_length统计字段长度</span><br>select char_length(name) <span class="hljs-keyword">from</span> t18;<br>select char_length(name) <span class="hljs-keyword">from</span> t19;<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">首先可以肯定的是 char硬盘上存的绝对是真正的数据 带有空格的</span><br><span class="hljs-string">但是在显示的时候MySQL会自动将多余的空格剔除</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 再次修改sql_mode 让MySQL不要做自动剔除操作</span><br><span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span> sql_mode = <span class="hljs-string">&#x27;STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="char与varchar对比"><a href="#char与varchar对比" class="headerlink" title="char与varchar对比"></a>char与varchar对比</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">char</span><br><span class="hljs-string">缺点:浪费空间</span><br><span class="hljs-string">优点:存取都很简单</span><br><span class="hljs-string">直接按照固定的字符存取数据即可</span><br><span class="hljs-string">jason egon alex wusir tank </span><br><span class="hljs-string">存按照五个字符存 取也直接按照五个字符取</span><br><span class="hljs-string"></span><br><span class="hljs-string">varchar</span><br><span class="hljs-string">优点:节省空间</span><br><span class="hljs-string">缺点:存取较为麻烦</span><br><span class="hljs-string">1bytes+jason 1bytes+egon 1bytes+alex 1bytes+tank </span><br><span class="hljs-string"></span><br><span class="hljs-string">存的时候需要制作报头</span><br><span class="hljs-string">取的时候也需要先读取报头 之后才能读取真实数据</span><br><span class="hljs-string"></span><br><span class="hljs-string">以前基本上都是用的char 其实现在用varchar的也挺多</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>补充:<br>    进来公司之后你完全不需要考虑字段类型和字段名<br>    因为产品经理给你发的邮件上已经全部指明了<br></code></pre></td></tr></table></figure></li></ul><h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><ul><li><p>分类</p><p>  date:年月日 2020-5-4</p><p>  datetime:年月日时分秒  2020-5-4 11:11:11</p><p>  time:时分秒11:11:11</p><p>  Year:2020</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">create table student(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>    name varchar(<span class="hljs-number">16</span>),<br>    born_year year,<br>    birth date,<br>    study_time time,<br>    reg_time datetime<br>);<br>insert into student values(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;1880&#x27;</span>,<span class="hljs-string">&#x27;1880-11-11&#x27;</span>,<span class="hljs-string">&#x27;11:11:11&#x27;</span>,<span class="hljs-string">&#x27;2020-11-11 11:11:11&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="枚举与集合类型"><a href="#枚举与集合类型" class="headerlink" title="枚举与集合类型"></a>枚举与集合类型</h4><ul><li><p>分类</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">枚举(enum)  多选一</span><br><span class="hljs-string">集合(set)   多选多</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>具体使用</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">create table user(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>    name char(<span class="hljs-number">16</span>),<br>    gender enum(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-string">&#x27;others&#x27;</span>)<br>);<br>insert into user values(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;jason&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>);  正常<br>insert into user values(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;xxxxooo&#x27;</span>);  报错<br><span class="hljs-comment"># 枚举字段 后期在存数据的时候只能从枚举里面选择一个存储 </span><br><br><br>create table teacher(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>    name char(<span class="hljs-number">16</span>),<br>    gender enum(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-string">&#x27;others&#x27;</span>),<br>    hobby <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;read&#x27;</span>,<span class="hljs-string">&#x27;DBJ&#x27;</span>,<span class="hljs-string">&#x27;hecha&#x27;</span>)<br>);<br>insert into teacher values(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;jason&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;read&#x27;</span>);  正常<br>insert into teacher values(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-string">&#x27;DBJ,hecha&#x27;</span>);  正常<br>insert into teacher values(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;tank&#x27;</span>,<span class="hljs-string">&#x27;others&#x27;</span>,<span class="hljs-string">&#x27;生蚝&#x27;</span>); 报错<br><span class="hljs-comment"># 集合可以只写一个  但是不能写没有列举的</span><br></code></pre></td></tr></table></figure><p>  <strong>总结</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">字段类型</span><br><span class="hljs-string">严格模式</span><br><span class="hljs-string"></span><br><span class="hljs-string">约束条件</span><br><span class="hljs-string">not null</span><br><span class="hljs-string">zerofill</span><br><span class="hljs-string">unsigned</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><h4 id="default默认值"><a href="#default默认值" class="headerlink" title="default默认值"></a>default默认值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 补充知识点  插入数据的时候可以指定字段</span><br>create table t1(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>    name char(<span class="hljs-number">16</span>)<br>);<br>insert into t1(name,<span class="hljs-built_in">id</span>) values(<span class="hljs-string">&#x27;jason&#x27;</span>,<span class="hljs-number">1</span>);<br><br>create table t2(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>    name char(<span class="hljs-number">16</span>),<br>    gender enum(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-string">&#x27;others&#x27;</span>) default <span class="hljs-string">&#x27;male&#x27;</span><br>);<br>insert into t2(<span class="hljs-built_in">id</span>,name) values(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;jason&#x27;</span>);<br>insert into t2 values(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="unique唯一"><a href="#unique唯一" class="headerlink" title="unique唯一"></a>unique唯一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单列唯一</span><br>create table t3(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> unique,<br>    name char(<span class="hljs-number">16</span>)<br>);<br>insert into t3 values(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;jason&#x27;</span>),(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;egon&#x27;</span>);<br>insert into t3 values(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;jason&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;egon&#x27;</span>);<br><br><span class="hljs-comment"># 联合唯一</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">ip和port</span><br><span class="hljs-string">单个都可以重复 但是加载一起必须是唯一的</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table t4(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>    ip char(<span class="hljs-number">16</span>),<br>    port <span class="hljs-built_in">int</span>,<br>    unique(ip,port)<br>);<br>insert into t4 values(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>);<br>insert into t4 values(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8081</span>);<br>insert into t4 values(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;127.0.0.2&#x27;</span>,<span class="hljs-number">8080</span>);<br>insert into t4 values(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>);  报错<br></code></pre></td></tr></table></figure><h4 id="primary-key主键"><a href="#primary-key主键" class="headerlink" title="primary key主键"></a>primary key主键</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.单单从约束效果上来看primary key等价于not null + unique</span><br><span class="hljs-string">非空且唯一！！！</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table t5(<span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key);<br>insert into t5 values(null);  报错<br>insert into t5 values(<span class="hljs-number">1</span>),(<span class="hljs-number">1</span>);  报错<br>insert into t5 values(<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>); <br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">2.它除了有约束效果之外 它还是Innodb存储引擎组织数据的依据</span><br><span class="hljs-string">Innodb存储引擎在创建表的时候必须要有primary key</span><br><span class="hljs-string">因为它类似于书的目录 能够帮助提示查询效率并且也是建表的依据</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 1 一张表中有且只有一个主键 如果你没有设置主键 那么会从上往下搜索直到遇到一个非空且唯一的字段将它自动升级为主键</span><br>create table t6(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>    name char(<span class="hljs-number">16</span>),<br>    age <span class="hljs-built_in">int</span> <span class="hljs-keyword">not</span> null unique,<br>    addr char(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> null unique<br>);<br><br><span class="hljs-comment"># 2 如果表中没有主键也没有其他任何的非空且唯一字段 那么Innodb会采用自己内部提供的一个隐藏字段作为主键，隐藏意味着你无法使用到它 就无法提示查询速度</span><br><br><span class="hljs-comment"># 3 一张表中通常都应该有一个主键字段 并且通常将id/uid/sid字段作为主键</span><br><span class="hljs-comment"># 单个字段主键</span><br>create table t5(<br>    <span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key<br>name char(<span class="hljs-number">16</span>)<br>);<br><span class="hljs-comment"># 联合主键(多个字段联合起来作为表的主键 本质还是一个主键)</span><br>create table t7(<br>    ip char(<span class="hljs-number">16</span>),<br>    port <span class="hljs-built_in">int</span>,<br>    primary key(ip,port)<br>);<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">也意味着 以后我们在创建表的时候id字段一定要加primary key</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="auto-increment自增"><a href="#auto-increment自增" class="headerlink" title="auto_increment自增"></a>auto_increment自增</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 当编号特别多的时候 人为的去维护太麻烦</span><br>create table t8(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    name char(<span class="hljs-number">16</span>)<br>);<br>insert into t8(name) values(<span class="hljs-string">&#x27;jason&#x27;</span>),(<span class="hljs-string">&#x27;egon&#x27;</span>),(<span class="hljs-string">&#x27;kevin&#x27;</span>);<br><br><span class="hljs-comment"># 注意auto_increment通常都是加在主键上的 不能给普通字段加</span><br>create table t9(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    name char(<span class="hljs-number">16</span>),<br>    cid <span class="hljs-built_in">int</span> auto_increment<br>);<br>ERROR <span class="hljs-number">1075</span> (<span class="hljs-number">42000</span>): Incorrect table definition; there can be only one auto column <span class="hljs-keyword">and</span> it must be defined <span class="hljs-keyword">as</span> a key<br></code></pre></td></tr></table></figure><p><strong>结论</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">以后在创建表的id(数据的唯一标识id、uid、sid)字段的时候</span><br><span class="hljs-string">id int primary key auto_increment</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>补充</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">delete <span class="hljs-keyword">from</span> t1  删除表中数据后 主键的自增不会停止<br><br>truncate t1  清空表数据并且重置主键<br></code></pre></td></tr></table></figure><h3 id="表与表之间建关系"><a href="#表与表之间建关系" class="headerlink" title="表与表之间建关系"></a>表与表之间建关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">定义一张员工表 表中有很多字段</span><br><span class="hljs-string">id name gender dep_name dep_desc</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 1 该表的组织结构不是很清晰(可忽视)</span><br><span class="hljs-comment"># 2 浪费硬盘空间(可忽视)</span><br><span class="hljs-comment"># 3 数据的扩展性极差(无法忽视的)</span><br><br><span class="hljs-comment"># 如何优化？</span><br><span class="hljs-string">&quot;&quot;&quot;上述问题就类似于你将所有的代码都写在了一个py文件中&quot;&quot;&quot;</span><br>将员工表拆分  员工表和部门表<br></code></pre></td></tr></table></figure><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">外键就是用来帮助我们建立表与表之间关系的，对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性</span><br><span class="hljs-string">添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);</span><br><span class="hljs-string">删除外键约束: alter table 表名 drop foreign key 外键名;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">表与表之间最多只有四种关系</span><br><span class="hljs-string">一对多关系</span><br><span class="hljs-string">在MySQL的关系中没有多对一一说</span><br><span class="hljs-string">一对多 多对一 都叫一对多！！！</span><br><span class="hljs-string">多对多关系</span><br><span class="hljs-string">一对一关系</span><br><span class="hljs-string">没有关系</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">判断表与表之间关系的时候 前期不熟悉的情况下 一定要按照我给你的建议</span><br><span class="hljs-string">换位思考  分别站在两张表的角度考虑</span><br><span class="hljs-string"></span><br><span class="hljs-string">员工表与部门表为例</span><br><span class="hljs-string">先站在员工表</span><br><span class="hljs-string">思考一个员工能否对应多个部门(一条员工数据能否对应多条部门数据)</span><br><span class="hljs-string">不能！！！</span><br><span class="hljs-string">(不能直接得出结论 一定要两张表都考虑完全)</span><br><span class="hljs-string">再站在部门表</span><br><span class="hljs-string">思考一个部门能否对应多个员工(一个部门数据能否对应多条员工数据)</span><br><span class="hljs-string">能！！！</span><br><span class="hljs-string">得出结论</span><br><span class="hljs-string">员工表与部门表示单向的一对多</span><br><span class="hljs-string">所以表关系就是一对多</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>foreign key<br><span class="hljs-number">1</span> 一对多表关系   外键字段建在多的一方<br>    <span class="hljs-number">2</span> 在创建表的时候 一定要先建被关联表 <br>    <span class="hljs-number">3</span> 在录入数据的时候 也必须先录入被关联表<br><span class="hljs-comment"># SQL语句建立表关系</span><br>create table dep(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    dep_name char(<span class="hljs-number">16</span>),<br>    dep_desc char(<span class="hljs-number">32</span>)<br>);<br><br>create table emp(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    name char(<span class="hljs-number">16</span>),<br>    gender enum(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-string">&#x27;others&#x27;</span>) default <span class="hljs-string">&#x27;male&#x27;</span>,<br>    dep_id <span class="hljs-built_in">int</span>,<br>    foreign key(dep_id) references dep(<span class="hljs-built_in">id</span>)<br>);<br>insert into dep(dep_name,dep_desc) values(<span class="hljs-string">&#x27;sb教学部&#x27;</span>,<span class="hljs-string">&#x27;教书育人&#x27;</span>),(<span class="hljs-string">&#x27;外交部&#x27;</span>,<span class="hljs-string">&#x27;多人外交&#x27;</span>),(<span class="hljs-string">&#x27;nb技术部&#x27;</span>,<span class="hljs-string">&#x27;技术能力有限部门&#x27;</span>);<br>insert into emp(name,dep_id) values(<span class="hljs-string">&#x27;jason&#x27;</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&#x27;tank&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&#x27;kevin&#x27;</span>,<span class="hljs-number">3</span>);<br><br><br><span class="hljs-comment"># 修改dep表里面的id字段</span><br>update dep <span class="hljs-built_in">set</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">200</span> where <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>;  不行<br><span class="hljs-comment"># 删除dep表里面的数据</span><br>delete <span class="hljs-keyword">from</span> dep;  不行<br><br><span class="hljs-comment"># 1 先删除教学部对应的员工数据 之后再删除部门</span><br>操作太过繁琐<br>    <br><span class="hljs-comment"># 2 真正做到数据之间有关系</span><br>更新就同步更新<br>    删除就同步删除<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">级联更新   &gt;&gt;&gt;   同步更新</span><br><span class="hljs-string">级联删除   &gt;&gt;&gt;   同步删除</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table dep(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    dep_name char(<span class="hljs-number">16</span>),<br>    dep_desc char(<span class="hljs-number">32</span>)<br>);<br><br>create table emp(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    name char(<span class="hljs-number">16</span>),<br>    gender enum(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-string">&#x27;others&#x27;</span>) default <span class="hljs-string">&#x27;male&#x27;</span>,<br>    dep_id <span class="hljs-built_in">int</span>,<br>    foreign key(dep_id) references dep(<span class="hljs-built_in">id</span>) <br>    on update cascade  <span class="hljs-comment"># 同步更新</span><br>    on delete cascade  <span class="hljs-comment"># 同步删除</span><br>);<br>insert into dep(dep_name,dep_desc) values(<span class="hljs-string">&#x27;sb教学部&#x27;</span>,<span class="hljs-string">&#x27;教书育人&#x27;</span>),(<span class="hljs-string">&#x27;外交部&#x27;</span>,<span class="hljs-string">&#x27;多人外交&#x27;</span>),(<span class="hljs-string">&#x27;nb技术部&#x27;</span>,<span class="hljs-string">&#x27;技术能力有限部门&#x27;</span>);<br>insert into emp(name,dep_id) values(<span class="hljs-string">&#x27;jason&#x27;</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&#x27;tank&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&#x27;kevin&#x27;</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">图书表和作者表</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table book(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    title varchar(<span class="hljs-number">32</span>),<br>    price <span class="hljs-built_in">int</span>,<br>    author_id <span class="hljs-built_in">int</span>,<br>    foreign key(author_id) references author(<span class="hljs-built_in">id</span>) <br>    on update cascade  <span class="hljs-comment"># 同步更新</span><br>    on delete cascade  <span class="hljs-comment"># 同步删除</span><br>);<br>create table author(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    name varchar(<span class="hljs-number">32</span>),<br>    age <span class="hljs-built_in">int</span>,<br>    book_id <span class="hljs-built_in">int</span>,<br>    foreign key(book_id) references book(<span class="hljs-built_in">id</span>) <br>    on update cascade  <span class="hljs-comment"># 同步更新</span><br>    on delete cascade  <span class="hljs-comment"># 同步删除</span><br>);<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">按照上述的方式创建 一个都别想成功！！！</span><br><span class="hljs-string">其实我们只是想记录书籍和作者的关系</span><br><span class="hljs-string">针对多对多字段表关系 不能在两张原有的表中创建外键</span><br><span class="hljs-string">需要你单独再开设一张 专门用来存储两张表数据之间的关系</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table book(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    title varchar(<span class="hljs-number">32</span>),<br>    price <span class="hljs-built_in">int</span><br>);<br>create table author(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    name varchar(<span class="hljs-number">32</span>),<br>    age <span class="hljs-built_in">int</span><br>);<br>create table book2author(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    author_id <span class="hljs-built_in">int</span>,<br>    book_id <span class="hljs-built_in">int</span>,<br>    foreign key(author_id) references author(<span class="hljs-built_in">id</span>) <br>    on update cascade  <span class="hljs-comment"># 同步更新</span><br>    on delete cascade,  <span class="hljs-comment"># 同步删除</span><br>    foreign key(book_id) references book(<span class="hljs-built_in">id</span>) <br>    on update cascade  <span class="hljs-comment"># 同步更新</span><br>    on delete cascade  <span class="hljs-comment"># 同步删除</span><br>);<br></code></pre></td></tr></table></figure><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">id name age addr phone hobby email........</span><br><span class="hljs-string">如果一个表的字段特别多 每次查询又不是所有的字段都能用得到</span><br><span class="hljs-string">将表一分为二  </span><br><span class="hljs-string">用户表</span><br><span class="hljs-string">用户表</span><br><span class="hljs-string">id name age</span><br><span class="hljs-string">用户详情表</span><br><span class="hljs-string">id addr phone hobby email........</span><br><span class="hljs-string"></span><br><span class="hljs-string">站在用户表</span><br><span class="hljs-string">一个用户能否对应多个用户详情   不能！！！</span><br><span class="hljs-string">站在详情表</span><br><span class="hljs-string">一个详情能否属于多个用户      不能！！！</span><br><span class="hljs-string">结论:单向的一对多都不成立 那么这个时候两者之间的表关系</span><br><span class="hljs-string">就是一对一</span><br><span class="hljs-string">或者没有关系(好判断)</span><br><span class="hljs-string"></span><br><span class="hljs-string">客户表和学生表</span><br><span class="hljs-string">在你们报名之前你们是客户端</span><br><span class="hljs-string">报名之后是学生(期间有一些客户不会报名)</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>一对一 外键字段建在任意一方都可以 但是推荐你建在查询频率比较高的表中<br>create table authordetail(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    phone <span class="hljs-built_in">int</span>,<br>    addr varchar(<span class="hljs-number">64</span>)<br>);<br>create table author(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>    name varchar(<span class="hljs-number">32</span>),<br>    age <span class="hljs-built_in">int</span>,<br>    authordetail_id <span class="hljs-built_in">int</span> unique,<br>    foreign key(authordetail_id) references authordetail(<span class="hljs-built_in">id</span>) <br>    on update cascade  <span class="hljs-comment"># 同步更新</span><br>    on delete cascade  <span class="hljs-comment"># 同步删除</span><br>)<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">表关系的建立需要用到foreign key</span><br><span class="hljs-string">一对多</span><br><span class="hljs-string">外键字段建在多的一方</span><br><span class="hljs-string">多对多</span><br><span class="hljs-string">自己开设第三张存储</span><br><span class="hljs-string">一对一</span><br><span class="hljs-string">建在任意一方都可以 但是推荐你建在查询频率较高的表中</span><br><span class="hljs-string"></span><br><span class="hljs-string">判断表之间关系的方式</span><br><span class="hljs-string">换位思考！！！</span><br><span class="hljs-string">员工与部门</span><br><span class="hljs-string"></span><br><span class="hljs-string">图书与作者</span><br><span class="hljs-string"></span><br><span class="hljs-string">作者与作者详情</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语法</span><br>create table 表名(<br>字段名<span class="hljs-number">1</span> 类型(宽度) 约束条件,<br>    字段名<span class="hljs-number">2</span> 类型(宽度) 约束条件,<br>    字段名<span class="hljs-number">3</span> 类型(宽度) 约束条件<br>)<br><br><span class="hljs-comment"># 注意</span><br><span class="hljs-number">1</span> 在同一张表中字段名不能重复<br><span class="hljs-number">2</span> 宽度和约束条件是可选的(可写可不写) 而字段名和字段类型是必须的<br>约束条件写的话 也支持写多个<br>    字段名<span class="hljs-number">1</span> 类型(宽度) 约束条件<span class="hljs-number">1</span> 约束条件<span class="hljs-number">2.</span>..,<br>create table t5(<span class="hljs-built_in">id</span>);  报错<br><span class="hljs-number">3</span> 最后一行不能有逗号<br>create table t6(<br>        <span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>        name char,<br>    );   报错<br><br><span class="hljs-string">&quot;&quot;&quot;补充&quot;&quot;&quot;</span><br><span class="hljs-comment"># 宽度</span><br>一般情况下指的是对存储数据的限制<br>create table t7(name char);  默认宽度是<span class="hljs-number">1</span><br>    insert into t7 values(<span class="hljs-string">&#x27;jason&#x27;</span>);<br>    insert into t7 values(null);  关键字NULL<br>    针对不同的版本会出现不同的效果<br>        <span class="hljs-number">5.6</span>版本默认没有开启严格模式 规定只能存一个字符你给了多个字符，那么我会自动帮你截取<br>            <span class="hljs-number">5.7</span>版本及以上或者开启了严格模式 那么规定只能存几个 就不能超，一旦超出范围立刻报错 Data too long <span class="hljs-keyword">for</span> ....<br><span class="hljs-string">&quot;&quot;&quot;严格模式到底开不开呢？&quot;&quot;&quot;</span><br>MySQL5<span class="hljs-number">.7</span>之后的版本默认都是开启严格模式的<br>使用数据库的准则:<br>能尽量少的让数据库干活就尽量少 不要给数据库增加额外的压力<br><br><span class="hljs-comment"># 约束条件 null  not null不能插入null</span><br>create table t8(<span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,name char <span class="hljs-keyword">not</span> null);<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">宽度和约束条件到底是什么关系</span><br><span class="hljs-string">宽度是用来限制数据的存储</span><br><span class="hljs-string">约束条件是在宽度的基础之上增加的额外的约束</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># MySQL对大小写是不敏感的</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1 修改表名</span><br><span class="hljs-string">alter table 表名 rename 新表名;</span><br><span class="hljs-string"></span><br><span class="hljs-string">2 增加字段</span><br><span class="hljs-string">alter table 表名 add 字段名 字段类型(宽度)  约束条件;</span><br><span class="hljs-string">alter table 表名 add 字段名 字段类型(宽度)  约束条件 first;</span><br><span class="hljs-string">alter table 表名 add 字段名 字段类型(宽度)  约束条件 after 字段名;</span><br><span class="hljs-string"></span><br><span class="hljs-string">3 删除字段</span><br><span class="hljs-string">alter table 表名 drop 字段名;</span><br><span class="hljs-string"></span><br><span class="hljs-string">4 修改字段</span><br><span class="hljs-string">alter table 表名 modify 字段名 字段类型(宽度) 约束条件;</span><br><span class="hljs-string"></span><br><span class="hljs-string">alter table 表名 change 旧字段名 新字段名 字段类型(宽度) 约束条件;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">我们sql语句查询的结果其实也是一张虚拟表</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>create table 表名 select * <span class="hljs-keyword">from</span> 旧表;  不能复制主键 外键 ...<br><br>create table new_dep2 select * <span class="hljs-keyword">from</span> dep where <span class="hljs-built_in">id</span>&gt;<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="表查询操作"><a href="#表查询操作" class="headerlink" title="表查询操作"></a>表查询操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 查询语句<br><span class="hljs-keyword">select</span> 字段名 <span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">as</span> :给字段名或表取别名,例如<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> studentu <span class="hljs-keyword">as</span> a <br><span class="hljs-keyword">distinct</span>:<span class="hljs-keyword">distinct</span>可以去除重复数据行。<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> 列<span class="hljs-number">1</span>,... <span class="hljs-keyword">from</span> 表名;<br><span class="hljs-keyword">where</span>:条件查询<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件;<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> : 排序<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 列<span class="hljs-number">1</span> <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span> [,列<span class="hljs-number">2</span> <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>,...]<br>例：<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> gender<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> is_delete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span>;<br><span class="hljs-keyword">asc</span> 表示升序<br><span class="hljs-keyword">desc</span> 表示降序<br>limit ：分页查询<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 limit <span class="hljs-keyword">start</span>,count<br>limit是分页查询关键字<br><span class="hljs-keyword">start</span>表示开始行索引，默认是<span class="hljs-number">0</span><br>count表示查询条数<br>例：查询前<span class="hljs-number">3</span>行男生信息:<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> gender<span class="hljs-operator">=</span><span class="hljs-number">1</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">3</span>;<br>简写<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> gender<span class="hljs-operator">=</span><span class="hljs-number">1</span> limit <span class="hljs-number">3</span>;<br>聚合函数:<br><span class="hljs-built_in">count</span>(col): 表示求指定列的总行数<br><span class="hljs-built_in">max</span>(col): 表示求指定列的最大值<br><span class="hljs-built_in">min</span>(col): 表示求指定列的最小值<br><span class="hljs-built_in">sum</span>(col): 表示求指定列的和<br><span class="hljs-built_in">avg</span>(col): 表示求指定列的平均值<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>: 分组查询<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名 [<span class="hljs-keyword">HAVING</span> 条件表达式] [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>]<br>列名: 是指按照指定字段的值进行分组。<br><span class="hljs-keyword">HAVING</span> 条件表达式: 用来过滤分组后的数据。<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>：在所有记录的最后加上一条记录，显示<span class="hljs-keyword">select</span>查询时聚合函数的统计和计算结果<br>例：<br><span class="hljs-comment">-- 根据gender字段来分组</span><br><span class="hljs-keyword">select</span> gender <span class="hljs-keyword">from</span> students <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><span class="hljs-comment">-- 根据name和gender字段进行分组</span><br><span class="hljs-keyword">select</span> name, gender <span class="hljs-keyword">from</span> students <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name, gender;<br><br>group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割<br>例：<br><span class="hljs-comment">-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息</span><br><span class="hljs-keyword">select</span> gender,group_concat(name) <span class="hljs-keyword">from</span> students <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br>连接查询：<br>内连接查询：内连接根据连接查询条件取出两个表的 “交集”<br>左连接查询：左连接以左表为主根据条件查询右表数据，右表数据不存在使用<span class="hljs-keyword">null</span>值填充。<br>右连接查询：右连接以右表为主根据条件查询左表数据，左表数据不存在使用<span class="hljs-keyword">null</span>值填充。<br>自连接查询<br><br>内连接查询语法格式:<br><span class="hljs-keyword">select</span> 字段 <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">on</span> 表<span class="hljs-number">1.</span>字段<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 表<span class="hljs-number">2.</span>字段<span class="hljs-number">2</span><br>左连接查询语法格式:<br><span class="hljs-keyword">select</span> 字段 <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">on</span> 表<span class="hljs-number">1.</span>字段<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 表<span class="hljs-number">2.</span>字段<span class="hljs-number">2</span><br>右连接查询语法格式:<br><span class="hljs-keyword">select</span> 字段 <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">on</span> 表<span class="hljs-number">1.</span>字段<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 表<span class="hljs-number">2.</span>字段<span class="hljs-number">2</span><br>自连接查询：<br>自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。<br>自连接就是一种特殊的连接方式，连接的表还是本身这张表<br>自连接查询必须对表起别名<br>自连接查询的用法:<br><span class="hljs-keyword">select</span> c.id, c.title, c.pid, p.title <span class="hljs-keyword">from</span> areas <span class="hljs-keyword">as</span> c <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> areas <span class="hljs-keyword">as</span> p <span class="hljs-keyword">on</span> c.pid <span class="hljs-operator">=</span> p.id <span class="hljs-keyword">where</span> p.title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;山西省&#x27;</span>;<br>子查询：<br>在一个 <span class="hljs-keyword">select</span> 语句中,嵌入了另外一个 <span class="hljs-keyword">select</span> 语句, 那么被嵌入的 <span class="hljs-keyword">select</span> 语句称之为子查询语句，外部那个<span class="hljs-keyword">select</span>语句则称为主查询.<br>主查询和子查询的关系:<br>子查询是嵌入到主查询中<br>子查询是辅助主查询的,要么充当条件,要么充当数据源<br>子查询是可以独立存在的语句,是一条完整的 <span class="hljs-keyword">select</span> 语句<br></code></pre></td></tr></table></figure><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如何查看严格模式</span><br>show variables like <span class="hljs-string">&quot;%mode&quot;</span>;<br><br>模糊匹配/查询<br>关键字 like<br>%:匹配任意多个字符<br>        _:匹配任意单个字符<br><br><span class="hljs-comment"># 修改严格模式</span><br><span class="hljs-built_in">set</span> session  只在当前窗口有效<br>    <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>   全局有效<br>    <br>    <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span> sql_mode = <span class="hljs-string">&#x27;STRICT_TRANS_TABLES&#x27;</span>;<br>    <br>    修改完之后 重新进入服务端即可<br></code></pre></td></tr></table></figure><h4 id="前期表准备（实例）"><a href="#前期表准备（实例）" class="headerlink" title="前期表准备（实例）"></a>前期表准备（实例）</h4><p>（针对下面一直到正则的查询语句）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python">create table emp(<br>  <span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">not</span> null unique auto_increment,<br>  name varchar(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> null,<br>  sex enum(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>) <span class="hljs-keyword">not</span> null default <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-comment">#大部分是男的</span><br>  age <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>) unsigned <span class="hljs-keyword">not</span> null default <span class="hljs-number">28</span>,<br>  hire_date date <span class="hljs-keyword">not</span> null,<br>  post varchar(<span class="hljs-number">50</span>),<br>  post_comment varchar(<span class="hljs-number">100</span>),<br>  salary double(<span class="hljs-number">15</span>,<span class="hljs-number">2</span>),<br>  office <span class="hljs-built_in">int</span>, <span class="hljs-comment">#一个部门一个屋子</span><br>  depart_id <span class="hljs-built_in">int</span><br>);<br><br><span class="hljs-comment">#插入记录</span><br><span class="hljs-comment">#三个部门：教学，销售，运营</span><br>insert into emp(name,sex,age,hire_date,post,salary,office,depart_id) values<br>(<span class="hljs-string">&#x27;jason&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;20170301&#x27;</span>,<span class="hljs-string">&#x27;张江第一帅形象代言&#x27;</span>,<span class="hljs-number">7300.33</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>), <span class="hljs-comment">#以下是教学部</span><br>(<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">78</span>,<span class="hljs-string">&#x27;20150302&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-number">1000000.31</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;kevin&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">81</span>,<span class="hljs-string">&#x27;20130305&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-number">8300</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;tony&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">73</span>,<span class="hljs-string">&#x27;20140701&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-number">3500</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;owen&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">28</span>,<span class="hljs-string">&#x27;20121101&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-number">2100</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;20110211&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-number">9000</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;jenny&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;19000301&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-number">30000</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;sank&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">48</span>,<span class="hljs-string">&#x27;20101111&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">401</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;哈哈&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">48</span>,<span class="hljs-string">&#x27;20150311&#x27;</span>,<span class="hljs-string">&#x27;sale&#x27;</span>,<span class="hljs-number">3000.13</span>,<span class="hljs-number">402</span>,<span class="hljs-number">2</span>),<span class="hljs-comment">#以下是销售部门</span><br>(<span class="hljs-string">&#x27;呵呵&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">38</span>,<span class="hljs-string">&#x27;20101101&#x27;</span>,<span class="hljs-string">&#x27;sale&#x27;</span>,<span class="hljs-number">2000.35</span>,<span class="hljs-number">402</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;西西&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;20110312&#x27;</span>,<span class="hljs-string">&#x27;sale&#x27;</span>,<span class="hljs-number">1000.37</span>,<span class="hljs-number">402</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;乐乐&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;20160513&#x27;</span>,<span class="hljs-string">&#x27;sale&#x27;</span>,<span class="hljs-number">3000.29</span>,<span class="hljs-number">402</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;拉拉&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">28</span>,<span class="hljs-string">&#x27;20170127&#x27;</span>,<span class="hljs-string">&#x27;sale&#x27;</span>,<span class="hljs-number">4000.33</span>,<span class="hljs-number">402</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;僧龙&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">28</span>,<span class="hljs-string">&#x27;20160311&#x27;</span>,<span class="hljs-string">&#x27;operation&#x27;</span>,<span class="hljs-number">10000.13</span>,<span class="hljs-number">403</span>,<span class="hljs-number">3</span>), <span class="hljs-comment">#以下是运营部门</span><br>(<span class="hljs-string">&#x27;程咬金&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;19970312&#x27;</span>,<span class="hljs-string">&#x27;operation&#x27;</span>,<span class="hljs-number">20000</span>,<span class="hljs-number">403</span>,<span class="hljs-number">3</span>),<br>(<span class="hljs-string">&#x27;程咬银&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;20130311&#x27;</span>,<span class="hljs-string">&#x27;operation&#x27;</span>,<span class="hljs-number">19000</span>,<span class="hljs-number">403</span>,<span class="hljs-number">3</span>),<br>(<span class="hljs-string">&#x27;程咬铜&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;20150411&#x27;</span>,<span class="hljs-string">&#x27;operation&#x27;</span>,<span class="hljs-number">18000</span>,<span class="hljs-number">403</span>,<span class="hljs-number">3</span>),<br>(<span class="hljs-string">&#x27;程咬铁&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;20140512&#x27;</span>,<span class="hljs-string">&#x27;operation&#x27;</span>,<span class="hljs-number">17000</span>,<span class="hljs-number">403</span>,<span class="hljs-number">3</span>);<br><br><br><span class="hljs-comment"># 当表字段特别多 展示的时候错乱 可以使用\G分行展示</span><br>select * <span class="hljs-keyword">from</span> emp\G;<br><br><span class="hljs-comment"># 个别同学的电脑在插入中文的时候还是会出现乱码或者空白的现象 你可以将字符编码统一设置成GBK</span><br></code></pre></td></tr></table></figure><h4 id="where筛选条件"><a href="#where筛选条件" class="headerlink" title="where筛选条件"></a>where筛选条件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 作用:是对整体数据的一个筛选操作</span><br><span class="hljs-comment"># 1.查询id大于等于3小于等于6的数据</span><br>select <span class="hljs-built_in">id</span>,name,age <span class="hljs-keyword">from</span> emp where <span class="hljs-built_in">id</span>&gt;=<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">id</span>&lt;=<span class="hljs-number">6</span>;<br>select <span class="hljs-built_in">id</span>,name <span class="hljs-keyword">from</span> emp where <span class="hljs-built_in">id</span> between <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span>;  两者等价<br><br><span class="hljs-comment"># 2.查询薪资是20000或者18000或者17000的数据</span><br>select * <span class="hljs-keyword">from</span> emp where salary=<span class="hljs-number">20000</span> <span class="hljs-keyword">or</span> salary=<span class="hljs-number">18000</span> <span class="hljs-keyword">or</span> salary=<span class="hljs-number">17000</span>;<br>select * <span class="hljs-keyword">from</span> emp where salary <span class="hljs-keyword">in</span> (<span class="hljs-number">20000</span>,<span class="hljs-number">18000</span>,<span class="hljs-number">17000</span>);<br><br><span class="hljs-comment"># 3.查询员工姓名中包含字母o的员工的姓名和薪资</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">模糊查询</span><br><span class="hljs-string">like</span><br><span class="hljs-string">%  匹配任意多个字符</span><br><span class="hljs-string">_  匹配任意单个字符</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>select name,salary <span class="hljs-keyword">from</span> emp where name like <span class="hljs-string">&#x27;%o%&#x27;</span>;<br><br><span class="hljs-comment"># 4.查询员工姓名是由四个字符组成的 姓名和薪资  char_length()   _</span><br>select name,salary <span class="hljs-keyword">from</span> emp where name like <span class="hljs-string">&#x27;____&#x27;</span>;<br>select name,salary <span class="hljs-keyword">from</span> emp where char_length(name) = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment"># 5.查询id小于3或者id大于6的数据</span><br>select * <span class="hljs-keyword">from</span> emp where <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> between <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-comment"># 6.查询薪资不在20000,18000,17000范围的数据</span><br>select * <span class="hljs-keyword">from</span> emp where salary <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">20000</span>,<span class="hljs-number">18000</span>,<span class="hljs-number">17000</span>);<br><br><span class="hljs-comment"># 7.查询岗位描述为空的员工姓名和岗位名  针对null不用等号 用is</span><br>select name,post <span class="hljs-keyword">from</span> emp where post_comment = NULL;<br>select name,post <span class="hljs-keyword">from</span> emp where post_comment <span class="hljs-keyword">is</span> NULL;<br></code></pre></td></tr></table></figure><h4 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分组实际应用场景  分组应用场景非常的多</span><br>男女比例<br>    部门平均薪资<br>    部门秃头率<br>    国家之间数据统计<br><br><span class="hljs-comment"># 1按照部门分组</span><br>select * <span class="hljs-keyword">from</span> emp group by post;<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">分组之后 最小可操作单位应该是组 还不再是组内的单个数据</span><br><span class="hljs-string">上述命令在你没有设置严格模式的时候是可正常执行的 返回的是分组之后 每个组的第一条数据 但是这不符合分组的规范:分组之后不应该考虑单个数据 而应该以组为操作单位(分组之后 没办法直接获取组内单个数据)</span><br><span class="hljs-string">如果设置了严格模式 那么上述命令会直接报错 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span> sql_mode = <span class="hljs-string">&#x27;strict_trans_tables,only_full_group_by&#x27;</span>;<br><br>设置严格模式之后  分组 默认只能拿到分组的依据<br>select post <span class="hljs-keyword">from</span> emp group by post;  <br>按照什么分组就只能拿到分组 其他字段不能直接获取 需要借助于一些方法(聚合函数)<br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">什么时候需要分组啊？？？</span><br><span class="hljs-string">关键字 </span><br><span class="hljs-string">每个 平均 最高 最低 </span><br><span class="hljs-string"></span><br><span class="hljs-string">聚合函数</span><br><span class="hljs-string">max</span><br><span class="hljs-string">min</span><br><span class="hljs-string">sum</span><br><span class="hljs-string">count</span><br><span class="hljs-string">avg</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 1.获取每个部门的最高薪资</span><br>select post,<span class="hljs-built_in">max</span>(salary) <span class="hljs-keyword">from</span> emp group by post;<br>select post <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;部门&#x27;</span>,<span class="hljs-built_in">max</span>(salary) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;最高薪资&#x27;</span> <span class="hljs-keyword">from</span> emp group by post;<br>select post <span class="hljs-string">&#x27;部门&#x27;</span>,<span class="hljs-built_in">max</span>(salary) <span class="hljs-string">&#x27;最高薪资&#x27;</span> <span class="hljs-keyword">from</span> emp group by post;<br><span class="hljs-comment"># as可以给字段起别名 也可以直接省略不写 但是不推荐 因为省略的话语意不明确 容易错乱</span><br><br><span class="hljs-comment"># 2.获取每个部门的最低薪资</span><br>select post,<span class="hljs-built_in">min</span>(salary) <span class="hljs-keyword">from</span> emp group by post;<br><span class="hljs-comment"># 3.获取每个部门的平均薪资</span><br>select post,avg(salary) <span class="hljs-keyword">from</span> emp group by post;<br><span class="hljs-comment"># 4.获取每个部门的工资总和</span><br>select post,<span class="hljs-built_in">sum</span>(salary) <span class="hljs-keyword">from</span> emp group by post;<br><span class="hljs-comment"># 5.获取每个部门的人数</span><br>select post,count(<span class="hljs-built_in">id</span>) <span class="hljs-keyword">from</span> emp group by post;  <span class="hljs-comment"># 常用 符合逻辑</span><br>select post,count(salary) <span class="hljs-keyword">from</span> emp group by post;<br>select post,count(age) <span class="hljs-keyword">from</span> emp group by post;<br>select post,count(post_comment) <span class="hljs-keyword">from</span> emp group by post;  null不行<br><br><span class="hljs-comment"># 6.查询分组之后的部门名称和每个部门下所有的员工姓名 </span><br><span class="hljs-comment"># group_concat不单单可以支持你获取分组之后的其他字段值 还支持拼接操作</span><br>select post,group_concat(name) <span class="hljs-keyword">from</span> emp group by post;<br>select post,group_concat(name,<span class="hljs-string">&#x27;_DSB&#x27;</span>) <span class="hljs-keyword">from</span> emp group by post;<br>select post,group_concat(name,<span class="hljs-string">&#x27;:&#x27;</span>,salary) <span class="hljs-keyword">from</span> emp group by post;<br><span class="hljs-comment"># concat不分组的时候用 </span><br>select concat(<span class="hljs-string">&#x27;NAME:&#x27;</span>,name),concat(<span class="hljs-string">&#x27;SAL:&#x27;</span>,salary) <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment"># 补充 as语法不单单可以给字段起别名 还可以给表临时起别名</span><br>select emp.<span class="hljs-built_in">id</span>,emp.name <span class="hljs-keyword">from</span> emp;  <br>select emp.<span class="hljs-built_in">id</span>,emp.name <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">as</span> t1;   报错<br>select t1.<span class="hljs-built_in">id</span>,t1.name <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">as</span> t1;<br><br><span class="hljs-comment"># 查询每个人的年薪  12薪</span><br>select name,salary*<span class="hljs-number">12</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h4 id="分组注意事项"><a href="#分组注意事项" class="headerlink" title="分组注意事项"></a>分组注意事项</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 关键字where和group by同时出现的时候group by必须在where的后面</span><br>where先对整体数据进行过滤之后再分组操作<br>where筛选条件不能使用聚合函数<br>select <span class="hljs-built_in">id</span>,name,age <span class="hljs-keyword">from</span> emp where <span class="hljs-built_in">max</span>(salary) &gt; <span class="hljs-number">3000</span>;<br><br>select <span class="hljs-built_in">max</span>(salary) <span class="hljs-keyword">from</span> emp;  <span class="hljs-comment"># 不分组 默认整体就是一组</span><br><br><span class="hljs-comment"># 统计各部门年龄在30岁以上的员工平均薪资</span><br><span class="hljs-number">1</span> 先求所有年龄大于<span class="hljs-number">30</span>岁的员工<br>    select * <span class="hljs-keyword">from</span> emp where age&gt;<span class="hljs-number">30</span>;<br>    <span class="hljs-number">2</span> 再对结果进行分组<br>     select * <span class="hljs-keyword">from</span> emp where age&gt;<span class="hljs-number">30</span> group by post;<br>    <br>    select post,avg(salary) <span class="hljs-keyword">from</span> emp where age&gt;<span class="hljs-number">30</span> group by post;<br></code></pre></td></tr></table></figure><h4 id="having分组之后的筛选条件"><a href="#having分组之后的筛选条件" class="headerlink" title="having分组之后的筛选条件"></a>having分组之后的筛选条件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">having的语法根where是一致的</span><br><span class="hljs-string">只不过having是在分组之后进行的过滤操作</span><br><span class="hljs-string">即having是可以直接使用聚合函数的</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 统计各部门年龄在30岁以上的员工平均工资并且保留平均薪资大于10000的部门</span><br>select post,avg(salary) <span class="hljs-keyword">from</span> emp <br>where age&gt;<span class="hljs-number">30</span> <br>    group by post<br>        having avg(salary) &gt; <span class="hljs-number">10000</span><br>        ;<br></code></pre></td></tr></table></figure><h4 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">一定要注意 必须是完全一样的数据才可以去重！！！</span><br><span class="hljs-string">一定不要将逐渐忽视了 有逐渐存在的情况下 是不可能去重的</span><br><span class="hljs-string">[</span><br><span class="hljs-string">&#123;&#x27;id&#x27;:1,&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18&#125;,</span><br><span class="hljs-string">&#123;&#x27;id&#x27;:2,&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18&#125;,</span><br><span class="hljs-string">&#123;&#x27;id&#x27;:3,&#x27;name&#x27;:&#x27;egon&#x27;,&#x27;age&#x27;:18&#125;</span><br><span class="hljs-string">]</span><br><span class="hljs-string">ORM  对象关系映射   让不懂SQL语句的人也能够非常牛逼的操作数据库</span><br><span class="hljs-string">表类</span><br><span class="hljs-string">一条条的数据对象</span><br><span class="hljs-string">字段对应的值对象的属性</span><br><span class="hljs-string"></span><br><span class="hljs-string">你再写类 就意味着在创建表</span><br><span class="hljs-string">用类生成对象 就意味着再创建数据</span><br><span class="hljs-string">对象点属性 就是在获取数据字段对应的值</span><br><span class="hljs-string">目的就是减轻python程序员的压力 只需要会python面向对象的知识点就可以操作MySQL</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>select distinct <span class="hljs-built_in">id</span>,age <span class="hljs-keyword">from</span> emp;<br>select distinct age <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h4 id="order-by排序"><a href="#order-by排序" class="headerlink" title="order by排序"></a>order by排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">select * <span class="hljs-keyword">from</span> emp order by salary;<br>select * <span class="hljs-keyword">from</span> emp order by salary asc;<br>select * <span class="hljs-keyword">from</span> emp order by salary desc;<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">order by默认是升序  asc 该asc可以省略不写</span><br><span class="hljs-string">也可以修改为降序     desc</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>select * <span class="hljs-keyword">from</span> emp order by age desc,salary asc;<br><span class="hljs-comment"># 先按照age降序排  如果碰到age相同 则再按照salary升序排</span><br><br><span class="hljs-comment"># 统计各部门年龄在10岁以上的员工平均工资并且保留平均薪资大于1000的部门,然后对平均工资降序排序</span><br>select post,avg(salary) <span class="hljs-keyword">from</span> emp <br>where age&gt;<span class="hljs-number">10</span> <br>    group by post<br>        having avg(salary) &gt; <span class="hljs-number">1000</span><br>        order by avg(salary) desc<br>        ;<br></code></pre></td></tr></table></figure><h4 id="limit限制展示条数"><a href="#limit限制展示条数" class="headerlink" title="limit限制展示条数"></a>limit限制展示条数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">select * <span class="hljs-keyword">from</span> emp;<br><span class="hljs-string">&quot;&quot;&quot;针对数据过多的情况 我们通常都是做分页处理&quot;&quot;&quot;</span><br>select * <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">3</span>;  <span class="hljs-comment"># 只展示三条数据</span><br><br>select * <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br>select * <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">5</span>,<span class="hljs-number">5</span>;<br>第一个参数是起始位置<br>第二个参数是展示条数<br></code></pre></td></tr></table></figure><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">select * <span class="hljs-keyword">from</span> emp where name regexp <span class="hljs-string">&#x27;^j.*(n|y)$&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h4><p>前期表准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#建表</span><br>create table dep(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span>,<br>name varchar(<span class="hljs-number">20</span>) <br>);<br><br>create table emp(<br><span class="hljs-built_in">id</span> <span class="hljs-built_in">int</span> primary key auto_increment,<br>name varchar(<span class="hljs-number">20</span>),<br>sex enum(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>) <span class="hljs-keyword">not</span> null default <span class="hljs-string">&#x27;male&#x27;</span>,<br>age <span class="hljs-built_in">int</span>,<br>dep_id <span class="hljs-built_in">int</span><br>);<br><br><span class="hljs-comment">#插入数据</span><br>insert into dep values<br>(<span class="hljs-number">200</span>,<span class="hljs-string">&#x27;技术&#x27;</span>),<br>(<span class="hljs-number">201</span>,<span class="hljs-string">&#x27;人力资源&#x27;</span>),<br>(<span class="hljs-number">202</span>,<span class="hljs-string">&#x27;销售&#x27;</span>),<br>(<span class="hljs-number">203</span>,<span class="hljs-string">&#x27;运营&#x27;</span>);<br><br>insert into emp(name,sex,age,dep_id) values<br>(<span class="hljs-string">&#x27;jason&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">200</span>),<br>(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">48</span>,<span class="hljs-number">201</span>),<br>(<span class="hljs-string">&#x27;kevin&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">201</span>),<br>(<span class="hljs-string">&#x27;nick&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">28</span>,<span class="hljs-number">202</span>),<br>(<span class="hljs-string">&#x27;owen&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">203</span>),<br>(<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">204</span>);<br></code></pre></td></tr></table></figure><h4 id="表查询"><a href="#表查询" class="headerlink" title="表查询"></a>表查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">select * <span class="hljs-keyword">from</span> dep,emp;  <span class="hljs-comment"># 结果   笛卡尔积</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">了解即可 不知道也没关系</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>select * <span class="hljs-keyword">from</span> emp,dep where emp.dep_id = dep.<span class="hljs-built_in">id</span>;<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">MySQL也知道 你在后面查询数据过程中 肯定会经常用到拼表操作 </span><br><span class="hljs-string">所以特地给你开设了对应的方法</span><br><span class="hljs-string">inner join  内连接</span><br><span class="hljs-string">left join   左连接</span><br><span class="hljs-string">right join  右连接</span><br><span class="hljs-string">union全连接</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># inner join  内连接</span><br>select * <span class="hljs-keyword">from</span> emp inner join dep on emp.dep_id = dep.<span class="hljs-built_in">id</span>;<br><span class="hljs-comment"># 只拼接两张表中公有的数据部分</span><br><br><span class="hljs-comment"># left join   左连接</span><br>select * <span class="hljs-keyword">from</span> emp left join dep on emp.dep_id = dep.<span class="hljs-built_in">id</span>;<br><span class="hljs-comment"># 左表所有的数据都展示出来 没有对应的项就用NULL</span><br><br><span class="hljs-comment"># right join  右连接</span><br>select * <span class="hljs-keyword">from</span> emp right join dep on emp.dep_id = dep.<span class="hljs-built_in">id</span>;<br><span class="hljs-comment"># 右表所有的数据都展示出来 没有对应的项就用NULL</span><br><br><span class="hljs-comment"># union全连接  左右两表所有的数据都展示出来</span><br>select * <span class="hljs-keyword">from</span> emp left join dep on emp.dep_id = dep.<span class="hljs-built_in">id</span><br>union<br>select * <span class="hljs-keyword">from</span> emp right join dep on emp.dep_id = dep.<span class="hljs-built_in">id</span>;<br></code></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">子查询就是我们平时解决问题的思路</span><br><span class="hljs-string">分步骤解决问题</span><br><span class="hljs-string">第一步</span><br><span class="hljs-string">第二步</span><br><span class="hljs-string">...</span><br><span class="hljs-string">将一个查询语句的结果当做另外一个查询语句的条件去用</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 查询部门是技术或者人力资源的员工信息</span><br><span class="hljs-number">1</span> 先获取部门的<span class="hljs-built_in">id</span>号<br>    <span class="hljs-number">2</span> 再去员工表里面筛选出对应的员工<br>    select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> dep where name=<span class="hljs-string">&#x27;技术&#x27;</span> <span class="hljs-keyword">or</span> name = <span class="hljs-string">&#x27;人力资源&#x27;</span>;<br>    <br>    select name <span class="hljs-keyword">from</span> emp where dep_id <span class="hljs-keyword">in</span> (<span class="hljs-number">200</span>,<span class="hljs-number">201</span>);<br>    <br>    <br>    select * <span class="hljs-keyword">from</span> emp where dep_id <span class="hljs-keyword">in</span> (select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> dep where name=<span class="hljs-string">&#x27;技术&#x27;</span> <span class="hljs-keyword">or</span> name = <span class="hljs-string">&#x27;人力资源&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">表的查询结果可以作为其他表的查询条件<br>也可以通过起别名的方式把它作为一个张虚拟表根其他表关联<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多表查询就两种方式</span><br><span class="hljs-string">先拼接表再查询</span><br><span class="hljs-string">子查询 一步一步来</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="将查询结果插入到其它表中"><a href="#将查询结果插入到其它表中" class="headerlink" title="将查询结果插入到其它表中"></a>将查询结果插入到其它表中</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">例：<br><span class="hljs-comment">-- 将查询结果插入到good_cates表中</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> good_cates(<span class="hljs-type">name</span>) <span class="hljs-keyword">select</span> cate_name <span class="hljs-keyword">from</span> goods <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> cate_name;<br><br>使用连接更新表中某个字段数据<br>将goods表中的分类名称更改成商品分类表中对应的分类id<br><span class="hljs-comment">-- 查看goods表中的商品分类名称对应的商品分类id</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> goods <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> good_cates <span class="hljs-keyword">on</span> goods.cate_name = good_cates.name;<br><br><span class="hljs-comment">-- 把该语句中from 后的语句理解为一张虚表  </span><br><span class="hljs-keyword">update</span> goods g <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> good_cates gc <span class="hljs-keyword">on</span> g.cate_name=gc.name <span class="hljs-keyword">set</span> g.cate_name=gc.id;<br><br>更改表字段名（修改表结构）<br>修改表结构可以使用: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 语句，多个修改字段之间使用逗号分隔<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods change cate_name cate_id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, change brand_name brand_id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h2 id="pymsql"><a href="#pymsql" class="headerlink" title="pymsql"></a>pymsql</h2><h3 id="python调用mysql"><a href="#python调用mysql" class="headerlink" title="python调用mysql"></a>python调用mysql</h3><p>pip3 install pymysql(用pip安装pymysql模块)</p><p>python调用mysql接口分为六步：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>导包<br><span class="hljs-number">2.</span>创建连接对象<br><span class="hljs-number">3.</span>获取游标，目的就是要执行<span class="hljs-keyword">sql</span>语句<br><span class="hljs-number">4.</span>执行<span class="hljs-keyword">sql</span>语句<br><span class="hljs-number">5.</span>关闭游标<br><span class="hljs-number">6.</span>关闭连接<br>对应代码：<br>导包<br><span class="hljs-keyword">import</span> pymysql<br>创建连接对象<br>pymysql.<span class="hljs-keyword">connect</span>(参数列表)<br>获取游标对象<br><span class="hljs-keyword">cursor</span> =conn.<span class="hljs-keyword">cursor</span>()<br>执行<span class="hljs-keyword">SQL</span>语句<br><span class="hljs-built_in">row_count</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">execute</span>(<span class="hljs-keyword">sql</span>)<br>获取查询结果集<br>result = <span class="hljs-keyword">cursor</span>.fetchall()<br>将修改操作提交到数据库<br>conn.<span class="hljs-keyword">commit</span>()<br>回滚数据<br>conn.<span class="hljs-keyword">rollback</span>()<br>关闭游标<br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>()<br>关闭连接<br>conn.<span class="hljs-keyword">close</span>()<br>导入 pymysql 包<br><span class="hljs-keyword">import</span> pymysql<br></code></pre></td></tr></table></figure><h3 id="创建连接对象"><a href="#创建连接对象" class="headerlink" title="创建连接对象"></a>创建连接对象</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">调用pymysql模块中的<span class="hljs-keyword">connect</span>()函数来创建连接对象,代码如下:<br> conn=<span class="hljs-keyword">connect</span>(参数列表)<br><br> * 参数host：连接的mysql主机，如果本机是<span class="hljs-string">&#x27;localhost&#x27;</span><br> * 参数port：连接的mysql主机的端口，默认是<span class="hljs-number">3306</span><br> * 参数<span class="hljs-keyword">user</span>：连接的用户名<br> * 参数<span class="hljs-keyword">password</span>：连接的密码<br> * 参数<span class="hljs-keyword">database</span>：数据库的名称<br> * 参数charset：通信采用的编码方式，推荐使用utf8<br>连接对象操作说明:<br>关闭连接 conn.<span class="hljs-keyword">close</span>()<br>提交数据 conn.<span class="hljs-keyword">commit</span>()<br>撤销数据 conn.<span class="hljs-keyword">rollback</span>()<br>获取游标对象：<br>获取游标对象的目标就是要执行<span class="hljs-keyword">sql</span>语句，完成对数据库的增、删、改、查操作。代码如下:<br> # 调用连接对象的<span class="hljs-keyword">cursor</span>()方法获取游标对象   <br> cur =conn.<span class="hljs-keyword">cursor</span>()<br>游标操作说明:<br>使用游标执行<span class="hljs-keyword">SQL</span>语句: <span class="hljs-keyword">execute</span>(operation [parameters ]) 执行<span class="hljs-keyword">SQL</span>语句，返回受影响的行数，主要用于执行<span class="hljs-keyword">insert</span>、<span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span>、<span class="hljs-keyword">select</span>等语句<br>获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>)<br>获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;李四&#x27;</span>))<br>关闭游标: cur.<span class="hljs-keyword">close</span>(),表示和数据库操作完成<br></code></pre></td></tr></table></figure><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import pymysql<br># 创建连接对象<br>conn = pymysql.connect(<span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-attribute">port</span>=3306, <span class="hljs-attribute">user</span>=<span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;mysql&#x27;</span>,database=&#x27;python&#x27;, <span class="hljs-attribute">charset</span>=<span class="hljs-string">&#x27;utf8&#x27;</span>)<br># 获取游标对象<br>cursor = conn.cursor()<br># 查询 SQL 语句<br>sql = <span class="hljs-string">&quot;select * from students;&quot;</span><br># 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数<br>row_count = cursor.execute(sql)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;SQL 语句执行影响的行数%d&quot;</span> % row_count)<br># 取出结果集中一行数据,　例如:(1, <span class="hljs-string">&#x27;张三&#x27;</span>)<br># <span class="hljs-builtin-name">print</span>(cursor.fetchone())<br># 取出结果集中的所有数据, 例如:((1, <span class="hljs-string">&#x27;张三&#x27;</span>), (2, <span class="hljs-string">&#x27;李四&#x27;</span>), (3, <span class="hljs-string">&#x27;王五&#x27;</span>))<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> cursor.fetchall():<br><span class="hljs-builtin-name">print</span>(line)<br># 关闭游标<br>cursor.close()<br># 关闭连接<br>conn.close()<br>添加（修改）sql数据:<br>import pymysql<br><span class="hljs-attribute">conn</span>=pymysql.connect(host=&quot;10.10.10.85&quot;,<br><span class="hljs-attribute">port</span>=3306,<br><span class="hljs-attribute">user</span>=<span class="hljs-string">&quot;root&quot;</span>,<br><span class="hljs-attribute">password</span>=<span class="hljs-string">&quot;123456&quot;</span>,<br><span class="hljs-attribute">database</span>=<span class="hljs-string">&quot;python&quot;</span>,<br><span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;utf8&quot;</span>)<br>cursor =conn.cursor()<br>sql = <span class="hljs-string">&quot;insert into students(name) values(&#x27;张三&#x27;);&quot;</span><br>try:<br><span class="hljs-attribute">row_count</span>=cursor.execute(sql)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;SQL 语句执行影响的行数%d&quot;</span> % row_count)<br>conn.commit()<br>except Exception as e:<br>conn.rollback()<br>finally:<br>cursor.close()<br>conn.close()<br></code></pre></td></tr></table></figure><h3 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">什么是<span class="hljs-keyword">SQL</span>注入?<br>​用户提交带有恶意的数据与<span class="hljs-keyword">SQL</span>语句进行字符串方式的拼接，从而影响了<span class="hljs-keyword">SQL</span>语句的语义，最终产生数据泄露的现象。<br>​如何防止<span class="hljs-keyword">SQL</span>注入?<br>​<span class="hljs-keyword">SQL</span>语句参数化<br>​<span class="hljs-keyword">SQL</span>语言中的参数使用%s来占位，此处不是python中的字符串格式化操作<br>​将<span class="hljs-keyword">SQL</span>语句中%s占位所需要的参数存在一个列表中，把参数列表传递给<span class="hljs-keyword">execute</span>方法中第二个参数<br><br></code></pre></td></tr></table></figure><h4 id="防止SQL注入的示例代码"><a href="#防止SQL注入的示例代码" class="headerlink" title="防止SQL注入的示例代码:"></a>防止SQL注入的示例代码:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">利用一些语法的特性 书写一些特点的语句实现固定的语法</span><br><span class="hljs-string">MySQL利用的是MySQL的注释语法</span><br><span class="hljs-string">select * from user where name=&#x27;jason&#x27; -- jhsadklsajdkla&#x27; and password=&#x27;&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string">select * from user where name=&#x27;xxx&#x27; or 1=1 -- sakjdkljakldjasl&#x27; and password=&#x27;&#x27;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">#日常生活中很多软件在注册的时候都不能含有特殊符号</span><br><span class="hljs-comment">#因为怕你构造出特定的语句入侵数据库 不安全</span><br><br><span class="hljs-comment"># 敏感的数据不要自己做拼接 交给execute帮你拼接即可</span><br><span class="hljs-comment"># 结合数据库完成一个用户的登录功能？</span><br><span class="hljs-keyword">import</span> pymysql<br><br><br>conn = pymysql.connect(<br>    host = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    port = <span class="hljs-number">3306</span>,<br>    user = <span class="hljs-string">&#x27;root&#x27;</span>,<br>    password = <span class="hljs-string">&#x27;123456&#x27;</span>,<br>    database = <span class="hljs-string">&#x27;day48&#x27;</span>,<br>    charset = <span class="hljs-string">&#x27;utf8&#x27;</span>  <span class="hljs-comment"># 编码千万不要加-</span><br>)  <span class="hljs-comment"># 链接数据库</span><br>cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br><br>username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;&gt;&gt;&gt;:&#x27;</span>)<br>password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;&gt;&gt;&gt;:&#x27;</span>)<br>sql = <span class="hljs-string">&quot;select * from user where name=%s and password=%s&quot;</span><br><span class="hljs-comment"># 不要手动拼接数据 先用%s占位 之后将需要拼接的数据直接交给execute方法即可</span><br><span class="hljs-built_in">print</span>(sql)<br>rows = cursor.execute(sql,(username,password))  <span class="hljs-comment"># 自动识别sql里面的%s用后面元组里面的数据替换</span><br><span class="hljs-keyword">if</span> rows:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(cursor.fetchall())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户名密码错误&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里防止sql注入的主要方法是这句，rows = cursor.execute(sql,(username,password))  ，用execute自带的拼接方式来做防止注入。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket</title>
    <link href="/2021/11/18/socket_hexo/"/>
    <url>/2021/11/18/socket_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="SOCKET-："><a href="#SOCKET-：" class="headerlink" title="SOCKET ："></a>SOCKET ：</h1><p>socket本质上来说就是位于应用层与传输层之间的逻辑层，下图为tcp/ip四层，五层协议以及osi参考模型</p><p><img src="https://yinshiweiysw.github.io/images/assets.socket/1036857-20161008145544426-736439132.png" alt="img"></p><p>一般现在用的就是五层模型，从两台计算机传输数据的角度来讲，物理层定义其计算机基本数据结构（0和1，也就是数据本身）。数据链路层定义了数据的传输（以mac地址为唯一标识），而这一层在局域网内通信方式也极其简单，就是通过广播发送到每一个局域网内的计算机上面，如非指定的接受者（mac地址），则丢弃。到网络层时就可以跨越其局域网的限制，通过网关设备的路由功能（通过ip地址进行路由），就可以找到互联网上的每一个设备进行传输通信，但其本质上还是数据链路层通信，网络层最主要是定位到互联网每一台主机（ARP协议最终将ip解析到mac地址）。到传输层时有两个协议（tcp和udp），tcp是稳定的传输协议，主要保证数据完整性，而udp是非稳定的传输协议，用于非重要数据传输，例如视频聊天，qq信息等。这里传输层定义了端口，可使用范围为1-65535。如果说网络层是用来定位到互联网中的某一台计算机的话，那么传输层则是定位到计算机中的某个应用且与其建立连接（三次握手，其建立连接本质上也是逻辑上的建立）。到应用层这里则是访问到应用中具体某个资源，例如/index.html。</p><p>应用程序位于其应用层，在应用程序发送数据时，需要将其封装打包成一段段的数据段送到传输层，然后传输层再封装成网络包，到链路层时又封装成数据帧，到物理层又封装成数据位（二进制，0和1）。到目标主机以后从物理层开始又一层一层的拆包往上传递，所以正常情况下程序员在编写程序时，应该把客户端和目标服务器五层的封装以及拆包写好，但是这个步骤太过于麻烦且重复性工作，所以有了socket。</p><p><u>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</u></p><p><u>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</u></p><p>有了socket接口以后程序员就只用关心程序本身，只要将C/S两边程序写好，直接调用已有的socket模块来帮程序员完成应用层以下真正实现传输的所有步骤。</p><p><img src="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="socket流程："><a href="#socket流程：" class="headerlink" title="socket流程："></a>socket流程：</h2><p><img src="https://yinshiweiysw.github.io/images/assets.socket/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>图中每一个步骤就是socket的每一个提供函数（方法）。</p><p>客户端：</p><p>首先创建socket对象，连接服务器端，发送（请求）数据和接受数据，然后关闭套接字</p><p>服务器端：<br>        首先也需要创建socket对象，然后绑定端口（服务器需要固定的端口绑定，客户端使用随机ip和端口进行通信即可），监听，监听完毕后accept等待客户端连接（这里可以设置半连接池），然后连接完毕以后发送数据，接受数据（发送接受先后顺序不定，看程序需要），最后关闭连接（关闭这个客户端的连接），但一般不会关闭服务器套接字连接。</p><h2 id="socket-for-python"><a href="#socket-for-python" class="headerlink" title="socket for python:"></a>socket for python:</h2><h3 id="tcp流程"><a href="#tcp流程" class="headerlink" title="tcp流程"></a>tcp流程</h3><p>tcp客户端:<br>            创建客户端套接字对象<br>            和服务端套接字建立连接<br>            发送数据<br>            接收数据<br>            关闭客户端套接字<br>            socket() -&gt; connect() -&gt; send() -&gt; recv () -&gt;close()<br>      tcp服务器：<br>            创建服务端端套接字对象<br>            绑定端口号<br>            设置监听<br>            等待接受客户端的连接请求<br>            接收数据<br>            发送数据<br>            关闭套接字<br>            socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;recv()-send()-&gt;close() </p><p>tcp客户端开发：</p><p>需要导入socket模块，然后根据步骤调用每一个方法即可，实例代码如下</p><h3 id="tcp："><a href="#tcp：" class="headerlink" title="tcp："></a>tcp：</h3><p>客户端：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import socket<br>SOCKET=socket<span class="hljs-selector-class">.socket</span>(socket<span class="hljs-selector-class">.AF_INET</span>,socket.SOCK_STREAM)<br><br>SOCKET<span class="hljs-selector-class">.connect</span>((<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-number">8080</span>))<br><br>SOCKET<span class="hljs-selector-class">.send</span>(<span class="hljs-string">&#x27;你就是传说中的服务器吗？我是客户端&#x27;</span><span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br>information=SOCKET<span class="hljs-selector-class">.recv</span>(<span class="hljs-number">1024</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(information.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>)<br>SOCKET<span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure><p>服务器端：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import socket<br><br>SOCKET=socket<span class="hljs-selector-class">.socket</span>(socket<span class="hljs-selector-class">.AF_INET</span>,socket.SOCK_STREAM)<br><br>SOCKET<span class="hljs-selector-class">.bind</span>((<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-number">8080</span>))<br><br>SOCKET<span class="hljs-selector-class">.listen</span>()<br><br>user,user_addr=SOCKET<span class="hljs-selector-class">.accept</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;正在处理客户端消息，客户端ip为：&#x27;</span>,user_addr)</span></span><br>information=user<span class="hljs-selector-class">.recv</span>(<span class="hljs-number">1024</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(information.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>)<br><br>user<span class="hljs-selector-class">.send</span>(<span class="hljs-string">&#x27;给客户端发送消息&#x27;</span><span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br>user<span class="hljs-selector-class">.close</span>()<br><br>SOCKET<span class="hljs-selector-class">.close</span>()<br><br></code></pre></td></tr></table></figure><h3 id="udp："><a href="#udp：" class="headerlink" title="udp："></a>udp：</h3><p>服务端：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> socket<br><span class="hljs-title">server</span>=socket.socket(socket.<span class="hljs-type">AF_INET</span>,socket.<span class="hljs-type">SOCK_DGRAM</span>)<br><span class="hljs-title">server</span>.bind((&#x27;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>&#x27;,<span class="hljs-number">8080</span>))<br><span class="hljs-title">while</span> <span class="hljs-type">True</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>,ip_addr=server.recvfrom(1024)</span><br>    print(<span class="hljs-class"><span class="hljs-keyword">data</span>.decode(&#x27;<span class="hljs-title">utf</span>-8&#x27;))</span><br>    server.sendto(<span class="hljs-class"><span class="hljs-keyword">data</span>,ip_addr)</span><br><span class="hljs-title">server</span>.close()<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import socket<br>server = socket<span class="hljs-selector-class">.socket</span>(socket<span class="hljs-selector-class">.AF_INET</span>, socket.SOCK_DGRAM)<br>while True:<br>    msg=<span class="hljs-selector-tag">input</span>(<span class="hljs-string">&#x27;&gt;&gt;&gt;:&#x27;</span>)<span class="hljs-selector-class">.strip</span>()<br>    server<span class="hljs-selector-class">.sendto</span>(msg<span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>),(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>))<br>    data, ip_addr = server<span class="hljs-selector-class">.recvfrom</span>(<span class="hljs-number">1024</span>)<br>    print(data<span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>server<span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure><h3 id="远程执行命令和粘包问题"><a href="#远程执行命令和粘包问题" class="headerlink" title="远程执行命令和粘包问题"></a>远程执行命令和粘包问题</h3><h4 id="粘包："><a href="#粘包：" class="headerlink" title="粘包："></a>粘包：</h4><p><img src="https://yinshiweiysw.github.io/images/assets.socket/image-20211104162346374.png" alt="image-20211104162346374"></p><p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流(stream)，一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢?可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。<br>        例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始,在何处结束<br>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。<br>        此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p><p>1.TCP (transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端〈客户端和服务器端）都要有—一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法(Nagle算法)，将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。<br>        2.UDP(user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，,由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头〈消息来源地址，端口等信息)，这样,对于接收端来说，就容易进行区分处理了。即面向消息的通信是有消息保护边界的。<br>        3.tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车)，那也不是空消息，udp协议会帮你封装上消息头.</p><p>例如客户端在使用recv(1024)方法接受数据时，其最大接受数据为1024个字节，但服务器端发送的数据远远大于这个值，于是客户端的缓存就会有很多数据没拿到，只有1024是真正被网卡取出缓存的，其他数据会在下一次再向客户端请求数据时拿到，第二次很明显无法拿到想要的数据，而是第一次没有读取完的数据。</p><p>客户端收数据没收干净，有残留，就会在下一次结果混淆在一起。</p><p>解决办法：</p><p>每次都将数据收完，不要让其残留在缓存里面。    </p><p>1.拿到数据的总大小total_size</p><p>2.recv_size=0,循环接收，每接收一次，recv_size+=接收的长度    </p><p>3.直到recv_size=total_size，结束循环</p><h4 id="python解决粘包（远程执行命令的代码）："><a href="#python解决粘包（远程执行命令的代码）：" class="headerlink" title="python解决粘包（远程执行命令的代码）："></a>python解决粘包（远程执行命令的代码）：</h4><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-number">1.</span>服务器端要传入其发送数据的具体字节大小到客户端（也就是头信息）<br><span class="hljs-number">2.</span>客户端接收数据时要先接收头部信息（字节大小），再根据其字节大小接收具体的数据<br><span class="hljs-meta">#subprocess为远程执行命令</span><br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">#服务器端</span><br><span class="hljs-comment">#本代码为客户端调用命令远程执行服务器端的命令</span><br>import subprocess<br><span class="hljs-built_in">from</span> <span class="hljs-built_in">socket</span> import *<br>import struct<br>server=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM)<br>server.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>))<br>server.listen(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">while</span> True:<br>    conn,client_addr=server.accept()<br><br>    <span class="hljs-keyword">while</span> True:<br>        <span class="hljs-keyword">try</span>:<br>            res=conn.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:break <span class="hljs-comment">#如果客户端输入的命令为空则推出</span><br>            obj=subprocess.Popen(res.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>                             <span class="hljs-built_in">shell</span>=True,<br>                             <span class="hljs-keyword">stdout</span>=subprocess.PIPE,<br>                             <span class="hljs-keyword">stderr</span>=subprocess.PIPE)<br>           <span class="hljs-comment">#subprocess.Popen执行命令，stdout和stderr为其正确输出以及错误输出</span><br>            <span class="hljs-keyword">stdout</span>=obj.<span class="hljs-keyword">stdout</span>.<span class="hljs-built_in">read</span>()<br>            <span class="hljs-keyword">stderr</span>=obj.<span class="hljs-keyword">stderr</span>.<span class="hljs-built_in">read</span>()<br>            total_size=<span class="hljs-built_in">len</span>(<span class="hljs-keyword">stdout</span>)+<span class="hljs-built_in">len</span>(<span class="hljs-keyword">stderr</span>) <span class="hljs-comment">#统计其输出代码的字节长度</span><br>            <span class="hljs-comment">#stdout为命令执行成功输出，stderr为执行错误的输出</span><br>            header=struct.pack(<span class="hljs-string">&#x27;i&#x27;</span>,total_size) <span class="hljs-comment">#将其长度转换为字节bytes，struct.pack 中i的固定大小为4字节，表示其客户端在拿到头部信息时，先收取4字节并解码就可以得到其服务器端传输数据的大小</span><br>            conn.<span class="hljs-built_in">send</span>(header)<br>            conn.<span class="hljs-built_in">send</span>(<span class="hljs-keyword">stdout</span>+<span class="hljs-keyword">stderr</span>)<br>        except Exception:<br>            break<br>    conn.<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#客户端</span><br>import struct<br><span class="hljs-keyword">from</span> socket import *<br><span class="hljs-attribute">client</span>=socket(AF_INET,SOCK_STREAM)<br>client.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,8080))<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-attribute">msg</span>=input(&#x27;请输入命令&#x27;).strip()<br>    <span class="hljs-keyword">if</span> len(msg) == 0:continue<br>    client.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-attribute">header</span>=client.recv(4) #拿四个字节的数据大小<br>    <span class="hljs-attribute">total_size</span>=struct.unpack(&#x27;i&#x27;,header)[0] #拿到后解码<br>    <span class="hljs-attribute">recv_size</span>=0<br>    <span class="hljs-attribute">cmd_res</span>=b&#x27;&#x27;<br>    <span class="hljs-keyword">while</span>  recv_size &lt; total_size: #如果已拿到的数据大小recv_size小于服务器发送过来的总数据大小就继续拿数据。<br>        <span class="hljs-attribute">data</span>=client.recv(1024)<br>        recv_size+=len(data)<br>        cmd_res+=data<br>        <span class="hljs-builtin-name">print</span>(data.decode(<span class="hljs-string">&#x27;gbk&#x27;</span>),<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;&#x27;</span>) #windows编码gbk<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>strut转换参数：</p><p><img src="https://yinshiweiysw.github.io/images/assets.socket/image-20211104172547839.png" alt="image-20211104172547839"></p><h4 id="解决粘包代码终极版："><a href="#解决粘包代码终极版：" class="headerlink" title="解决粘包代码终极版："></a>解决粘包代码终极版：</h4><p>（将其封装成一个字典，将字典作为头信息传递过去）</p><p>服务器端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@作者: egon老湿</span><br><span class="hljs-string">@微信:18611453110</span><br><span class="hljs-string">@专栏: https://zhuanlan.zhihu.com/c_1189883314197168128</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 服务端应该满足两个特点：</span><br><span class="hljs-comment"># 1、一直对外提供服务</span><br><span class="hljs-comment"># 2、并发地服务多个客户端</span><br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><br>server=socket(AF_INET,SOCK_STREAM)<br>server.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="hljs-number">1</span>) <span class="hljs-comment">#就是它，在bind前加</span><br>server.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8083</span>))<br>server.listen(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">#  服务端应该做两件事</span><br><span class="hljs-comment"># 第一件事：循环地从板连接池中取出链接请求与其建立双向链接，拿到链接对象</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    conn,client_addr=server.accept()<br><br>    <span class="hljs-comment"># 第二件事：拿到链接对象，与其进行通信循环</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            cmd=conn.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cmd) == <span class="hljs-number">0</span>:<span class="hljs-keyword">break</span><br>            obj=subprocess.Popen(cmd.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>                             shell=<span class="hljs-literal">True</span>,<br>                             stdout=subprocess.PIPE,<br>                             stderr=subprocess.PIPE<br>                             )<br><br>            stdout_res=obj.stdout.read()<br>            stderr_res=obj.stderr.read()<br>            total_size=<span class="hljs-built_in">len</span>(stdout_res)+<span class="hljs-built_in">len</span>(stderr_res)<br><br>            <span class="hljs-comment"># 1、制作头</span><br>            header_dic=&#123;<br>                <span class="hljs-string">&quot;filename&quot;</span>:<span class="hljs-string">&quot;a.txt&quot;</span>,<br>                <span class="hljs-string">&quot;total_size&quot;</span>:total_size,<br>                <span class="hljs-string">&quot;md5&quot;</span>:<span class="hljs-string">&quot;123123xi12ix12&quot;</span><br>            &#125;<br><br>            json_str = json.dumps(header_dic)<br>            json_str_bytes = json_str.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><br>            <span class="hljs-comment"># 2、先把头的长度发过去</span><br>            x=struct.pack(<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-built_in">len</span>(json_str_bytes))<br>            conn.send(x)<br><br>            <span class="hljs-comment"># 3、发头信息</span><br>            conn.send(json_str_bytes)<br>            <span class="hljs-comment"># 4、再发真实的数据</span><br>            conn.send(stdout_res)<br>            conn.send(stderr_res)<br><br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">break</span><br>    conn.close()<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">@作者: egon老湿</span><br><span class="hljs-string">@微信:18611453110</span><br><span class="hljs-string">@专栏: https://zhuanlan.zhihu.com/c_1189883314197168128</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span><br>import struct<br>import json<br><span class="hljs-keyword">from</span> socket import *<br><br><span class="hljs-attribute">client</span>=socket(AF_INET,SOCK_STREAM)<br>client.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,8083))<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-attribute">cmd</span>=input(&#x27;请输入命令&gt;&gt;：&#x27;).strip()<br>    <span class="hljs-keyword">if</span> len(cmd) == 0:continue<br>    client.send(cmd.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br>    # 接收端<br>    # 1、先手4个字节，从中提取接下来要收的头的长度<br>    <span class="hljs-attribute">x</span>=client.recv(4)<br>    <span class="hljs-attribute">header_len</span>=struct.unpack(&#x27;i&#x27;,x)[0]<br><br>    # 2、接收头，并解析<br>    <span class="hljs-attribute">json_str_bytes</span>=client.recv(header_len)<br>    <span class="hljs-attribute">json_str</span>=json_str_bytes.decode(&#x27;utf-8&#x27;)<br>    <span class="hljs-attribute">header_dic</span>=json.loads(json_str)<br>    <span class="hljs-builtin-name">print</span>(header_dic)<br>    <span class="hljs-attribute">total_size</span>=header_dic[<span class="hljs-string">&quot;total_size&quot;</span>]<br><br>    # 3、接收真实的数据<br>    recv_size = 0<br>    <span class="hljs-keyword">while</span> recv_size &lt; total_size:<br>        <span class="hljs-attribute">recv_data</span>=client.recv(1024)<br>        recv_size+=len(recv_data)<br>        <span class="hljs-builtin-name">print</span>(recv_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-builtin-name">print</span>()<br><br><br><span class="hljs-comment"># 粘包问题出现的原因</span><br><span class="hljs-comment"># 1、tcp是流式协议，数据像水流一样粘在一起，没有任何边界区分</span><br><span class="hljs-comment"># 2、收数据没收干净，有残留，就会下一次结果混淆在一起</span><br><br><span class="hljs-comment"># 解决的核心法门就是：每次都收干净，不要任何残留</span><br></code></pre></td></tr></table></figure><h3 id="服务端为多个客户端提供服务"><a href="#服务端为多个客户端提供服务" class="headerlink" title="服务端为多个客户端提供服务"></a>服务端为多个客户端提供服务</h3><p>从上面的代码来说，当一个服务器端处于accept()等待连接的时候，一个客户端来了这个时候代码就会继续往下面走，此时如果再来一个客户端，在请求时就会堵塞住，因为服务器端的主线程已经用于服务第一个客户端去了，无法分身服务多个客户端</p><p>解决办法：</p><p>1.socketserver </p><p>2.多线程（多进程）</p><p>这两个模块都能解决单进程服务器端的问题，其实就是服务器端把处理客户端的服务交给其他进程或线程取处理，而自己只负责与客户端连接。类似于nginx，nginx一共两个进程，master和slave，master进程仅负责接收客户端的请求，而真正与客户端通信和返回数据的是slave端。 </p><h4 id="socketserver"><a href="#socketserver" class="headerlink" title="socketserver:"></a>socketserver:</h4><p>这里用了socketserver模块，直接省略accpet以及以上监听绑定步骤（服务器端），直接用class类继承socketserver.BaseRequestHandler，然后定义handle函数，在恢复和发送数据时调用self.request.(recv or send)即可。最后生成对象，传入要监听的端口ip以及创建好的类名再运行对象即可。</p><p><strong>这里只需要创建对象时传入bind的ip+port，已经通信时调用request方法。极其简单便捷。客户端无需改变，该如何通信还是一样，服务器端除了于客户端通信的那段代码其他均为固定格式</strong></p><p>服务器端：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua">import subprocess<br>import socketserver<br>import struct<br>class MyRequestHandle(socketserver.BaseRequestHandler):<br>    def handle(<span class="hljs-built_in">self</span>):<br>        <span class="hljs-keyword">while</span> True:<br>            try:<br>                res=<span class="hljs-built_in">self</span>.request.recv(<span class="hljs-number">1024</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:<span class="hljs-keyword">break</span><br>                obj=subprocess.Popen(res.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>                                 shell=True,<br>                                 <span class="hljs-built_in">stdout</span>=subprocess.PIPE,<br>                                 <span class="hljs-built_in">stderr</span>=subprocess.PIPE)<br>                <span class="hljs-built_in">stdout</span>=obj.<span class="hljs-built_in">stdout</span>.<span class="hljs-built_in">read</span>()<br>                <span class="hljs-built_in">stderr</span>=obj.<span class="hljs-built_in">stderr</span>.<span class="hljs-built_in">read</span>()<br>                total_size=<span class="hljs-built_in">len</span>(<span class="hljs-built_in">stdout</span>)+<span class="hljs-built_in">len</span>(<span class="hljs-built_in">stderr</span>)<br>                #<span class="hljs-built_in">stdout</span>为命令执行成功输出，<span class="hljs-built_in">stderr</span>为执行错误的输出<br>                header=struct.pack(<span class="hljs-string">&#x27;i&#x27;</span>,total_size)<br>                <span class="hljs-built_in">self</span>.request.send(header)<br>                <span class="hljs-built_in">self</span>.request.send(<span class="hljs-built_in">stdout</span>+<span class="hljs-built_in">stderr</span>)<br>            except Exception:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-built_in">self</span>.request.<span class="hljs-built_in">close</span>()<br>s=socketserver.ThreadingTCPServer((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8080</span>),MyRequestHandle)<br>s.serve_forever()<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import struct<br><span class="hljs-keyword">from</span> socket import *<br><span class="hljs-attribute">client</span>=socket(AF_INET,SOCK_STREAM)<br>client.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,8080))<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-attribute">msg</span>=input(&#x27;请输入命令&#x27;).strip()<br>    <span class="hljs-keyword">if</span> len(msg) == 0:continue<br>    client.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-attribute">header</span>=client.recv(4)<br>    <span class="hljs-attribute">total_size</span>=struct.unpack(&#x27;i&#x27;,header)[0]<br>    <span class="hljs-attribute">recv_size</span>=0<br>    <span class="hljs-attribute">cmd_res</span>=b&#x27;&#x27;<br>    <span class="hljs-keyword">while</span>  recv_size &lt; total_size:<br>        <span class="hljs-attribute">data</span>=client.recv(1024)<br>        recv_size+=len(data)<br>        cmd_res+=data<br>        <span class="hljs-builtin-name">print</span>(data.decode(<span class="hljs-string">&#x27;gbk&#x27;</span>),<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h5 id="服务器端代码模板："><a href="#服务器端代码模板：" class="headerlink" title="服务器端代码模板："></a>服务器端代码模板：</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> socketserver<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">MyRequestHandle</span>(<span class="hljs-title">socketserver</span>.<span class="hljs-type">BaseRequestHandler</span>):</span><br><span class="hljs-class">    def handle(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        while <span class="hljs-type">True</span>:</span><br><span class="hljs-class">主代码（于客户端通信的代码）</span><br><span class="hljs-class">        self.request.close() #（关闭套接字代码）</span><br><span class="hljs-class">s=socketserver.<span class="hljs-type">ThreadingTCPServer</span>((&#x27;127.0.0.1&#x27;,8080),<span class="hljs-type">MyRequestHandle</span>)</span><br><span class="hljs-class">s.serve_forever()</span><br></code></pre></td></tr></table></figure><h4 id="多线程实现："><a href="#多线程实现：" class="headerlink" title="多线程实现："></a>多线程实现：</h4><p>多线程与多进程都可以实现，这里导入多线程模块，把accpet接收到的客户端对象以下代码全部交与线程来做就可以了。（多进程也可以实现，但一般用多线程即可。）这里用threading模块</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import <span class="hljs-built_in">socket</span><br>import threading<br>import struct<br>import subprocess<br><span class="hljs-comment"># 处理客户端请求的任务</span><br>def handle_client_request(ip_port, new_client):<br>print(<span class="hljs-string">&quot;客户端的ip和端口号为:&quot;</span>, ip_port)<br><span class="hljs-comment"># 5. 接收客户端的数据</span><br><span class="hljs-comment"># 收发消息都使用返回的这个新的套接字</span><br><span class="hljs-comment"># 循环接收客户端的消息</span><br><span class="hljs-keyword">while</span> True:<br>recv_data = new_client.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-keyword">if</span> recv_data == <span class="hljs-string">&#x27;quit&#x27;</span>:<br>new_client.<span class="hljs-built_in">close</span>()<br>break<br>elif recv_data:<br>obj = subprocess.Popen(recv_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>   <span class="hljs-built_in">shell</span>=True,<br>   <span class="hljs-keyword">stdout</span>=subprocess.PIPE,<br>   <span class="hljs-keyword">stderr</span>=subprocess.PIPE)<br><span class="hljs-keyword">stdout</span> = obj.<span class="hljs-keyword">stdout</span>.<span class="hljs-built_in">read</span>()<br><span class="hljs-keyword">stderr</span> = obj.<span class="hljs-keyword">stderr</span>.<span class="hljs-built_in">read</span>()<br>total_size = <span class="hljs-built_in">len</span>(<span class="hljs-keyword">stdout</span>) + <span class="hljs-built_in">len</span>(<span class="hljs-keyword">stderr</span>)<br>total_size = struct.pack(<span class="hljs-string">&quot;i&quot;</span>,total_size)<br>new_client.<span class="hljs-built_in">send</span>(total_size)<br>new_client.<span class="hljs-built_in">send</span>(<span class="hljs-keyword">stdout</span>)<br>new_client.<span class="hljs-built_in">send</span>(<span class="hljs-keyword">stderr</span>)<br><span class="hljs-keyword">else</span>:<br>break<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><span class="hljs-comment"># 1. 创建tcp服务端套接字</span><br><span class="hljs-comment"># AF_INET: ipv4 , AF_INET6: ipv6</span><br>tcp_server_socket = <span class="hljs-built_in">socket</span>.<span class="hljs-built_in">socket</span>(<span class="hljs-built_in">socket</span>.AF_INET, <span class="hljs-built_in">socket</span>.SOCK_STREAM)<br><span class="hljs-comment"># 设置端口号复用，表示意思： 服务端程序退出端口号立即释放</span><br><span class="hljs-comment"># 1. SOL_SOCKET: 表示当前套接字</span><br><span class="hljs-comment"># 2. SO_REUSEADDR： 表示复用端口号的选项</span><br><span class="hljs-comment"># 3. True： 确定复用</span><br>tcp_server_socket.setsockopt(<span class="hljs-built_in">socket</span>.SOL_SOCKET, <span class="hljs-built_in">socket</span>.SO_REUSEADDR, True)<br><span class="hljs-comment"># 2. 绑定端口号</span><br><span class="hljs-comment"># 第一个参数表示ip地址，一般不用指定，表示本机的任何一个ip即可</span><br><span class="hljs-comment"># 第二个参数表示端口号</span><br>tcp_server_socket.bind((<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">8080</span>))<br><span class="hljs-comment"># 3. 设置监听</span><br><span class="hljs-comment"># 128: 表示最大等待建立连接的个数</span><br>tcp_server_socket.listen(<span class="hljs-number">128</span>)<br><span class="hljs-comment"># 4. 等待接受客户端的连接请求</span><br><span class="hljs-comment"># 注意点： 每次当客户端和服务端建立连接成功都会返回一个新的套接字</span><br><span class="hljs-comment"># tcp_server_socket只负责等待接收客户端的连接请求，收发消息不使用该套接字</span><br><span class="hljs-comment"># 循环等待接受客户端的连接请求</span><br><span class="hljs-keyword">while</span> True:<br>new_client, ip_port = tcp_server_socket.accept()<br><span class="hljs-comment"># 代码执行到此，说明客户端和服务端建立连接成功</span><br><span class="hljs-comment"># 当客户端和服务端建立连接成功，创建子线程，让子线程专门负责接收客户端的消息</span><br>sub_thread = threading.Thread(target=handle_client_request, args=(ip_port, new_client))<br><span class="hljs-comment"># 设置守护主线程，主线程退出子线程直接销毁</span><br>sub_thread.setDaemon(True)<br><span class="hljs-comment"># 启动子线程执行对应的任务</span><br>sub_thread.<span class="hljs-built_in">start</span>()<br><span class="hljs-comment"># 7. 关闭服务端套接字， 表示服务端以后不再等待接受客户端的连接请求</span><br><span class="hljs-comment"># tcp_server_socket.close()  # 因为服务端的程序需要一直运行，所以关闭服务端套接字的代码可以省略不写</span><br></code></pre></td></tr></table></figure><p>上面为服务端代码，客户端不变，仅为实现服务端多线程</p><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> subprocess<br>def handle_client_request(ip_port, <span class="hljs-keyword">new</span><span class="hljs-type">_client</span>):<span class="hljs-type"></span><br><span class="hljs-keyword">while</span> True:<span class="hljs-type"></span><br><span class="hljs-meta">#主代码部分</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<span class="hljs-type"></span><br>tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)<br>tcp_server_socket.bind((<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">8080</span>))<br>tcp_server_socket.listen(<span class="hljs-number">128</span>)<br><span class="hljs-keyword">while</span> True:<span class="hljs-type"></span><br><span class="hljs-keyword">new</span><span class="hljs-type">_client</span>, ip_port = tcp_server_socket.accept()<br>sub_thread = threading.Thread(target=handle_client_request, args=(ip_port, <span class="hljs-keyword">new</span><span class="hljs-type">_client</span>))<br>sub_thread.setDaemon(True)<br>sub_thread.start()<br><span class="hljs-meta"># tcp_server_socket.close() </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python异常</title>
    <link href="/2021/11/01/python%E5%BC%82%E5%B8%B8_hexo/"/>
    <url>/2021/11/01/python%E5%BC%82%E5%B8%B8_hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h2><p>异常是程序发生错误的信号，程序一旦出错就会抛出异常，从而导致程序运行的终止。</p><p>异常处理：</p><p>捕捉其异常，使其在程序出错时执行某些操作或打印记录日志或反馈某些信息，而非直接终止运行。</p><p>异常处理的特征：</p><p>异常的追踪信息，异常的类型，异常的内容。</p><h2 id="异常问题以及其处理方式："><a href="#异常问题以及其处理方式：" class="headerlink" title="异常问题以及其处理方式："></a>异常问题以及其处理方式：</h2><p> 语法上的错误：“SyntaxError”,</p><p>处理方式:必须在程序运行前就改正</p><p>if 1&gt;3<br>                print( “run. . . “)</p><p>逻辑上的错误：</p><p>例如：dic={‘name’:’saf’}</p><p>​            dic[‘age’]</p><p>针对逻辑上的异常又分为两种处理方式</p><p>​    1.错误的发生可以预知：        </p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">age</span>=<span class="hljs-function"><span class="hljs-title">input</span>(<span class="hljs-string">&#x27;请输入年龄&#x27;</span>).strip()</span><br><span class="hljs-variable">age</span>=<span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-variable">age</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">age</span> &gt; <span class="hljs-number">18</span>:<br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;猜大了&#x27;</span>)</span><br><span class="hljs-variable">elif</span> <span class="hljs-variable">age</span> &lt; <span class="hljs-number">18</span>:<br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;猜小了&#x27;</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;猜对了&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>本代码中的逻辑漏洞在于，如果这里输入的不是数字而是字母或字符串，在进行数字大小比较时，就会出错，属于代码逻辑错误，可以预知。</p><p>2.无法预知的错误：</p><p>这时只能使用</p><p>try函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>  <span class="hljs-comment"># 主代码块</span><br>  <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> KeyError,e:<br>  <span class="hljs-comment"># 异常时，执行该块</span><br>  <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>  <span class="hljs-comment"># 主代码块执行完，执行该块</span><br>  <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">finally</span>:<br>  <span class="hljs-comment"># 无论异常与否，最终执行该块</span><br>  <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>常见异常：</p><p>​    IndexError,NameError,KeyError 等</p><p>​    第一个对应集合索引名错误，第二个对应运行的命令名错误，第三个为字典错误。每一种错误</p><p>python所有的标准异常类：</p><table><thead><tr><th align="left">异常名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">BaseException</td><td align="left">所有异常的基类</td></tr><tr><td align="left">SystemExit</td><td align="left">解释器请求退出</td></tr><tr><td align="left">KeyboardInterrupt</td><td align="left">用户中断执行(通常是输入^C)</td></tr><tr><td align="left">Exception</td><td align="left">常规错误的基类</td></tr><tr><td align="left">StopIteration</td><td align="left">迭代器没有更多的值</td></tr><tr><td align="left">GeneratorExit</td><td align="left">生成器(generator)发生异常来通知退出</td></tr><tr><td align="left">SystemExit</td><td align="left">Python 解释器请求退出</td></tr><tr><td align="left">StandardError</td><td align="left">所有的内建标准异常的基类</td></tr><tr><td align="left">ArithmeticError</td><td align="left">所有数值计算错误的基类</td></tr><tr><td align="left">FloatingPointError</td><td align="left">浮点计算错误</td></tr><tr><td align="left">OverflowError</td><td align="left">数值运算超出最大限制</td></tr><tr><td align="left">ZeroDivisionError</td><td align="left">除(或取模)零 (所有数据类型)</td></tr><tr><td align="left">AssertionError</td><td align="left">断言语句失败</td></tr><tr><td align="left">AttributeError</td><td align="left">对象没有这个属性</td></tr><tr><td align="left">EOFError</td><td align="left">没有内建输入,到达EOF 标记</td></tr><tr><td align="left">EnvironmentError</td><td align="left">操作系统错误的基类</td></tr><tr><td align="left">IOError</td><td align="left">输入/输出操作失败</td></tr><tr><td align="left">OSError</td><td align="left">操作系统错误</td></tr><tr><td align="left">WindowsError</td><td align="left">系统调用失败</td></tr><tr><td align="left">ImportError</td><td align="left">导入模块/对象失败</td></tr><tr><td align="left">KeyboardInterrupt</td><td align="left">用户中断执行(通常是输入^C)</td></tr><tr><td align="left">LookupError</td><td align="left">无效数据查询的基类</td></tr><tr><td align="left">IndexError</td><td align="left">序列中没有没有此索引(index)</td></tr><tr><td align="left">KeyError</td><td align="left">映射中没有这个键</td></tr><tr><td align="left">MemoryError</td><td align="left">内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td align="left">NameError</td><td align="left">未声明/初始化对象 (没有属性)</td></tr><tr><td align="left">UnboundLocalError</td><td align="left">访问未初始化的本地变量</td></tr><tr><td align="left">ReferenceError</td><td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td align="left">RuntimeError</td><td align="left">一般的运行时错误</td></tr><tr><td align="left">NotImplementedError</td><td align="left">尚未实现的方法</td></tr><tr><td align="left">SyntaxError</td><td align="left">Python 语法错误</td></tr><tr><td align="left">IndentationError</td><td align="left">缩进错误</td></tr><tr><td align="left">TabError</td><td align="left">Tab 和空格混用</td></tr><tr><td align="left">SystemError</td><td align="left">一般的解释器系统错误</td></tr><tr><td align="left">TypeError</td><td align="left">对类型无效的操作</td></tr><tr><td align="left">ValueError</td><td align="left">传入无效的参数</td></tr><tr><td align="left">UnicodeError</td><td align="left">Unicode 相关的错误</td></tr><tr><td align="left">UnicodeDecodeError</td><td align="left">Unicode 解码时的错误</td></tr><tr><td align="left">UnicodeEncodeError</td><td align="left">Unicode 编码时错误</td></tr><tr><td align="left">UnicodeTranslateError</td><td align="left">Unicode 转换时错误</td></tr><tr><td align="left">Warning</td><td align="left">警告的基类</td></tr><tr><td align="left">DeprecationWarning</td><td align="left">关于被弃用的特征的警告</td></tr><tr><td align="left">FutureWarning</td><td align="left">关于构造将来语义会有改变的警告</td></tr><tr><td align="left">OverflowWarning</td><td align="left">旧的关于自动提升为长整型(long)的警告</td></tr><tr><td align="left">PendingDeprecationWarning</td><td align="left">关于特性将会被废弃的警告</td></tr><tr><td align="left">RuntimeWarning</td><td align="left">可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td align="left">SyntaxWarning</td><td align="left">可疑的语法的警告</td></tr><tr><td align="left">UserWarning</td><td align="left">用户代码生成的警告</td></tr></tbody></table><p>无法判断具体错误的情况可以使用捕捉所有异常：</p><p>Exception或BaseException</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议（转）</title>
    <link href="/2021/11/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_hexo/"/>
    <url>/2021/11/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="网络基础之网络协议篇"><a href="#网络基础之网络协议篇" class="headerlink" title="网络基础之网络协议篇"></a>网络基础之网络协议篇</h1><p>本文转自<a href="https://www.cnblogs.com/linhaifeng/articles/5937962.html">https://www.cnblogs.com/linhaifeng/articles/5937962.html</a></p><h1 id="一-操作系统基础"><a href="#一-操作系统基础" class="headerlink" title="一.操作系统基础"></a>一.操作系统基础</h1><p> 操作系统:(Operating System，简称OS)是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。</p><p>注：计算机(硬件)－&gt;os－&gt;应用软件</p><h1 id="二-网络通信原理"><a href="#二-网络通信原理" class="headerlink" title="二.网络通信原理"></a>二.网络通信原理</h1><h2 id="2-1-互联网的本质就是一系列的网络协议"><a href="#2-1-互联网的本质就是一系列的网络协议" class="headerlink" title="2.1 互联网的本质就是一系列的网络协议"></a>2.1 互联网的本质就是一系列的网络协议</h2><p>一台硬设有了操作系统，然后装上软件你就可以正常使用了，然而你也只能自己使用</p><p>像这样，每个人都拥有一台自己的机器，然而彼此孤立</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008115246442-867569611.png" alt="img"></p><p>如何能大家一起玩耍</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008115341598-934171433.png" alt="img"></p><p>然而internet为何物？</p><p>其实两台计算机之间通信与两个人打电话之间通信的原理是一样的（中国有很多地区，不同的地区有不同的方言，为了全中国人都可以听懂，大家统一讲普通话）</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008131010254-430615122.png" alt="img"></p><p>普通话属于中国国内人与人之间通信的标准，那如果是两个国家的人交流呢？</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008131301051-196580728.png" alt="img"></p><p>问题是，你不可能要求一个人／计算机掌握全世界的语言／标准，于是有了世界统一的通信标准：英语</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008131410957-1579746437.png" alt="img"></p><p>结论：英语成为世界上所有人通信的统一标准，如果把计算机看成分布于世界各地的人，那么连接两台计算机之间的internet实际上就是</p><p>一系列统一的标准，这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为‘互联网协议’（Internet Protocol Suite).</p><p>互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。</p><h2 id="2-2-osi七层协议"><a href="#2-2-osi七层协议" class="headerlink" title="2.2 osi七层协议"></a>2.2 osi七层协议</h2><p>互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008145544426-736439132.png" alt="img"></p><p>每层运行常见物理设备</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008144925254-1398507493.png" alt="img"></p><p>OSI七层协议数据传输的封包与解包过程 </p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20200415215541847-564448301.gif" alt="img"></p><h2 id="2-3-tcp-ip五层模型讲解"><a href="#2-3-tcp-ip五层模型讲解" class="headerlink" title="2.3 tcp/ip五层模型讲解"></a>2.3 tcp/ip五层模型讲解</h2><p>我们将应用层，表示层，会话层并作应用层，从tcp／ip五层协议的角度来阐述每层的由来与功能，搞清楚了每层的主要协议</p><p>就理解了整个互联网通信的原理。</p><p>首先，用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解</p><p>每层都运行特定的协议，越往上越靠近用户，越往下越靠近硬件</p><h3 id="2-3-1-物理层"><a href="#2-3-1-物理层" class="headerlink" title="2.3.1 物理层"></a>2.3.1 物理层</h3><p>物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008154500754-704720294.png" alt="img"></p><p>物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0</p><h3 id="2-3-2-数据链路层"><a href="#2-3-2-数据链路层" class="headerlink" title="2.3.2 数据链路层"></a>2.3.2 数据链路层</h3><p>数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思</p><p>数据链路层的功能：定义了电信号的分组方式</p><p><em><strong>以太网协议：</strong></em></p><p>早期的时候各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议ethernet</p><p>ethernet规定</p><ul><li>一组电信号构成一个数据包，叫做‘帧’</li><li>每一数据帧分成：报头head和数据data两部分</li></ul><table><thead><tr><th>head</th><th>data</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>head包含：(固定18个字节)</p><ul><li>发送者／源地址，6个字节</li><li>接收者／目标地址，6个字节</li><li>数据类型，6个字节</li></ul><p>data包含：(最短46字节，最长1500字节)</p><ul><li>数据包的具体内容</li></ul><p>head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送</p><p><em><strong>mac地址：</strong></em></p><p>head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址</p><p>mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008164852129-1597186542.png" alt="img"></p><p>*<strong>广播：*</strong></p><p>有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）</p><p>ethernet采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008171118317-164674895.png" alt="img"></p><h3 id="2-3-3-网络层"><a href="#2-3-3-网络层" class="headerlink" title="2.3.3 网络层"></a>2.3.3 网络层</h3><p>网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由</p><p>一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，</p><p>这就不仅仅是效率低的问题了，这会是一种灾难</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008172732957-102296982.png" alt="img"></p><p>上图结论：必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是，如果是就采用广播的方式发送，如果不是，</p><p>就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关</p><p>网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址</p><p><em><strong>IP协议：</strong></em></p><ul><li>规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示</li><li>范围0.0.0.0-255.255.255.255</li><li>一个ip地址通常写成四段十进制数，例：172.16.10.1</li></ul><p>*<strong>ip地址分成两部分*</strong></p><ul><li>网络部分：标识子网</li><li>主机部分：标识主机</li></ul><p>注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网</p><p>例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网</p><p><em><strong>子网掩码</strong></em></p><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，</p><p>172.16.10.1：10101100.00010000.00001010.000000001</p><p>255255.255.255.0:11111111.11111111.11111111.00000000</p><p>AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p><p>172.16.10.2：10101100.00010000.00001010.000000010</p><p>255255.255.255.0:11111111.11111111.11111111.00000000</p><p>AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p><p>结果都是172.16.10.0，因此它们在同一个子网络。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><p><em><strong>ip数据包</strong></em></p><p>ip数据包也分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分</p><p>head：长度为20到60字节</p><p>data：最长为65,515字节。</p><p>而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><table><thead><tr><th>以太网头</th><th>ip 头</th><th>ip数据</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p> <em><strong>ARP协议</strong></em></p><p>arp协议由来：计算机通信基本靠吼，即广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，在谈及以太网协议时候，我门了解到</p><p>通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议</p><p>arp协议功能：广播的方式发送数据包，获取目标主机的mac地址</p><p>协议工作方式：每台主机ip都是已知的</p><p>例如：主机172.16.10.10/24访问172.16.10.11/24</p><p>一：首先通过ip地址和子网掩码区分出自己所处的子网</p><table><thead><tr><th>场景</th><th>数据包地址</th></tr></thead><tbody><tr><td>同一子网</td><td>目标主机mac，目标主机ip</td></tr><tr><td>不同子网</td><td>网关mac，目标主机ip</td></tr></tbody></table><p>二：分析172.16.10.10/24与172.16.10.11/24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac)</p><table><thead><tr><th></th><th>源mac</th><th>目标mac</th><th>源ip</th><th>目标ip</th><th>数据部分</th></tr></thead><tbody><tr><td>发送端主机</td><td>发送端mac</td><td>FF:FF:FF:FF:FF:FF</td><td>172.16.10.10/24</td><td>172.16.10.11/24</td><td>数据</td></tr></tbody></table><p>三：这个包会以广播的方式在发送端所处的自网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac</p><h3 id="2-3-4-传输层"><a href="#2-3-4-传输层" class="headerlink" title="2.3.4 传输层"></a>2.3.4 传输层</h3><p>传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，</p><p>那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。</p><p>传输层功能：建立端口到端口的通信</p><p>补充：端口范围0-65535，0-1023为系统占用端口</p><p>tcp协议：</p><p>可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><table><thead><tr><th>以太网头</th><th>ip 头</th><th>tcp头</th><th>数据</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>udp协议：</p><p>不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><table><thead><tr><th>以太网头</th><th>ip头</th><th>udp头</th><th>数据</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>tcp报文</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008185553973-1895926477.png" alt="img"></p><p>tcp三次握手和四次挥手</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008185648160-191189690.png" alt="img"></p><h3 id="2-3-5-应用层"><a href="#2-3-5-应用层" class="headerlink" title="2.3.5 应用层"></a>2.3.5 应用层</h3><p>应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 </p><p>应用层功能：规定应用程序的数据格式。</p><p>例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p> <img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161008190023098-992049015.png" alt="img"></p><h3 id="2-3-6-socket"><a href="#2-3-6-socket" class="headerlink" title="2.3.6 socket"></a>2.3.6 socket</h3><p>我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。</p><p>能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20161013091647484-1707663286.png" alt="img"></p><p>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7 小结"></a>2.3.7 小结</h3><p><strong>总结图如下：</strong></p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20200415222138157-249976328.png" alt="img"></p><p><strong>数据传输动图如下：</strong></p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20200415220004538-1827984001.gif" alt="img"></p><h1 id="三-网络通信实现"><a href="#三-网络通信实现" class="headerlink" title="三.网络通信实现"></a>三.网络通信实现</h1><p>想实现网络通信，每台主机需具备四要素</p><ul><li>本机的IP地址</li><li>子网掩码</li><li>网关的IP地址</li><li>DNS的IP地址</li></ul><p>获取这四要素分两种方式</p><p>1.静态获取</p><p>即手动配置</p><p>2.动态获取</p><p>通过dhcp获取</p><table><thead><tr><th>以太网头</th><th>ip头</th><th>udp头</th><th>dhcp数据包</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数</p><h1 id="四-DNS域名解析"><a href="#四-DNS域名解析" class="headerlink" title="四.DNS域名解析"></a>四.DNS域名解析</h1><h3 id="4-1-dns的作用"><a href="#4-1-dns的作用" class="headerlink" title="4.1 dns的作用"></a>4.1 dns的作用</h3><p>DNS的作用：在互联网中，其实没有类似于<a href="http://www.xxx.com/">www.xxx.com</a>这种域名方式，而替代的是以IP地址，如222.222.222.222，那我们在IE地址栏中应当输入222.222.222.222才能打开网站<a href="http://www.xxx.com,但我们细想一下,互联网上的网站成千上万,如果每个网站登陆都需要记住一大串数字,那是不是特别不方便,对于记忆力不强的人,根本无法记住这么烦琐的数字.这个时候dns就出现了,它的作用就是将222.222.222.222解析为www.xxx.com,那么我们登陆的时候就直接输入域名就可以了./">www.xxx.com，但我们细想一下，互联网上的网站成千上万，如果每个网站登陆都需要记住一大串数字，那是不是特别不方便，对于记忆力不强的人，根本无法记住这么烦琐的数字。这个时候DNS就出现了，它的作用就是将222.222.222.222解析为www.xxx.com，那么我们登陆的时候就直接输入域名就可以了。</a></p><p>为什么一定要设置DNS才能上网？有些朋友可能会发现，为什么我可能登陆QQ、MSN，但却打不开网页呢？其实大部分原因都是因为DNS服务器故障造成的，DNS服务器地址是唯一的，是运营商提供给终端用户用来解析IP地址及域名的关系，而如果不设定DNS服务器地址，那么就无法查询地址的去向，自然也就打不开网页，而QQ、MSN等即时聊天软件，采用的是UDP传输协议，即不可靠传输协议，无需提供DNS服务器地址，也同样可以登陆。</p><h3 id="4-2-dns的两种查询方式"><a href="#4-2-dns的两种查询方式" class="headerlink" title="4.2 dns的两种查询方式"></a>4.2 dns的两种查询方式</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">#一 ：递归</span><br>主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的<span class="hljs-built_in">IP</span>地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的<span class="hljs-built_in">IP</span>地址，或者是报错，表示无法查询到所需的<span class="hljs-built_in">IP</span>地址。<br><br><span class="hljs-comment"># 二：迭代</span><br>本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的<span class="hljs-built_in">IP</span>地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的<span class="hljs-built_in">IP</span>地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的<span class="hljs-built_in">IP</span>地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的<span class="hljs-built_in">IP</span>地址或报错，然后把这个结果返回给发起查询的主机。 <br></code></pre></td></tr></table></figure><p>下图给出了这两种查询的差别</p><p>图1</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20201012174443242-1565501096.png" alt="img"></p><p>图2</p><p> <img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20201012174541729-1246240693.png" alt="img"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vim">#下面举一个例子演示整个查询过程：<br><br>        假定域名为<span class="hljs-keyword">m</span>.xyz.<span class="hljs-keyword">com</span>的主机想知道另一个主机<span class="hljs-keyword">y</span>.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>的IP地址。例如，主机<span class="hljs-keyword">m</span>.xyz.<span class="hljs-keyword">com</span>打算发送邮件给<span class="hljs-keyword">y</span>.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>。这时就必须知道主机<span class="hljs-keyword">y</span>.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>的IP地址。下面是图<span class="hljs-number">2</span>的几个查询步骤：<br><br>        <span class="hljs-number">1</span>、主机<span class="hljs-keyword">m</span>.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>先向本地服务器dns.xyz.<span class="hljs-keyword">com</span>进行递归查询。<br><br>        <span class="hljs-number">2</span>、本地服务器采用迭代查询。它先向一个根域名服务器查询。<br><br>        <span class="hljs-number">3</span>、根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.<span class="hljs-keyword">com</span>的IP地址。<br><br>        <span class="hljs-number">4</span>、本地域名服务器向顶级域名服务器dns.<span class="hljs-keyword">com</span>进行查询。<br><br>        <span class="hljs-number">5</span>、顶级域名服务器dns.<span class="hljs-keyword">com</span>告诉本地域名服务器，下一步应查询的权限服务器dns.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>的IP地址。<br><br>        <span class="hljs-number">6</span>、本地域名服务器向权限域名服务器dns.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>进行查询。<br><br>        <span class="hljs-number">7</span>、权限域名服务器dns.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>告诉本地域名服务器，所查询的主机的IP地址。<br><br>        <span class="hljs-number">8</span>、本地域名服务器最后把查询结果告诉<span class="hljs-keyword">m</span>.xyz.<span class="hljs-keyword">com</span>。<br><br>        # 整个查询过程共用到了<span class="hljs-number">8</span>个UDP报文。<br><br>        为了提高DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。<br><br>        例如，在上面的查询过程中，如果在<span class="hljs-keyword">m</span>.xyz.<span class="hljs-keyword">com</span>的主机上不久前已经有用户查询过<span class="hljs-keyword">y</span>.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>的IP地址，那么本地域名服务器就不必向根域名服务器重新查询<span class="hljs-keyword">y</span>.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>的IP地址，而是直接把告诉缓存中存放的上次查询结果(即<span class="hljs-keyword">y</span>.<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>的IP地址)告诉用户。<br><br>        由于名字到地址的绑定并不经常改变，为保持告诉缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项(例如每个项目两天)。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。<br><br>        不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。<br></code></pre></td></tr></table></figure><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20201012174943786-1550814066.png" alt="img"></p><h3 id="4-3-DNS解析流程举例"><a href="#4-3-DNS解析流程举例" class="headerlink" title="4.3 DNS解析流程举例"></a>4.3 DNS解析流程举例</h3><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20201012175307563-473595213.png" alt="img"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">如上图所示，我们将详细阐述DNS解析流程。<br><br><span class="hljs-number">1</span>、首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入http:<span class="hljs-regexp">//</span>www.zdns.cn的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根请求http:<span class="hljs-regexp">//</span>www.zdns.cn的时候，根服务器就会返回.cn服务器的位置信息。<br><br><span class="hljs-number">2</span>、递归服务器拿到.cn的权威服务器地址以后，就会寻问cn的权威服务器，知不知道http:<span class="hljs-regexp">//</span>www.zdns.cn的位置。这个时候cn权威服务器查找并返回http:<span class="hljs-regexp">//</span>zdns.cn服务器的地址。<br><br><span class="hljs-number">3</span>、继续向http:<span class="hljs-regexp">//</span>zdns.cn的权威服务器去查询这个地址，由http:<span class="hljs-regexp">//</span>zdns.cn的服务器给出了地址：<span class="hljs-number">202.173</span>.<span class="hljs-number">11.10</span><br><br><span class="hljs-number">4</span>、最终才能进行http的链接，顺利访问网站。<br><br><span class="hljs-number">5</span>、这里补充说明，一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把http:<span class="hljs-regexp">//</span>www.zdns.cn的A记录返回给客户端就可以了。<br></code></pre></td></tr></table></figure><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/ContractedBlock.gif" alt="img"> 了解：DNS查询类型</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/ContractedBlock.gif" alt="img"> 了解：DNS资源记录</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20201012175158975-374415105.png" alt="img"></p><h3 id="4-4-DNS缓存"><a href="#4-4-DNS缓存" class="headerlink" title="4.4 DNS缓存"></a>4.4 DNS缓存</h3><p>DNS缓存指DNS返回了正确的IP之后，系统就会将这个结果临时储存起来。并且它会为缓存设定一个失效时间 (例如N小时)，在这N小时之内，当你再次访问这个网站时，系统就会直接从你电脑本地的DNS缓存中把结果交还给你，而不必再去询问DNS服务器，变相“加速”了网址的解析。</p><p>当然，在超过N小时之后，系统会自动再次去询问DNS服务器获得新的结果。所以，当你修改了 DNS 服务器，并且不希望电脑继续使用之前的DNS缓存时，就需要手动去清除本地的缓存了。</p><h3 id="4-5-DNS缓存分类"><a href="#4-5-DNS缓存分类" class="headerlink" title="4.5 DNS缓存分类"></a>4.5 DNS缓存分类</h3><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">1）浏览器DNS缓存（内存中)</span>: 浏览器会按照一定频率缓存DNS记录<br><br><span class="hljs-attribute">2）本地操作系统DNS缓存(内存中)</span>: 如果浏览器缓存中找不到需要的DNS记录，那就去操作系统找。<br><br><span class="hljs-attribute">3）本地HOSTS文件（硬盘中）</span>: Windows系统中位于C:\Windows\System32\drivers\etc<br><br><span class="hljs-attribute">4）路由器指定的DNS(远程)</span>: 路由器自动获取DNS地址，也可以手动修改-登录后台设置DNS服务器地址<br>　　ps：路由器DNS被篡改会造成域名劫持，你访问的网址都会被定位到同一个位置，但是IP直接可以访问<br><br><span class="hljs-attribute">5）ISP的DNS服务器（远程）</span>:  ISP(Internet Service Provider互联网服务提供商、联通电信移动)，ISP有专门的DNS服务器应 对DNS查询请求 6）根服务器（远程，跨国）: ISP的DNS服务器还找不到的话，它就会向根服务器发出查询请求<br></code></pre></td></tr></table></figure><p>调用系统缓存需要跨进程，消耗大，因此为了解析速度的方便，就有了一系列缓存来加快IP查找速度。 </p><h3 id="4-6-浏览器DNS查找顺序"><a href="#4-6-浏览器DNS查找顺序" class="headerlink" title="4.6 浏览器DNS查找顺序"></a>4.6 浏览器DNS查找顺序</h3><p><strong>浏览器DNS缓存-&gt;本地系统DNS缓存-&gt;本地计算机HOSTS文件-&gt;ISP DNS缓存-&gt;递归or迭代搜索</strong></p><p>期间如果查询到了，也就直接访问ip地址了，这个就像三级缓存原理一样，例如，能够在hosts文件中找到就不会再去查其他的</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/1036857-20201012181341361-436742942.png" alt="img"></p><h3 id="4-7-清除DNS缓存"><a href="#4-7-清除DNS缓存" class="headerlink" title="4.7 清除DNS缓存"></a>4.7 清除DNS缓存</h3><p>打开cmd执行命令：ipconfig /all</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">全国通用DNS地址（国内用户推荐使用，速度较快！）<br>首先DNS服务器地址添：<span class="hljs-number">114.114.114.114</span>  (位于北京人民英雄纪念碑）<br>备用DNS服务器地址添：<span class="hljs-number">114.114.115.115</span><br>全球通用DNS地址（此DNS地址为谷歌服务器的）<br>首选DNS服务器地址添：<span class="hljs-number">8.8.8.8</span><br>备用DNS服务器地址添：<span class="hljs-number">8.8.4.4</span><br></code></pre></td></tr></table></figure><p>查看本地dns缓存命令：ipconfig /displaydns</p><p>清除本地dns缓存命令：ipconfig /flushdns</p><p>清除浏览器缓存：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">我们在开发的时候，有时候会给某个域名绑hosts，用于本地开发测试，但是绑了之后，用谷歌浏览器访问会发现并没有生效，按F12会发现访问的还是线上的ip，说明浏览器是有该域名的dns缓存的，那么如何清除浏览器的dns缓存呢？<br><br><span class="hljs-comment"># 1、针对谷歌浏览器</span><br>谷歌浏览器清除方法如下：打开浏览器，访问如下地址<br>chrome:<span class="hljs-regexp">//</span>net-internals/<span class="hljs-comment">#dns</span><br><br>点击 clear host cache，就清楚了浏览器的dns缓存，再访问绑hosts的域名，就会发现ip变啦<br><br><span class="hljs-comment"># 2、针对火狐浏览器</span><br>如果是firefox火狐浏览器的话，可以按照以下方式：<br><br>在地址栏中 about:config 并回车，可能会出现一个警告信息，直接点击按钮进入，会出现firefox的所有配置信息，通过搜索dns 进行过滤，可以看到一项名为 network.dnsCacheExpirationGracePeriod 项，它对应的值就是DNS缓存的时间，双击此项，会出现修改的提示框，填入 <span class="hljs-number">0</span> （不缓存DNS）即可。<br></code></pre></td></tr></table></figure><h3 id="4-8-其他了解"><a href="#4-8-其他了解" class="headerlink" title="4.8 其他了解"></a>4.8 其他了解</h3><p>13台根dns：</p><p>A.root-servers.net198.41.0.4美国<br>B.root-servers.net192.228.79.201美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0">IPv6</a>）<br>C.root-servers.net192.33.4.12法国<br>D.root-servers.net128.8.10.90美国<br>E.root-servers.net192.203.230.10美国<br>F.root-servers.net192.5.5.241美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0">IPv6</a>）<br>G.root-servers.net192.112.36.4美国<br>H.root-servers.net128.63.2.53美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0">IPv6</a>）<br>I.root-servers.net192.36.148.17瑞典<br>J.root-servers.net192.58.128.30美国<br>K.root-servers.net193.0.14.129英国（另支持IPv6）<br>L.root-servers.net198.32.64.12美国<br>M.root-servers.net202.12.27.33日本（另支持IPv6）</p><p>域名定义：<a href="http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html">http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html</a></p><p>顶级域名：以.com,.net,.org,.cn等等属于国际顶级域名，根据目前的国际互联网域名体系，国际顶级域名分为两类：类别顶级域名(gTLD)和地理顶级域名(ccTLD)两种。类别顶级域名是　　　　　　　　       以”COM”、”NET”、”ORG”、”BIZ”、”INFO”等结尾的域名，均由国外公司负责管理。地理顶级域名是以国家或地区代码为结尾的域名，如”CN”代表中国，”UK”代表英国。地理顶级域名一般由各个国家或地区负责管理。</p><p>二级域名：二级域名是以顶级域名为基础的地理域名，比喻中国的二级域有，.com.cn,.net.cn,.org.cn,.gd.cn等.子域名是其父域名的子域名，比喻父域名是abc.com,子域名就是<a href="http://www.abc.com或者*.abc.com/">www.abc.com或者*.abc.com</a>.<br>一般来说，二级域名是域名的一条记录，比如alidiedie.com是一个域名，<a href="http://www.alidiedie.com是其中比较常用的记录,一般默认是用这个,但是类似*.alidiedie.com的域名全部称作是alidiedie.com的二级/">www.alidiedie.com是其中比较常用的记录，一般默认是用这个，但是类似*.alidiedie.com的域名全部称作是alidiedie.com的二级</a></p><h1 id="五-网络通信流程"><a href="#五-网络通信流程" class="headerlink" title="五 网络通信流程"></a>五 网络通信流程</h1><p>1.本机获取</p><ul><li>本机的IP地址：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>网关的IP地址：192.168.1.1</li><li>DNS的IP地址：8.8.8.8</li></ul><p>2.打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com./">www.google.com。</a></p><p>3.dns协议(基于udp协议)</p><p>4.HTTP部分的内容，类似于下面这样：</p><blockquote><p>GET / HTTP/1.1<br>Host: <a href="http://www.google.com/">www.google.com</a><br>Connection: keep-alive<br>User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Encoding: gzip,deflate,sdch<br>Accept-Language: zh-CN,zh;q=0.8<br>Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>Cookie: … …</p></blockquote><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><p>5 TCP协议</p><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><p>6 IP协议</p><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><p>7 以太网协议</p><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p><img src="https://yinshiweiysw.github.io/images/assets.%E6%9C%AA%E5%91%BD%E5%90%8D/640.jpeg" alt="img"></p><p>8 服务器端响应</p><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>]]></content>
    
    
    <categories>
      
      <category>hexoblog添加hexo标签</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>python代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexoblog添加hexo标签</title>
    <link href="/2021/10/29/hexo_blog%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE_hexo/"/>
    <url>/2021/10/29/hexo_blog%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE_hexo/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python">zhuti=<span class="hljs-string">&#x27;python&#x27;</span><br>tags=<span class="hljs-string">&#x27;&#x27;&#x27;- python&#x27;&#x27;&#x27;</span><br>path=<span class="hljs-string">&quot;E:\\笔记\\python&quot;</span><br>backup_path=<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;path&#125;</span>\\backup&#x27;</span><br><span class="hljs-comment">##fenlei为其分类，tags为其标签，path为读取文件的路径,backuppath为备份目录，主题title为其文件名</span><br><span class="hljs-comment">#读取后会自动将文件备份，然后写入hexo标签，为防止第二次再对相同文件进行写入标签，所以会使其写入后改名为原名_hexo.md</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-comment">#这里walk拿到的三个值为根文件夹目录，根文件目录中的文件夹和根文件目录中的文件</span><br><span class="hljs-keyword">for</span> root,dirs,files <span class="hljs-keyword">in</span> os.walk(path):<span class="hljs-comment">#这个会递归查询所有子文件夹的文件</span><br>    <span class="hljs-comment">#由于walk会无限递归而这里我们只需要根文件夹下为.md结尾的文件则加入一个判断</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-string">&quot;E:\\笔记\\python&quot;</span>:<br>      <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files: <span class="hljs-comment">#循环每个文件</span><br>          <span class="hljs-comment">#文件备份功能</span><br>          file1 = os.path.join(root,file) <span class="hljs-comment">#拼接文件与文件夹路径</span><br>          file2=file.split(<span class="hljs-string">&quot;.&quot;</span>) <span class="hljs-comment">#将文件名和文件扩展名分开，用于判断文件名，下面if只取md类型文件</span><br>          <span class="hljs-keyword">if</span> file2[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;md&quot;</span>:<br>              <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;hexo&quot;</span> <span class="hljs-keyword">in</span> file2[<span class="hljs-number">0</span>]:<br>                  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文件<span class="hljs-subst">&#123;file&#125;</span>的文件名包含hexo，所以不会备份文件&quot;</span>)<br>                  <span class="hljs-keyword">continue</span><br>              <span class="hljs-keyword">else</span>:<br>                   <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(backup_path):<br>                       os.mkdir(backup_path)<br>                   <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;backup_path&#125;</span>\\<span class="hljs-subst">&#123;file&#125;</span>&quot;</span>, <span class="hljs-string">&quot;a+&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f1:  <span class="hljs-comment"># 备份到的路径   首先先打开被备份的路径是怕被备份文件本身不存在，所以这里如果没有则提前创建一个</span><br>                        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;file1&#125;</span>&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment">#备份的md文件</span><br>                                a = f.read()<br>                                f1.seek(<span class="hljs-number">0</span>) <span class="hljs-comment">#由于这里是r+模式打开文件，所以需要跳到开头然后再覆盖写入</span><br>                                f1.write(a)<br>                                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文件：[<span class="hljs-subst">&#123;file&#125;</span>]已备份为E:\\笔记\\python\\backup\\<span class="hljs-subst">&#123;file&#125;</span>&quot;</span>)<br><br><br>                       <span class="hljs-comment">#备份完成之后开始将hexo博客的标签格式写入每一个md文件。</span><br>                        datetime1 = datetime.datetime.now().strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br>                        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;file1&#125;</span>&#x27;</span>,<span class="hljs-string">&#x27;r+&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                                    a = f.read()<br>                                    f.seek(<span class="hljs-number">0</span>)<br>                                    b = f.write(<span class="hljs-string">f&quot;&quot;&quot;---</span><br><span class="hljs-string">title: <span class="hljs-subst">&#123;file2[<span class="hljs-number">0</span>]&#125;</span></span><br><span class="hljs-string">date: <span class="hljs-subst">&#123;datetime1&#125;</span></span><br><span class="hljs-string">categories: <span class="hljs-subst">&#123;zhuti&#125;</span></span><br><span class="hljs-string">tags:</span><br><span class="hljs-string">    <span class="hljs-subst">&#123;tags&#125;</span></span><br><span class="hljs-string">---</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br>                                    f.write(a)<br>                                    f.close()<br>                                    os.rename(file1,<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;root&#125;</span>\\<span class="hljs-subst">&#123;file2[<span class="hljs-number">0</span>]&#125;</span>_hexo.<span class="hljs-subst">&#123;file2[<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)  <span class="hljs-comment">#将已经写入hexo标签的文件改名</span><br>                                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;file&#125;</span>标签写入完成&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="2-typora更改图片位置代码"><a href="#2-typora更改图片位置代码" class="headerlink" title="2.typora更改图片位置代码"></a>2.typora更改图片位置代码</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span>=<span class="hljs-string">&quot;E:\\笔记\\python\\面向对象_hexo.md&quot;</span><br>import re,os<br>def alter(old_str,new_str):<br>    path = <span class="hljs-string">&quot;E:\\笔记\\python&quot;</span><br>    <span class="hljs-comment"># 这里walk拿到的三个值为根文件夹目录，根文件目录中的文件夹和根文件目录中的文件</span><br>    <span class="hljs-keyword">for</span> root, dirs, <span class="hljs-built_in">files</span> <span class="hljs-keyword">in</span> os.walk(path):  <span class="hljs-comment"># 这个会递归查询所有子文件夹的文件</span><br>        <span class="hljs-comment"># 由于walk会无限递归而这里我们只需要根文件夹下为.md结尾的文件则加入一个判断</span><br>        <span class="hljs-keyword">if</span> root == <span class="hljs-string">&quot;E:\\笔记\\python&quot;</span>:<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">files</span>:  <span class="hljs-comment"># 循环每个文件</span><br>                file1 = os.path.join(root,<span class="hljs-built_in">file</span>)<br>                file2=<span class="hljs-built_in">file</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;.&quot;</span>) <span class="hljs-comment">#将文件名和文件扩展名分开，用于判断文件名，下面if只取md类型文件</span><br>                <span class="hljs-keyword">if</span> file2[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;md&quot;</span>:<br>                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file1, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f1,<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;%s.bak&quot;</span> % file1, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f2:<br>                        <span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> f1:<br>                            f2.<span class="hljs-built_in">write</span>(re.sub(old_str,new_str,<span class="hljs-built_in">line</span>))<br>                    os.remove(file1)<br>                    os.<span class="hljs-built_in">rename</span>(<span class="hljs-string">&quot;%s.bak&quot;</span> % file1, file1)<br>alter(<span class="hljs-keyword">https</span>://yinshiweiysw.github.io/images/assets/<span class="hljs-string">&#x27;)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>python代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2021/10/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_hexo/"/>
    <url>/2021/10/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>核心是过程二字，过程是流水线，用来分步骤解决问题的</p><p>过程的核心思想是将<strong>程序流程化</strong>。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>核心是对象二字。</p><p>对象是“容器”，用来盛放东西。</p><p>类也是“容器”，该容器用来存放同类对象共有的数据与功能。</p><p>对象的核心思想是将<strong>程序容器化</strong>。将程序整合</p><h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><p>类似对象相似数据与功能的集合体</p><p>所以类体最常见的是变量与函数的定义，但是类体其实是可以包含任意其他代码</p><p>类体代码是在类定义阶段就会立即执行，会产生类的名称空间</p><p>调用类的过程又称为实例化。发生了三件事</p><p>1.先产生一个空对象</p><p>2.调用类中的__init__方法（对象初始化属性），然后将空对象(self)以及调用类时括号内传入的参数一同传入init方法，相当于定义对象时类传递的属性为对象属性</p><p>例：</p><p>duixiang=lei(‘1s’,2,3)</p><h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><p>1、会在调用类时自动触发执行，用来为对象初始化自己独有的数据<br>        2、__init__内应该存放是为对象初始化属性的功能，但是是可以存放任意其他代码，想要在<br>        类调用时就立刻执行的代码都可以放到该方法内<br>        3、__init__方法必须返回None ,</p><p>python中所有数据类型都为类（class），而将数据类型传入参数（数值）定义为变量本质上就是在定义对象，所有python一切皆为对象。</p><h3 id="对象代码示例："><a href="#对象代码示例：" class="headerlink" title="对象代码示例："></a>对象代码示例：</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">school</span>:</span><br>    school_name=<span class="hljs-string">&#x27;OLDBOY&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,a,b)</span></span>:<br>        <span class="hljs-keyword">self</span>.address=a<br>        <span class="hljs-keyword">self</span>.nickname=b<br>        <span class="hljs-keyword">self</span>.classes=[]<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rekated_class</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,classobj)</span></span>:<br>        <span class="hljs-keyword">self</span>.classes.append(classobj)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tell_class</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        print(<span class="hljs-keyword">self</span>.nickname,<span class="hljs-keyword">end</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">for</span> class_obj <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">classes:</span><br>            class_obj.tell_course()<br>        class_obj.tell_student()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,name)</span></span>:<br>        <span class="hljs-keyword">self</span>.name=name<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">related_course</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,coursename,student)</span></span>:<br>        <span class="hljs-keyword">self</span>.course=coursename<br>        <span class="hljs-keyword">self</span>.student=student<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tell_course</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        print(<span class="hljs-keyword">self</span>.name,<span class="hljs-keyword">end</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">self</span>.course.tell_info()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tell_student</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        <span class="hljs-keyword">self</span>.student.tell_info()<br><br><span class="hljs-comment"># print(Class1.name,Class1.course)</span><br><span class="hljs-comment"># print(Class2.name,Class2.course)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,name,age,)</span></span>:<br>        <span class="hljs-keyword">self</span>.name=name<br>        <span class="hljs-keyword">self</span>.age=age<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tell_info</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        print(f<span class="hljs-string">&#x27;学生:&#123;self.name&#125;,年龄&#123;self.age&#125;&#x27;</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">course</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,name,period,price)</span></span>:<br>        <span class="hljs-keyword">self</span>.name=name<br>        <span class="hljs-keyword">self</span>.period=period<br>        <span class="hljs-keyword">self</span>.price=price<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tell_info</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        print(<span class="hljs-keyword">self</span>.name,<span class="hljs-keyword">self</span>.period,<span class="hljs-keyword">self</span>.price)<br><br><br>student1=student(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">15</span>)<br>student2=student(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>)<br><br><span class="hljs-comment">#定义两门课程以及其相关信息</span><br>course1=course(<span class="hljs-string">&#x27;linux课程&#x27;</span>,<span class="hljs-string">&#x27;6mons&#x27;</span>,<span class="hljs-number">2000</span>)<br>course2=course(<span class="hljs-string">&#x27;python课程&#x27;</span>,<span class="hljs-string">&#x27;6mons&#x27;</span>,<span class="hljs-number">3000</span>)<br><br><span class="hljs-comment">#定义两个班，将两门课程分别传入两个班</span><br>Class1 =Class(<span class="hljs-string">&#x27;1班&#x27;</span>)<br>Class2 =Class(<span class="hljs-string">&#x27;2班&#x27;</span>)<br>Class1.related_course(course1,student1)<br>Class2.related_course(course2,student2)<br><br><br><span class="hljs-comment">#定义两个校区，将班级传入两个校区</span><br>school1 = school(<span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-string">&#x27;北京校区&#x27;</span>)<br>school2 = school(<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-string">&#x27;上海校区&#x27;</span>)<br>school1.rekated_class(Class1)<br>school2.rekated_class(Class2)<br>school1.tell_class()<br>school2.tell_class()<br><br><span class="hljs-comment">#学校中的班级带入班级对象，班级中的课程再调用课程对象 课程对象-》班级对象-》学校对象</span><br></code></pre></td></tr></table></figure><h3 id="自定义私有属性"><a href="#自定义私有属性" class="headerlink" title="自定义私有属性"></a>自定义私有属性</h3><p>在定义类属性时，若在该属性前加上__，则该属性被定义为私有属性，即该属性不可被外部直接引用，只能在类的内部使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">class A(object):<br><br>def __init__(self):<br>self.__a = 1<br><br>def func(self):<br>print self.__a<br><br>a = A()<br>a.func()<br>#输出<br>1<br>a.__a<br>#输出<br>AttributeError: &#x27;A&#x27; object has no attribute &#x27;__a&#x27;<br></code></pre></td></tr></table></figure><p>然而Python对__a这个属性做了什么呢？实际上该属性并不是不存在的，当在某个属性前加上两个下划线后，python自动将其所在的类名追加在属性前导致其拥有了新的属性名，也由此实现了该属性不可引用的假象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">class A(object):<br><br>def __init__(self):<br>self.__a = 1<br><br>def func(self):<br>print self.__a<br><br><br>a = A()<br>a._A__a<br>#输出<br>1<br></code></pre></td></tr></table></figure><h3 id="property："><a href="#property：" class="headerlink" title="property："></a>property：</h3><p>property是一个装饰器，用来绑定给对象的方法伪造成一个数据属性。</p><p>相当于对象中定义的函数正常情况下是 对象名.函数名(“参数”)来进行调用，如果是property装饰情况下调用方式将变为：</p><p>对象名.函数名,本质上调用方式和对象属性变为一至。</p><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">someone</span>(<span class="hljs-title">object</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,name,weight,height)</span></span>:<br>        <span class="hljs-keyword">self</span>.name = name<br>        <span class="hljs-keyword">self</span>.weight = weight<br>        <span class="hljs-keyword">self</span>.height = height<br>    <span class="hljs-variable">@property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bmi</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.weight / (<span class="hljs-keyword">self</span>.height ** <span class="hljs-number">2</span>)<br>obj1 = someone(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">1.80</span>)<br>print(obj1.bmi)<br><span class="hljs-comment">#这里的bmi为计算其人体bmi值的方法，但如果按人类正常思考模式，其调用应该和身高体重一样是一个属性值，而非方法。</span><br><span class="hljs-comment">#<span class="hljs-doctag">@property</span>可以定义<span class="hljs-doctag">@property</span>装饰器 </span><br></code></pre></td></tr></table></figure><h4 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">someone</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.__name = name<br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__name<br><span class="hljs-meta">    @name.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self,val</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(val) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">str</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请传入str类型&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>        self.__name = val<br><span class="hljs-meta">    @name.deleter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无法删除&#x27;</span>)<br>object1 = someone(<span class="hljs-string">&quot;张三&quot;</span>)<br><span class="hljs-built_in">print</span>(object1.name)<br>object1.name = <span class="hljs-string">&quot;李四&quot;</span><br><span class="hljs-built_in">print</span>(object1.name)<br><span class="hljs-keyword">del</span> object1.name<br><br></code></pre></td></tr></table></figure><p>结果：</p><p>张三<br>        李四<br>        无法删除</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是一种创建新类的方式，新建的类可以成为子类或者派生类，父类又可称为基类或超类</p><p>python支持多继承，在python中新建的类可以继承一个或多个父类</p><p>python2中有经典类和新式类：</p><p>​    新式类是指继承了object类的子类，经典类是指没有继承object类的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cs1</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    x=<span class="hljs-number">111</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cs2</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cs3</span>(<span class="hljs-params">cs1</span>):</span><br>    <span class="hljs-keyword">pass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cs4</span>(<span class="hljs-params">cs2,cs1</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(cs3.x)<br></code></pre></td></tr></table></figure><p>结果：</p><p>111</p><p>这里cs1和cs2为顶级类，下面的类定义时如果继承了cs1，则可拥有cs1的方法和属性，通过继承。</p><p><strong>继承作用：解决类与类之间代码冗余问题</strong></p><p>优点：子类可以同时遗传多个父类的属性，最大限度重用代码</p><p>缺点：</p><p>​    1.违背人的思维习惯：继承表达的是一种什么“是”什么的关系</p><p>​    2.代码可读性会变差</p><p>​    3.扩展性变差，不建议使用多继承</p><p>​    4.如果无法避免使用多继承，应该使用Mixins</p><h4 id="例：-1"><a href="#例：-1" class="headerlink" title="例："></a>例：</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldboyPeople</span>:</span><br>    school = <span class="hljs-string">&#x27;OLDBOY&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name, age, sex)</span></span>:<br>        <span class="hljs-keyword">self</span>.name = name<br>        <span class="hljs-keyword">self</span>.age = age<br>        <span class="hljs-keyword">self</span>.sex = sex<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-title">OldboyPeople</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choose_course</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        print(<span class="hljs-string">&#x27;学生%s 正在选课&#x27;</span> % <span class="hljs-keyword">self</span>.name)<br><span class="hljs-comment"># stu_obj = Student(&#x27;lili&#x27;, 18, &#x27;female&#x27;)</span><br><span class="hljs-comment"># print(stu_obj.__dict__)</span><br><span class="hljs-comment"># print(stu_obj.school)</span><br><span class="hljs-comment"># stu_obj.choose_course()</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span>(<span class="hljs-title">OldboyPeople</span>):</span><br>    <span class="hljs-comment">#           老师的空对象，&#x27;egon&#x27;,18,&#x27;male&#x27;,3000,10</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name, age, sex, salary, level)</span></span>:<br>        <span class="hljs-comment"># 指名道姓地跟父类OldboyPeople去要__init__</span><br>        OldboyPeople.__init__(<span class="hljs-keyword">self</span>,name,age, sex)<br>        <span class="hljs-keyword">self</span>.salary = salary<br>        <span class="hljs-keyword">self</span>.level = level<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        print(<span class="hljs-string">&#x27;老师 %s 正在给学生打分&#x27;</span> % <span class="hljs-keyword">self</span>.name)<br><br>tea_obj=Teacher(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">10</span>)<br><span class="hljs-comment"># print(tea_obj.__dict__)</span><br><span class="hljs-comment"># print(tea_obj.school)</span><br><br>tea_obj.score()<br></code></pre></td></tr></table></figure><p>teacher这里在继承父类__init__属性name,age,sex的时候需要通过OldboyPeople.<strong>init</strong>(self,name,age, sex)来调用到自己的init方法里面。</p><p>如果子类中没有方法或属性而父类拥有，这个时候会调用父类的方法属性。而如果子类的父类都有情况下，会优先使用子类的。如果这时子类拥有与父类同名的方法属性且仍需要调用父类方法属性时需要在子类的单独定义出来，例如这里的init方法。</p><h4 id="菱形问题"><a href="#菱形问题" class="headerlink" title="菱形问题"></a>菱形问题</h4><p> 大多数面向对象语言都不支持多继承，而在Python中，一个子类是可以同时继承多个父类的，这固然可以带来一个子类可以对多个不同父类加以重用的好处，但也有可能引发著名的 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Diamond_problem">Diamond problem</a>菱形问题(或称钻石问题，有时候也被称为“死亡钻石”)，菱形其实就是对下面这种继承结构的形象比喻</p><p><img src="https://yinshiweiysw.github.io/images/assets/v2-7c6088a106bbf1fc46de0cca9c03a037_720w.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">A类在顶部，B类和C类分别位于其下方，D类在底部将两者连接在一起形成菱形。<br></code></pre></td></tr></table></figure><p>这种继承结构下导致的问题称之为菱形问题：如果A中有一个方法，B和/或C都重写了该方法，而D没有重写它，那么D继承的是哪个版本的方法：B的还是C的？如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from A&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">A</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from B&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">A</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from C&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>(<span class="hljs-params">B,C</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><br>obj = D()<br>obj.test() <span class="hljs-comment"># 结果为：from B</span><br></code></pre></td></tr></table></figure><p>要想搞明白obj.test()是如何找到方法test的，需要了解python的继承实现原理</p><h4 id="继承原理"><a href="#继承原理" class="headerlink" title="继承原理"></a>继承原理</h4><p>python到底是如何实现继承的呢？ 对于你定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>D.mro() <span class="hljs-comment"># 新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法</span><br>[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">__main__</span>.<span class="hljs-title">D</span>&#x27;&gt;, &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">__main__</span>.<span class="hljs-title">B</span>&#x27;&gt;, &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">__main__</span>.<span class="hljs-title">C</span>&#x27;&gt;, &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">__main__</span>.<span class="hljs-title">A</span>&#x27;&gt;, &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">object</span>&#x27;&gt;]</span><br></code></pre></td></tr></table></figure><p>python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>子类会先于父类被检查<br><span class="hljs-number">2.</span>多个父类会根据它们在列表中的顺序被检查<br><span class="hljs-number">3.</span>如果对下一个类存在两个合法的选择,选择第一个父类<br></code></pre></td></tr></table></figure><p>所以obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，则参照属性查找的发起者(即obj)所处类D的MRO列表来依次检索，首先在类D中未找到，然后再B中找到方法test</p><p>ps：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去，<br><span class="hljs-number">2.</span>由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去，<br></code></pre></td></tr></table></figure><h4 id="深度优先和广度优先"><a href="#深度优先和广度优先" class="headerlink" title="深度优先和广度优先"></a>深度优先和广度优先</h4><p>参照下述代码，多继承结构为非菱形结构，此时，会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性</p><p><img src="https://yinshiweiysw.github.io/images/assets/v2-64faa1a6e825277233fe2bf40401b99b_720w.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from E&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from F&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">E</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from B&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">F</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from C&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from D&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">B, C, D</span>):</span><br>    <span class="hljs-comment"># def test(self):</span><br>    <span class="hljs-comment">#     print(&#x27;from A&#x27;)</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-built_in">print</span>(A.mro())<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.E&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.F&#x27;&gt;, &lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>obj = A()<br>obj.test() <span class="hljs-comment"># 结果为：from B</span><br><span class="hljs-comment"># 可依次注释上述类中的方法test来进行验证</span><br></code></pre></td></tr></table></figure><p>如果继承关系为菱形结构，那么经典类与新式类会有不同MRO，分别对应属性的两种查找方式：深度优先和广度优先</p><p><img src="https://yinshiweiysw.github.io/images/assets/v2-e95d9f13b01af6eb7da3b5043442f697_720w.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span>:</span> <span class="hljs-comment"># 在python2中，未继承object的类及其子类，都是经典类</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from G&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span>(<span class="hljs-params">G</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from E&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>(<span class="hljs-params">G</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from F&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">E</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from B&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">F</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from C&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>(<span class="hljs-params">G</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from D&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">B,C,D</span>):</span><br>    <span class="hljs-comment"># def test(self):</span><br>    <span class="hljs-comment">#     print(&#x27;from A&#x27;)</span><br>    <span class="hljs-keyword">pass</span><br><br>obj = A()<br>obj.test() <span class="hljs-comment"># 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;G-&gt;C-&gt;F-&gt;D-&gt;object</span><br><span class="hljs-comment"># 可依次注释上述类中的方法test来进行验证,注意请在python2.x中进行测试</span><br></code></pre></td></tr></table></figure><p><img src="https://yinshiweiysw.github.io/images/assets/v2-08eb8fd2226110ae845da74805cb98fb_720w.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from G&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span>(<span class="hljs-params">G</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from E&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>(<span class="hljs-params">G</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from F&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">E</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from B&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">F</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from C&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>(<span class="hljs-params">G</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from D&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">B,C,D</span>):</span><br>    <span class="hljs-comment"># def test(self):</span><br>    <span class="hljs-comment">#     print(&#x27;from A&#x27;)</span><br>    <span class="hljs-keyword">pass</span><br><br>obj = A()<br>obj.test() <span class="hljs-comment"># 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D-&gt;G-&gt;object</span><br><span class="hljs-comment"># 可依次注释上述类中的方法test来进行验证</span><br></code></pre></td></tr></table></figure><h4 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h4><p>mixins是多继承的正确打开方式，其核心要素为：</p><p>在多继承背景下尽可能的提升多继承代码可读性</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx_locationANDrewrite</title>
    <link href="/2021/10/28/nginx_locationANDrewrite_hexo/"/>
    <url>/2021/10/28/nginx_locationANDrewrite_hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="nginx-location"><a href="#nginx-location" class="headerlink" title="nginx location"></a>nginx location</h2><p>Location匹配规则 </p><p>语法规则： 【= | ^~ | ~ | ~* | / | /uri 】</p><p> location = /uri                 = 表示精确匹配，只有完全匹配上才能生效，若找到，停止搜索； </p><p> location ^~ /uri               ^~开头表示对URL路径进行前缀匹配，并且在正则匹配之前，若找到，停止搜索； </p><p> location ~ pattern           ~开头表示区分大小写的正则匹配，按配置文件顺序匹配； </p><p> location ~* pattern          ~*开头表示不区分大小写的正则匹配，按配置文件顺序匹配； </p><p> location /uri                    不带任何修饰符，表示前缀匹配，在正则匹配之后； </p><p> location /                        通用匹配，任何未匹配到其他location的请求都会匹配到，相当于default； </p><p>多个location配置的情况匹配顺序为</p><p>首先精确匹配 = ；</p><p>其次前缀匹配 ^~；</p><p>其次是按照配置文件中的正则匹配； </p><p>然后匹配不带任何修饰符的前缀匹配； </p><p>最后交给/通用匹配</p><p>注意点：</p><p>^~无法使用正则匹配</p><h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite:"></a>rewrite:</h2><p>  rewrite  <regex>  <replacement>  [flag];</p><p>  关键字    正则     替代内容      flag标记</p><p>  关键字：其中关键字error_log不能改变</p><p>  正则：perl兼容正则表达式语句进行规则匹配</p><p>  替代内容：将正则匹配的内容替换成replacement</p><p>  flag标记：rewrite支持的flag标记</p><p>flag标记说明：</p><p>last #本条规则匹配完成后，继续向下匹配新的location URI规则</p><p>break #本条规则匹配完成即终止，不再匹配后面的任何规则</p><p>redirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址</p><p>permanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</p><h3 id="rewrite参数的标签段位置："><a href="#rewrite参数的标签段位置：" class="headerlink" title="rewrite参数的标签段位置："></a>rewrite参数的标签段位置：</h3><p>server,location,if</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>rewrite ^/(.*) <a href="http://www.czlun.com/$1">http://www.czlun.com/$1</a> permanent;</p><p>说明：                    </p><p>rewrite为固定关键字，表示开始进行rewrite匹配规则</p><p>regex部分是 ^/(.*) ，这是一个正则表达式，匹配完整的域名和后面的路径地址</p><p>replacement部分是<a href="http://www.czlun.com/$1">http://www.czlun.com/$1</a> $1，是取自regex部分()里的内容。匹配成功后跳转到的URL。</p><p>flag部分 permanent表示永久301重定向标记，即跳转到新的 <a href="http://www.czlun.com/$1">http://www.czlun.com/$1</a> 地址上</p><p>这里匹配的时候如果不是break最好要让其重写后不再会匹配回来，否则会无限重写。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>名称空间</title>
    <link href="/2021/10/28/%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4_hexo/"/>
    <url>/2021/10/28/%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4_hexo/</url>
    
    <content type="html"><![CDATA[<p>​    1.三种名称空间用途与存货周期</p><p>​    2.三种名称空间的加载顺序</p><p>​    3.三种名称空间的查找名字的优先级</p><p>名称空间存放在栈区里面，栈区存放了三种名称空间，分别为：</p><p>​    内置名称空间，全局名称空间，局部名称空间</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20210909154939000.png" alt="image-20210909154939000"></p><h2 id="1-内置名称空间"><a href="#1-内置名称空间" class="headerlink" title="1.内置名称空间"></a>1.内置名称空间</h2><p>​    例如：print，input</p><p>​    存货周期：python解释器 启动则产生，解释器关闭则销毁。</p><h2 id="2-全局名称空间："><a href="#2-全局名称空间：" class="headerlink" title="2.全局名称空间："></a>2.全局名称空间：</h2><p>​    运行顶级代码所产生的名字，或者说不是函数内定义，也非内置的就是全局名称空间</p><p>​    python是靠缩进进行嵌套代码的，顶级代码就是第一级代码，非嵌套代码。</p><p>例如：</p><p> <code>x=10</code></p><p><code>def func():</code></p><p>​    <code>a=1</code></p><p>​    <code>b=2</code></p><p>这里func和x就是全局名称空间存储的，但a和b是局部名称空间。</p><p>存货周期：python文件执行则产生，运行完毕便销毁。</p><h2 id="3-局部名称空间"><a href="#3-局部名称空间" class="headerlink" title="3.局部名称空间"></a>3.局部名称空间</h2><p>​    在调用函数时，运行函数体代码过程中产生的函数内的名字。 </p><p>​    存货周期：在调用函数时存货，函数调用完毕后摧毁。</p><p>名称空间加载顺序：</p><pre><code> 内置名称空间》 全局名称空间 》 局部名称空间</code></pre><p>销毁顺序：</p><p>​    局部名称空间》 全局名称空间 》内置名称空间</p><p>名字的查找优先级：</p><p>​    内置名称空间》 全局名称空间 》 局部名称空间</p><h2 id="全局作用域与局部作用域"><a href="#全局作用域与局部作用域" class="headerlink" title="全局作用域与局部作用域"></a>全局作用域与局部作用域</h2><p>按照名字作用范围的不同可以将三个名称空间划分为两个区域：</p><ol><li>全局作用域:位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）；</li><li> 局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2021/10/28/%E4%BA%8C%E5%88%86%E6%B3%95_hexo/"/>
    <url>/2021/10/28/%E4%BA%8C%E5%88%86%E6%B3%95_hexo/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 二分法<br>date: 2021-10-20 20:19:11<br>tags:<br>    - Typora<br>    - Python</p><hr><hr><p>title: 二分法<br>date: 2021-10-20 20:18:43<br>tags:<br>    - Typora<br>    - Python</p><hr><p>​    </p><p>算法：是高效解决问题的方法</p><p>算法之二分法</p><p>​    需求：有一个按照从小到大顺序排序的数字列表，需要从该数字列表中找到我们想要的那个一个数字。</p><p>​    例子：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">89</span>,<span class="hljs-number">877</span>,<span class="hljs-number">999</span>,<span class="hljs-number">6888</span>,<span class="hljs-number">56757</span>,<span class="hljs-number">575657</span>]<br>b = <span class="hljs-number">6888</span><br><br>def bibary(<span class="hljs-keyword">a</span>,b):<br>    print(<span class="hljs-keyword">a</span>)<br>    e = <span class="hljs-built_in">len</span>(<span class="hljs-keyword">a</span>)<span class="hljs-comment"> // 2</span><br>    <span class="hljs-keyword">if</span> b &gt; <span class="hljs-keyword">a</span>[e]:<br>        <span class="hljs-keyword">a</span>=<span class="hljs-keyword">a</span>[e:]<br>        bibary(<span class="hljs-keyword">a</span>, b)<br>    elif b &lt; <span class="hljs-keyword">a</span>[e]:<br>        <span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span>[:e]<br>        bibary(<span class="hljs-keyword">a</span>, b)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;have find it &#x27;</span>)<br><br>bibary(<span class="hljs-keyword">a</span>,b)<br></code></pre></td></tr></table></figure><h2 id="函数式编程："><a href="#函数式编程：" class="headerlink" title="函数式编程："></a>函数式编程：</h2><p>函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有:Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提饪了很多函数式编程好的特性，如lambda，map,reduce，filter</p><h3 id="匿名函数lambda："><a href="#匿名函数lambda：" class="headerlink" title="匿名函数lambda："></a>匿名函数lambda：</h3><p>​    1.有名函数</p><p>​    func=函数的内存地址</p><p>​    def fun(a,b)</p><p>​        return x+y</p><p>​    2.匿名函数</p><p>​        lambda a,b:x+y #a,b为参数，无需加括号</p><p>​         这个x+y等于上面有名代码的return x+y</p><h4 id="调用匿名函数："><a href="#调用匿名函数：" class="headerlink" title="调用匿名函数："></a>调用匿名函数：</h4><p>​            方式一：</p><p>​                res=（lambda x,y:x+y）(1,2)</p><p>​                print(res)                </p><p>​            相当于 匿名地址内存地址加上传递的参数    </p><p>​            方式二：</p><p>​                func=lambda x,y:x+y</p><p>​                res=func(1,2)</p><p>​                print(res)</p><p>​            匿名函数本质不应加函数名字，可以加函数名字实现但没必要。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>​        用于临时使用（调用）一次。</p><p>​        </p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vala">salaries=&#123;<br>    <span class="hljs-string">&#x27;siry&#x27;</span>:<span class="hljs-number">3000</span>,<br>    <span class="hljs-string">&#x27;tom&#x27;</span>:<span class="hljs-number">7000</span>,<br>    <span class="hljs-string">&#x27;lili&#x27;</span>:<span class="hljs-number">10000</span>,<br>    <span class="hljs-string">&#x27;jack&#x27;</span>:<span class="hljs-number">2000</span><br>&#125;<br><span class="hljs-meta"># 迭代出的内容    比较的值</span><br><span class="hljs-meta"># &#x27;siry&#x27;         3000</span><br><span class="hljs-meta"># &#x27;tom&#x27;          7000</span><br><span class="hljs-meta"># &#x27;lili&#x27;         10000</span><br><span class="hljs-meta"># &#x27;jack&#x27;         2000</span><br><br><span class="hljs-meta"># def func(k):</span><br><span class="hljs-meta">#     return salaries[k]</span><br><br><span class="hljs-meta"># ========================max的应用</span><br><span class="hljs-meta"># res=max(salaries,key=func) # 返回值=func(&#x27;siry&#x27;)</span><br><span class="hljs-meta"># print(res)</span><br><span class="hljs-meta">#这里再max迭代其字典salaries时，迭代的是其key而非value，所以比较的也是key非value，想要比较key就把max中传入key=func参数，func为定义的函数(这里无需跟括号和参数因为max会自动传入参数)，其功能为返回字典key对应的value，使其用value进行比较，但因这里只临时调用一次，顾应该定义为lambda函数，而无需专门定义一个有名函数。写法如下：</span><br>res = max(salaries,key=lambda k:salaries[k])<br>print(res)<br><span class="hljs-meta"># ========================min的应用</span><br><span class="hljs-meta"># res=min(salaries,key=lambda k:salaries[k])</span><br><span class="hljs-meta"># print(res)</span><br><br><br><span class="hljs-meta"># ========================sorted排序</span><br><br><span class="hljs-meta">#res=sorted(salaries,key=lambda k:salaries[k],reverse=True)</span><br><span class="hljs-meta"># print(res)</span><br><span class="hljs-meta">#这里sorted为排序，默认为key排序，传入key参数（lamdda）找到其key对应value，使其用value排序。</span><br></code></pre></td></tr></table></figure><p>​            </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列化</title>
    <link href="/2021/10/28/%E5%BA%8F%E5%88%97%E5%8C%96_hexo/"/>
    <url>/2021/10/28/%E5%BA%8F%E5%88%97%E5%8C%96_hexo/</url>
    
    <content type="html"><![CDATA[<p>序列化指的是把内存的数据类型转换成一个特定的格式的内容。</p><p>该格式的内容可用于存储或传输给其他平台使用</p><p>内存中的数据类型–》序列化–》特定的格式（json格式或者pickle格式）</p><p>内存中的数据类型《–反序列化《–特定的格式（json格式或者pickle格式）</p><p>反序列化：相当于把json格式转为内存中的数据类型。</p><h2 id="序列化的作用："><a href="#序列化的作用：" class="headerlink" title="序列化的作用："></a>序列化的作用：</h2><p>序列化得到的结果：特定的格式的内容有两种用途</p><p>1.可用于存储-》用于存档</p><p>2.传输给其他平台使用-》跨平台数据交互</p><p>用途1：可以是一种专用的格式-》pickle只有python可以识别。因为用于存储本身是从内存数据类型转换到序列化格式存储然后使用时又调用反序列化到内存中去，本质上是自己和自己玩，无需与其他语言进行交互</p><p>用途2:应该是一种通用，能被其他语言所是识别的语言-》json。</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a><strong>json</strong></h2><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20210927145134605.png" alt="image-20210927145134605"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件</title>
    <link href="/2021/10/28/%E6%96%87%E4%BB%B6_hexo/"/>
    <url>/2021/10/28/%E6%96%87%E4%BB%B6_hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1.打开文件"></a>1.打开文件</h2><p>open()</p><p>windows路径分隔符问题：</p><p>open(‘C:\a\nb\c\d.txt’)</p><p>这里由于\是转义符且\n为换行符，无法直接找到需要的文件</p><p>解放方案1：</p><p>​    open(r’C:\a\nb\c\d.txt’)</p><p>​                2:</p><p>​    open(‘C:/a/nb/c/d.txt’)</p><p>open参数：</p><p>​    mode:</p><p>​    mode代表其操作文件的权限以及方式，权限有三种，方式有两种</p><pre><code>      权限：          r只读模式（带r的文件必须先存在）        w只写模式        a只追加写模式        +：r+、w+、a+              读写模式：          t和b            强调：t和b不能单独使用，必须跟r/w/a连用            t文本（默认的模式）                1、读写都以str（unicode）为单位的                2、文本文件                3、必须指定encoding=&#39;utf-8&#39;            b二进制/bytes</code></pre><p><img src="https://img-blog.csdnimg.cn/2019030514425285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmdlMjAxMTExMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>例：</p><p>​    f=open(r’aaa/a.txt’,mode=’rt’)</p><h2 id="2-操作文件"><a href="#2-操作文件" class="headerlink" title="2.操作文件"></a>2.操作文件</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">res</span>=f.read()<br></code></pre></td></tr></table></figure><h2 id="3-关闭文件"><a href="#3-关闭文件" class="headerlink" title="3.关闭文件"></a>3.关闭文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f.close()<br></code></pre></td></tr></table></figure><h2 id="4-with-open"><a href="#4-with-open" class="headerlink" title="4.with open"></a>4.with open</h2><p>​    在使用open时文件必须进行close操作，但with open无需主动进行关闭，系统会自动进行close</p><p>例：    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>,mode=<span class="hljs-string">&#x27;rt&#x27;</span>) <span class="hljs-keyword">as</span> f1：<br><br>f=f1.read()<br><br><span class="hljs-built_in">print</span>(f)<br></code></pre></td></tr></table></figure><h2 id="5-指定字符编码"><a href="#5-指定字符编码" class="headerlink" title="5.指定字符编码"></a>5.指定字符编码</h2><p>encoding=’字符编码’</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">with <span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;c.txt&#x27;</span>,<span class="hljs-keyword">mode</span>=<span class="hljs-string">&#x27;rt&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">f</span>:<br>    <span class="hljs-keyword">res</span>=<span class="hljs-keyword">f</span>.<span class="hljs-keyword">read</span>() # t模式会将<span class="hljs-keyword">f</span>.<span class="hljs-keyword">read</span>()读出的结果解码成unicode<br>    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">res</span>,<span class="hljs-built_in">type</span>(<span class="hljs-keyword">res</span>))<br></code></pre></td></tr></table></figure><h2 id="6-实例"><a href="#6-实例" class="headerlink" title="6.实例"></a>6.实例</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#1、编写文件copy工具</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">a = input(&#x27;请输入您复制的文件名:&#x27;)</span><br><span class="hljs-string">b = input(&#x27;您将要复制的文件名:&#x27;)</span><br><span class="hljs-string">with open(a,mode=&#x27;rb&#x27;) as file,\</span><br><span class="hljs-string">        open(b,mode=&#x27;wb+&#x27;) as file2:</span><br><span class="hljs-string">    c=file.read()</span><br><span class="hljs-string">    d=file2.write(c)</span><br><span class="hljs-string">    print(f&#x27;您复制的文件&#123;a&#125;,现在&#123;b&#125;文件的内容为&#123;d&#125;&#x27;)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#2、编写登录程序，账号密码来自于文件</span><br><span class="hljs-comment">#用户登陆</span><br>import re<br><span class="hljs-string">&#x27;&#x27;&#x27;用户登陆</span><br><span class="hljs-string">a = input(&quot;请输入您的账号：&quot;)</span><br><span class="hljs-string">b = input(&quot;请输入密码：&quot;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">with open(&#x27;static/c.txt&#x27;,mode=&#x27;r+&#x27;) as c:</span><br><span class="hljs-string">    while True:</span><br><span class="hljs-string">        d = c.readline()</span><br><span class="hljs-string">        e = a + &quot;:&quot; + b + &#x27;\n&#x27;</span><br><span class="hljs-string">        if e == d:</span><br><span class="hljs-string">            print(&quot;账号密码正确，登陆成功&quot;)</span><br><span class="hljs-string">            exit(0)</span><br><span class="hljs-string">        print(len(d))</span><br><span class="hljs-string">        if len(d) == 0:</span><br><span class="hljs-string">            print(&#x27;登陆失败&#x27;)</span><br><span class="hljs-string">            exit(1)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;注册账号</span><br><span class="hljs-string">a = input(&quot;请输入您要注册的账号：&quot;)</span><br><span class="hljs-string">b = input(&quot;请输入要注册的密码：&quot;)</span><br><span class="hljs-string">with open(&#x27;static/c.txt&#x27;,mode=&#x27;r+&#x27;) as c:</span><br><span class="hljs-string">        while True:</span><br><span class="hljs-string">            d = c.readline()</span><br><span class="hljs-string">            f= d.split(&#x27;:&#x27;)</span><br><span class="hljs-string">            if a == f[0]:</span><br><span class="hljs-string">                print(&quot;账号已存在，请重新输入&quot;)</span><br><span class="hljs-string">                exit(1)</span><br><span class="hljs-string">            if len(d) == 0:</span><br><span class="hljs-string">                e =  a + &quot;:&quot; + b + &quot;\n&quot;</span><br><span class="hljs-string">                c.seek(0,2)</span><br><span class="hljs-string">                c.write(e)</span><br><span class="hljs-string">                print(&#x27;账号已注册成功&#x27;)</span><br><span class="hljs-string">                exit(0)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#面向对象</span><br>class zcdl():<br>    def start(self):<br>        self.start1 = input(<span class="hljs-string">&#x27;&#x27;&#x27;请输入要选择的功能:</span><br><span class="hljs-string">     1.登陆账号</span><br><span class="hljs-string">     2.注册账号</span><br><span class="hljs-string">     :&#x27;&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">if</span> self.start1 == <span class="hljs-string">&#x27;1&#x27;</span>:<br>            self.denglu()<br>        <span class="hljs-keyword">if</span> self.start1 == <span class="hljs-string">&#x27;2&#x27;</span>:<br>            self.zhuce()<br>    def denglu(self):<br>        a = input(<span class="hljs-string">&quot;请输入您的账号：&quot;</span>)<br>        b = input(<span class="hljs-string">&quot;请输入密码：&quot;</span>)<br><br>        with open(<span class="hljs-string">&#x27;c.txt&#x27;</span>, mode=<span class="hljs-string">&#x27;r+&#x27;</span>) as c:<br>            <span class="hljs-keyword">while</span> True:<br>                d = c.readline()<br>                e = a + <span class="hljs-string">&quot;:&quot;</span> + b + <span class="hljs-string">&#x27;\n&#x27;</span><br>                <span class="hljs-keyword">if</span> e == d:<br>                    print(<span class="hljs-string">&quot;账号密码正确，登陆成功&quot;</span>)<br>                    <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> len(d) == <span class="hljs-number">0</span>:<br>                    print(<span class="hljs-string">&#x27;登陆失败&#x27;</span>)<br>                    <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>)<br>    def zhuce(self):<br>        a = input(<span class="hljs-string">&quot;请输入您要注册的账号：&quot;</span>)<br>        b = input(<span class="hljs-string">&quot;请输入要注册的密码：&quot;</span>)<br>        with open(<span class="hljs-string">&#x27;c.txt&#x27;</span>, mode=<span class="hljs-string">&#x27;a+&#x27;</span>) as c:<br>            c.seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">while</span> True:<br>                d = c.readline()<br>                f = d.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>                <span class="hljs-keyword">if</span> a == f[<span class="hljs-number">0</span>]:<br>                    print(<span class="hljs-string">&quot;账号已存在，请重新输入&quot;</span>)<br>                    <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">if</span> len(d) == <span class="hljs-number">0</span>:<br>                    e = a + <span class="hljs-string">&quot;:&quot;</span> + b + <span class="hljs-string">&quot;\n&quot;</span><br>                    c.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>                    c.write(e)<br>                    print(<span class="hljs-string">&#x27;账号已注册成功&#x27;</span>)<br>                    <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>)<br><br>duixiang = zcdl()<br>duixiang.start()<br></code></pre></td></tr></table></figure><p>注意点：</p><p>1.在打开文件时需要注意rwa这三种模式每一种模式所在的指针位置以及是否会清空文件，还需要需要根据具体需求来移动指针位置。通过seek函数 </p><p>2.seek(number,number) 第一个参数表示移动的位置为几个符号，正数右移动，负数左移动。第二个参数表示其在文件哪个位置。</p><p>0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形参与实参介绍</title>
    <link href="/2021/10/28/%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E4%BB%8B%E7%BB%8D_hexo/"/>
    <url>/2021/10/28/%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E4%BB%8B%E7%BB%8D_hexo/</url>
    
    <content type="html"><![CDATA[<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@作者: egon老湿</span><br><span class="hljs-string">@微信:18611453110</span><br><span class="hljs-string">@专栏: https://zhuanlan.zhihu.com/c_1189883314197168128</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-meta"># 一 形参与实参介绍</span><br><span class="hljs-meta"># 形参：在定义函数阶段定义的参数称之为形式参数，简称形参,相当于变量名</span><br>def func(x, y):  # x=<span class="hljs-number">1</span>，y=<span class="hljs-number">2</span><br>    print(x, y)<br><br><br><span class="hljs-meta"># 实参：在调用函数阶段传入的值称之为实际参数，简称实参，相当于变量值</span><br><span class="hljs-meta"># func(1,2)</span><br><br><span class="hljs-meta"># 形参与实参的关系：</span><br><span class="hljs-meta"># 1、在调用阶段，实参（变量值）会绑定给形参（变量名）</span><br><span class="hljs-meta"># 2、这种绑定关系只能在函数体内使用</span><br><span class="hljs-meta"># 3、实参与形参的绑定关系在函数调用时生效，函数调用结束后解除绑定关系</span><br><br><span class="hljs-meta"># 实参是传入的值，但值可以是以下形式</span><br><span class="hljs-meta"># 形式一：</span><br><span class="hljs-meta"># func(1,2)</span><br><br><span class="hljs-meta"># 形式二：</span><br><span class="hljs-meta"># a=1</span><br><span class="hljs-meta"># b=2</span><br><span class="hljs-meta"># func(a,b)</span><br><br><span class="hljs-meta"># 形式三：</span><br><span class="hljs-meta"># func(int(&#x27;1&#x27;),2)</span><br><span class="hljs-meta"># func(func1(1,2,),func2(2,3),333)</span><br><br><br><span class="hljs-meta"># 二 形参与实参的具体使用</span><br><span class="hljs-meta"># 2.1 位置参数：按照从左到右的顺序依次定义的参数称之为位置参数</span><br><span class="hljs-meta"># 位置形参:在函数定义阶段，按照从左到右的顺序直接定义的&quot;变量名&quot;</span><br><span class="hljs-meta">#        特点：必须被传值，多一个不行少一个也不行</span><br><span class="hljs-meta"># def func(x,y):</span><br><span class="hljs-meta">#     print(x,y)</span><br><span class="hljs-meta"># func(1,2,3)</span><br><span class="hljs-meta"># func(1,)</span><br><br><span class="hljs-meta"># 位置实参:在函数调用阶段， 按照从左到有的顺序依次传入的值</span><br><span class="hljs-meta">#        特点：按照顺序与形参一一对应</span><br><br><span class="hljs-meta"># func(1,2)</span><br><span class="hljs-meta"># func(2,1)</span><br><br><span class="hljs-meta"># 2.2 关键字参数</span><br><span class="hljs-meta"># 关键字实参：在函数调用阶段，按照key=value的形式传入的值</span><br><span class="hljs-meta">#       特点：指名道姓给某个形参传值，可以完全不参照顺序</span><br><span class="hljs-meta"># def func(x,y):</span><br><span class="hljs-meta">#     print(x,y)</span><br><br><span class="hljs-meta"># func(y=2,x=1)</span><br><span class="hljs-meta"># func(1,2)</span><br><br><span class="hljs-meta"># 混合使用，强调</span><br><span class="hljs-meta"># 1、位置实参必须放在关键字实参前</span><br><span class="hljs-meta"># func(1,y=2)</span><br><span class="hljs-meta"># func(y=2,1)</span><br><br><span class="hljs-meta"># 2、不能能为同一个形参重复传值</span><br><span class="hljs-meta"># func(1,y=2,x=3)</span><br><span class="hljs-meta"># func(1,2,x=3,y=4)</span><br><br><br><span class="hljs-meta"># 2.3 默认参数</span><br><span class="hljs-meta"># 默认形参：在定义函数阶段，就已经被赋值的形参，称之为默认参数</span><br><span class="hljs-meta">#       特点：在定义阶段就已经被赋值，意味着在调用阶段可以不用为其赋值</span><br><span class="hljs-meta"># def func(x,y=3):</span><br><span class="hljs-meta">#     print(x,y)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># # func(x=1)</span><br><span class="hljs-meta"># func(x=1,y=44444)</span><br><br><br><span class="hljs-meta"># def register(name,age,gender=&#x27;男&#x27;):</span><br><span class="hljs-meta">#     print(name,age,gender)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># register(&#x27;三炮&#x27;,18)</span><br><span class="hljs-meta"># register(&#x27;二炮&#x27;,19)</span><br><span class="hljs-meta"># register(&#x27;大炮&#x27;,19)</span><br><span class="hljs-meta"># register(&#x27;没炮&#x27;,19,&#x27;女&#x27;)</span><br><br><br><span class="hljs-meta"># 位置形参与默认形参混用，强调：</span><br><span class="hljs-meta"># 1、位置形参必须在默认形参的左边</span><br><span class="hljs-meta"># def func(y=2,x):</span><br><span class="hljs-meta">#     pass</span><br><br><span class="hljs-meta"># 2、默认参数的值是在函数定义阶段被赋值的，准确地说被赋予的是值的内存地址</span><br><span class="hljs-meta"># 示范1：</span><br><span class="hljs-meta"># m=2</span><br><span class="hljs-meta"># def func(x,y=m): # y=&gt;2的内存地址</span><br><span class="hljs-meta">#     print(x,y</span><br><span class="hljs-meta"># m=3333333333333333333</span><br><span class="hljs-meta"># func(1)</span><br><br><span class="hljs-meta"># 示范2：</span><br><span class="hljs-meta"># m = [111111, ]</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># def func(x, y=m): # y=&gt;[111111, ]的内存地址</span><br><span class="hljs-meta">#     print(x, y)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># m.append(3333333)</span><br><span class="hljs-meta"># func(1)</span><br><br><span class="hljs-meta"># 3、虽然默认值可以被指定为任意数据类型，但是不推荐使用可变类型</span><br><span class="hljs-meta"># 函数最理想的状态：函数的调用只跟函数本身有关系，不外界代码的影响</span><br><span class="hljs-meta"># m = [111111, ]</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># def func(x, y=m):</span><br><span class="hljs-meta">#     print(x, y)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># m.append(3333333)</span><br><span class="hljs-meta"># m.append(444444)</span><br><span class="hljs-meta"># m.append(5555)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># func(1)</span><br><span class="hljs-meta"># func(2)</span><br><span class="hljs-meta"># func(3)</span><br><br><br><span class="hljs-meta"># def func(x,y,z,l=None):</span><br><span class="hljs-meta">#     if l is None:</span><br><span class="hljs-meta">#         l=[]</span><br><span class="hljs-meta">#     l.append(x)</span><br><span class="hljs-meta">#     l.append(y)</span><br><span class="hljs-meta">#     l.append(z)</span><br><span class="hljs-meta">#     print(l)</span><br><br><span class="hljs-meta"># func(1,2,3)</span><br><span class="hljs-meta"># func(4,5,6)</span><br><br><span class="hljs-meta"># new_l=[111,222]</span><br><span class="hljs-meta"># func(1,2,3,new_l)</span><br><br><br><span class="hljs-meta"># 2.4 可变长度的参数（*与**的用法）</span><br><span class="hljs-meta"># 可变长度指的是在调用函数时，传入的值（实参）的个数不固定</span><br><span class="hljs-meta"># 而实参是用来为形参赋值的，所以对应着，针对溢出的实参必须有对应的形参来接收</span><br><br><span class="hljs-meta"># 2.4.1 可变长度的位置参数</span><br><span class="hljs-meta"># I：*形参名：用来接收溢出的位置实参，溢出的位置实参会被*保存成元组的格式然后赋值紧跟其后的形参名</span><br><span class="hljs-meta">#           *后跟的可以是任意名字，但是约定俗成应该是args</span><br><br><span class="hljs-meta"># def func(x,y,*z): # z =（3,4,5,6）</span><br><span class="hljs-meta">#     print(x,y,z)</span><br><br><span class="hljs-meta"># func(1,2,3,4,5,6)</span><br><br><span class="hljs-meta"># def my_sum(*args):</span><br><span class="hljs-meta">#     res=0</span><br><span class="hljs-meta">#     for item in args:</span><br><span class="hljs-meta">#         res+=item</span><br><span class="hljs-meta">#     return res</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># res=my_sum(1,2,3,4,)</span><br><span class="hljs-meta"># print(res)</span><br><br><span class="hljs-meta"># II: *可以用在实参中，实参中带*，先*后的值打散成位置实参</span><br><span class="hljs-meta"># def func(x,y,z):</span><br><span class="hljs-meta">#     print(x,y,z)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># # func(*[11,22,33]) # func(11，22，33)</span><br><span class="hljs-meta"># # func(*[11,22]) # func(11，22)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># l=[11,22,33]</span><br><span class="hljs-meta"># func(*l)</span><br><br><span class="hljs-meta"># III: 形参与实参中都带*</span><br><span class="hljs-meta"># def func(x,y,*args): # args=(3,4,5,6)</span><br><span class="hljs-meta">#     print(x,y,args)</span><br><br><span class="hljs-meta"># func(1,2,[3,4,5,6])</span><br><span class="hljs-meta"># func(1,2,*[3,4,5,6]) # func(1,2,3,4,5,6)</span><br><span class="hljs-meta"># func(*&#x27;hello&#x27;) # func(&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;)</span><br><br><br><span class="hljs-meta"># 2.4.2 可变长度的关键字参数</span><br><span class="hljs-meta"># I：**形参名：用来接收溢出的关键字实参，**会将溢出的关键字实参保存成字典格式，然后赋值给紧跟其后的形参名</span><br><span class="hljs-meta">#           **后跟的可以是任意名字，但是约定俗成应该是kwargs</span><br><span class="hljs-meta"># def func(x,y,**kwargs):</span><br><span class="hljs-meta">#     print(x,y,kwargs)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># func(1,y=2,a=1,b=2,c=3)</span><br><br><span class="hljs-meta"># II: **可以用在实参中(**后跟的只能是字典)，实参中带**，先**后的值打散成关键字实参</span><br><span class="hljs-meta"># def func(x,y,z):</span><br><span class="hljs-meta">#     print(x,y,z)</span><br><br><span class="hljs-meta"># func(*&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2,&#x27;z&#x27;:3&#125;) # func(&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;)</span><br><span class="hljs-meta"># func(**&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2,&#x27;z&#x27;:3&#125;) # func(x=1,y=2,z=3)</span><br><br><span class="hljs-meta"># 错误</span><br><span class="hljs-meta"># func(**&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2,&#125;) # func(x=1,y=2)</span><br><span class="hljs-meta"># func(**&#123;&#x27;x&#x27;:1,&#x27;a&#x27;:2,&#x27;z&#x27;:3&#125;) # func(x=1,a=2,z=3)</span><br><br><br><span class="hljs-meta"># III: 形参与实参中都带**</span><br><span class="hljs-meta"># def func(x,y,**kwargs):</span><br><span class="hljs-meta">#     print(x,y,kwargs)</span><br><br><span class="hljs-meta"># func(y=222,x=111,a=333,b=444)</span><br><span class="hljs-meta"># func(**&#123;&#x27;y&#x27;:222,&#x27;x&#x27;:111,&#x27;a&#x27;:333,&#x27;b&#x27;:4444&#125;)</span><br><br><br><br><br><span class="hljs-meta"># 混用*与**：*args必须在**kwargs之前</span><br><span class="hljs-meta"># def func(x,*args,**kwargs):</span><br><span class="hljs-meta">#     print(args)</span><br><span class="hljs-meta">#     print(kwargs)</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># func(1,2,3,4,5,6,7,8,x=1,y=2,z=3)</span><br><br><br>def index(x,y,z):<br>    print(<span class="hljs-string">&#x27;index=&gt;&gt;&gt; &#x27;</span>,x,y,z)<br><br>def wrapper(*args,**kwargs): #args=(<span class="hljs-number">1</span>,) kwargs=&#123;<span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;y&#x27;</span>:<span class="hljs-number">2</span>&#125;<br>    index(*args,**kwargs)<br>    # index(*(<span class="hljs-number">1</span>,),**&#123;<span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;y&#x27;</span>:<span class="hljs-number">2</span>&#125;)<br>    # index(<span class="hljs-number">1</span>,z=<span class="hljs-number">3</span>,y=<span class="hljs-number">2</span>)<br><br>wrapper(<span class="hljs-number">1</span>,z=<span class="hljs-number">3</span>,y=<span class="hljs-number">2</span>) # 为wrapper传递的参数是给index用的<br><span class="hljs-meta"># 原格式---》汇总-----》打回原形</span><br><br><br><br><span class="hljs-meta"># 2.5 命名关键字参数（了解）</span><br><span class="hljs-meta"># 2.6 组合使用（了解）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块</title>
    <link href="/2021/10/28/%E6%A8%A1%E5%9D%97_hexo/"/>
    <url>/2021/10/28/%E6%A8%A1%E5%9D%97_hexo/</url>
    
    <content type="html"><![CDATA[<h3 id="时间相关命令"><a href="#时间相关命令" class="headerlink" title="时间相关命令"></a>时间相关命令</h3><p>时间分为三种格式</p><p>1.时间戳：从1970年到现在的秒数</p><p>​            time.time</p><p>2.格式化的字符串形式</p><p>​            time.strftime(‘%Y-%m-%d %H:%M%S %p’)</p><p>3.结构化的时间</p><p>​            res=time.localtime</p><p>​            print(res)</p><p>​            print(res.tm_year)</p><p>4.datetime</p><p>​    import datetime</p><p>​    print(datetime.datetime.now())</p><p>​    直接获取到格式化的时间格式</p><h3 id="时间格式的转换"><a href="#时间格式的转换" class="headerlink" title="时间格式的转换"></a>时间格式的转换</h3><p>时间格式转换是其三种时间格式的相互转换，结构化时间（struct_time）,时间戳（timestamp）,格式化的字符串（format_string）</p><h4 id="struct-time转换成时间戳"><a href="#struct-time转换成时间戳" class="headerlink" title="struct_time转换成时间戳"></a>struct_time转换成时间戳</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import <span class="hljs-selector-tag">time</span><br>s_time=<span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.localtime</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.mktime(s_time)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="时间戳转换成struct-time"><a href="#时间戳转换成struct-time" class="headerlink" title="时间戳转换成struct_time"></a>时间戳转换成struct_time</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tp_time=<span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.time</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.localtime(tp_time)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="strcut-time转换成格式化的字符串"><a href="#strcut-time转换成格式化的字符串" class="headerlink" title="strcut_time转换成格式化的字符串"></a>strcut_time转换成格式化的字符串</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">s_time=time.localtime()<br>time.strftime(&#x27;<span class="hljs-built_in">%Y</span>-<span class="hljs-built_in">%m</span>-<span class="hljs-built_in">%d</span> <span class="hljs-built_in">%H</span>:<span class="hljs-built_in">%M</span><span class="hljs-built_in">%S</span> <span class="hljs-built_in">%p</span>&#x27;,s_time)<br></code></pre></td></tr></table></figure><p>真正需要掌握的是format string &lt;—&gt; timestamp</p><h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import <span class="hljs-built_in">random</span><br><br>print(<span class="hljs-built_in">random</span>.<span class="hljs-built_in">random</span>()) <span class="hljs-comment">#的到0到1之间的小数</span><br>  <span class="hljs-built_in">random</span>.randint(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">#大于等于1小于等于3的数</span><br>  <span class="hljs-built_in">random</span>.randrange(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">#大于等于1 小于3 </span><br>     ~.choice(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;aaa&#x27;</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment">#定义几个数随机取一个</span><br>     ~.sample(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;23131d&#x27;</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">#列表元素任意2个组合</span><br>     ~.uniform(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">#大于1小于3 的小树</span><br>     <span class="hljs-keyword">item</span> =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>     <span class="hljs-built_in">random</span>.shuffle(<span class="hljs-keyword">item</span>)<span class="hljs-comment">#打乱顺序</span><br></code></pre></td></tr></table></figure><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><p>os模块是与操作系统交互的一个接口</p><blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径<br><span class="hljs-built_in">os</span>.chdir(<span class="hljs-string">&quot;dirname&quot;</span>)  改变当前脚本工作目录；相当于shell下cd<br><span class="hljs-built_in">os</span>.curdir  返回当前目录: (<span class="hljs-string">&#x27;.&#x27;</span>)<br><span class="hljs-built_in">os</span>.pardir  获取当前目录的父目录字符串名：(<span class="hljs-string">&#x27;..&#x27;</span>)<br><span class="hljs-built_in">os</span>.makedirs(<span class="hljs-string">&#x27;dirname1/dirname2&#x27;</span>)    可生成多层递归目录<br><span class="hljs-built_in">os</span>.removedirs(<span class="hljs-string">&#x27;dirname1&#x27;</span>)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推<br><span class="hljs-built_in">os</span>.mkdir(<span class="hljs-string">&#x27;dirname&#x27;</span>)    生成单级目录；相当于shell中mkdir dirname<br><span class="hljs-built_in">os</span>.rmdir(<span class="hljs-string">&#x27;dirname&#x27;</span>)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname<br><span class="hljs-built_in">os</span>.listdir(<span class="hljs-string">&#x27;dirname&#x27;</span>)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">remove</span>()  删除一个文件<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">rename</span>(<span class="hljs-string">&quot;oldname&quot;</span>,<span class="hljs-string">&quot;newname&quot;</span>)  重命名文件/目录<br><span class="hljs-built_in">os</span>.stat(<span class="hljs-string">&#x27;path/filename&#x27;</span>)  获取文件/目录信息<br><span class="hljs-built_in">os</span>.sep    输出操作系统特定的路径分隔符，win下为<span class="hljs-string">&quot;\\&quot;</span>,Linux下为<span class="hljs-string">&quot;/&quot;</span><br><span class="hljs-built_in">os</span>.linesep    输出当前平台使用的行终止符，win下为<span class="hljs-string">&quot;\t\n&quot;</span>,Linux下为<span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-built_in">os</span>.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:<br><span class="hljs-built_in">os</span>.name    输出字符串指示当前使用平台。win-&gt;<span class="hljs-string">&#x27;nt&#x27;</span>; Linux-&gt;<span class="hljs-string">&#x27;posix&#x27;</span><br><span class="hljs-built_in">os</span>.system(<span class="hljs-string">&quot;bash command&quot;</span>)  运行shell命令，直接显示<br><span class="hljs-built_in">os</span>.environ  获取系统环境变量<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(<span class="hljs-built_in">path</span>)  返回<span class="hljs-built_in">path</span>规范化的绝对路径<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">path</span>)  将<span class="hljs-built_in">path</span>分割成目录和文件名二元组返回<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.dirname(<span class="hljs-built_in">path</span>)  返回<span class="hljs-built_in">path</span>的目录。其实就是<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">path</span>)的第一个元素<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.basename(<span class="hljs-built_in">path</span>)  返回<span class="hljs-built_in">path</span>最后的文件名。如何<span class="hljs-built_in">path</span>以／或\结尾，那么就会返回空值。即<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">path</span>)的第二个元素<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.exists(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>存在，返回True；如果<span class="hljs-built_in">path</span>不存在，返回False<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isabs(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>是绝对路径，返回True<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isfile(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>是一个存在的文件，返回True。否则返回False<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>是一个存在的目录，则返回True。否则返回False<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.getatime(<span class="hljs-built_in">path</span>)  返回<span class="hljs-built_in">path</span>所指向的文件或者目录的最后存取时间<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.getmtime(<span class="hljs-built_in">path</span>)  返回<span class="hljs-built_in">path</span>所指向的文件或者目录的最后修改时间<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.getsize(<span class="hljs-built_in">path</span>) 返回<span class="hljs-built_in">path</span>的大小<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">在Linux和Mac平台上，该函数会原样返回<span class="hljs-built_in">path</span>，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。<br>&gt;&gt;&gt; <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.normcase(<span class="hljs-string">&#x27;c:/windows\\system32\\&#x27;</span>)   <br><span class="hljs-string">&#x27;c:\\windows\\system32\\&#x27;</span>   <br>   <br><br>规范化路径，如..和/<br>&gt;&gt;&gt; <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.normpath(<span class="hljs-string">&#x27;c://windows\\System32\\../Temp/&#x27;</span>)   <br><span class="hljs-string">&#x27;c:\\windows\\Temp&#x27;</span>   <br><br>&gt;&gt;&gt; a=<span class="hljs-string">&#x27;/Users/jieli/test1/\\\a1/\\\\aa.py/../..&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.normpath(a))<br>/Users/jieli/test1<br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>路径处理<br>#方式一：推荐使用<br>import <span class="hljs-built_in">os</span><br>#具体应用<br>import <span class="hljs-built_in">os</span>,sys<br>possible_topdir = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.normpath(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<br>    <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(__file__),<br>    <span class="hljs-built_in">os</span>.pardir, #上一级<br>    <span class="hljs-built_in">os</span>.pardir,<br>    <span class="hljs-built_in">os</span>.pardir<br>))<br>sys.<span class="hljs-built_in">path</span>.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,possible_topdir)<br><br><br>#方式二：不推荐使用<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.dirname(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.dirname(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.dirname(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(__file__))))<br><br></code></pre></td></tr></table></figure><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import sys<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(sys.argv)</span></span><br></code></pre></td></tr></table></figure><p>sys.argv用于获取向文件传递的参数</p><p>例如：</p><p>python3 run.py 1 2 3</p><p>其中的1, 2,3就分别是三个参数</p><p>sys.argv[0]为文件名， 123，分别就是后面对应的位置参数。</p><p>例如:</p><p>以argv来实现cp命令（cp 源文件 目标文件），实现复制粘贴文件的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>cs_1=sys.argv[<span class="hljs-number">1</span>]<br>cs_2=sys.argv[<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;%s&#x27;</span> %cs_1,mode=<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> file1:<br>        a=file1.read()<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;%s&#x27;</span> %cs_2,mode=<span class="hljs-string">&quot;wb+&quot;</span>) <span class="hljs-keyword">as</span> file2:<br>            b=file2.write(a)<br><span class="hljs-keyword">except</span> IOError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有该文件&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;内容写入文件成功&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行效果：（得在Windows命令行console执行）</p><p>(pyproject) E:\pyproject\py_study1&gt;python study1.py upload_file.py 2.py<br>内容写入文件成功</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20210924160248941.png" alt="image-20210924160248941"></p><h2 id="打印进度条："><a href="#打印进度条：" class="headerlink" title="打印进度条："></a>打印进度条：</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">import time<br><span class="hljs-keyword">res</span> = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br><span class="hljs-keyword">res</span>+=<span class="hljs-string">&#x27;#&#x27;</span><br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">0.5</span>)<br><span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;\r[%-50s]&#x27;</span> % <span class="hljs-keyword">res</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>#%s 为百分号替代符号，中间的-<span class="hljs-number">50</span>，-为左对齐，<span class="hljs-number">50</span>为其长度固定为<span class="hljs-number">50</span>，由于只输出一行，让其为每次叠加一个#的进度条，所以其换行符为空，并且\r跳到其行首，使其覆盖<br></code></pre></td></tr></table></figure><h3 id="模拟打印下载进度条："><a href="#模拟打印下载进度条：" class="headerlink" title="模拟打印下载进度条："></a>模拟打印下载进度条：</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mel">import time<br>recv_size=<span class="hljs-number">0</span><br><br>total_size=<span class="hljs-number">30000</span><br><br><span class="hljs-keyword">while</span> recv_size &lt; total_size:<br>time.sleep(<span class="hljs-number">0.1</span>)<br>recv_size+=<span class="hljs-number">1024</span><br><br><span class="hljs-keyword">percent</span>= recv_size / total_size<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">percent</span> &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">percent</span> = <span class="hljs-number">1</span><br>res= <span class="hljs-keyword">int</span>(<span class="hljs-number">50</span> * <span class="hljs-keyword">percent</span>) * <span class="hljs-string">&#x27;#&#x27;</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;\r[%-50s] %d%%&#x27;</span>) % (res,<span class="hljs-keyword">int</span>(<span class="hljs-number">100</span>*<span class="hljs-keyword">percent</span>)),end=<span class="hljs-string">&#x27;&#x27;</span>)<br>#recv_size和total_size模拟其文件大小以及已下载的数据大小<br>#sleep模拟下载速度，使其不会太快加载完。<br>#recv_size/total_size得到的分数为其下载进度，\r[%-<span class="hljs-number">50</span>s]为其打印进度条，%d%%显示百分比，百分比为其下载进度分数x100.但recv_size一直累加可能会超出总大小本身，其比例也会超过<span class="hljs-number">100</span>%，这是可以用<span class="hljs-keyword">if</span> 判断其大于<span class="hljs-number">1</span>时使其等于<span class="hljs-number">1.</span><br><br></code></pre></td></tr></table></figure><h2 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h2><p>引入： import shutil</p><p>copy()<br>功能：复制文件<br>格式：shutil.copy(‘来源文件’,’目标地址’)<br>返回值：复制之后的路径</p><p>copy2()<br>功能：复制文件，保留元数据<br>格式：shutil.copy2(‘来源文件’,’目标地址’)<br>返回值：复制之后的路径</p><p>copyfileobj()<br>将一个文件的内容拷贝的另外一个文件当中<br>格式：shutil.copyfileobj(open(来源文件,’r’),open（’目标文件’,’w’）)<br>返回值：无</p><p>copyfile()<br>功能：将一个文件的内容拷贝的另外一个文件当中<br>格式:shutil.copyfile(来源文件,目标文件)<br>返回值：目标文件的路径</p><p>copytree()<br>功能：复制整个文件目录<br>格式:shutil.copytree(来源目录,目标目录)<br>返回值：目标目录的路径<br>注意：无论文件夹是否为空，均可以复制，而且会复制文件夹中的所有内容</p><p>copymode()<br>功能：拷贝权限</p><p>copystat()<br>功能：拷贝元数据（状态）</p><p>rmtree()<br>功能：移除整个目录，无论是否空<br>格式：shutil.rmtree(目录路径)<br>返回值：无</p><p>move()<br>功能：移动文件或者文件夹<br>格式：shutil.move(来源地址,目标地址)<br>返回值：目标地址</p><p>which()<br>功能：检测命令对应的文件路径<br>格式：shutil.which(‘命令字符串’)<br>返回值：命令文件所在位置<br>注意：window和linux不太一样。 window的命令都是.exe结尾，linux则不是</p><p>disk_usage()<br>功能：检测磁盘使用信息<br>格式：disk_usage(‘盘符’)<br>返回值：元组</p><p>归档和解包操作<br>归档：将多个文件合并到一个文件当中，这种操作方式就是归档。</p><p>解包：将归档的文件进行释放。</p><p>压缩：压缩时将多个文件进行有损或者无损的合并到一个文件当中。</p><p>解压缩：就是压缩的反向操作，将压缩文件中的多个文件，释放出来。</p><p>注意：压缩属于归档！<br>        make_archive()<br>功能：归档函数，归档操作<br>格式：shutil.make_archive(‘目标文件路径’,’归档文件后缀’,’需要归档的目录’)<br>返回值：归档文件的最终路径</p><p>unpack_archive()<br>功能：解包操作<br>格式：shutil.unpack_archive(‘归档文件路径’,’解包目标文件夹’)<br>返回值:None<br>注意：文件夹不存在会新建文件夹</p><p>get_archive_formats()<br>功能：获取当前系统已注册的归档文件格式（后缀）<br>格式：shutil.get_archive_formats()</p><p>get_unpack_formats()<br>功能：获取当前系统已经注册的解包文件格式(后缀)<br>格式:shutil.get_unpack_formats()<br>返回值：列表   [(后缀,解释),(后缀,解释),(后缀,解释)…]</p><h2 id="json-amp-pickle模块"><a href="#json-amp-pickle模块" class="headerlink" title="json&amp;pickle模块"></a>json&amp;pickle模块</h2><p>之前我们学习过用eval内置方法可以将一个字符串转成python对象，不过，eval方法是有局限性的，对于普通的数据类型，json.loads和eval都能用，但遇到特殊类型的时候，eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式，并返回表达式的值。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>import json<br><span class="hljs-symbol">2 </span>x=<span class="hljs-string">&quot;[null,true,false,1]&quot;</span><br><span class="hljs-symbol">3 </span><span class="hljs-keyword">print</span>(eval(x)) #报错，无法解析null类型，而json就可以<br><span class="hljs-symbol">4 </span><span class="hljs-keyword">print</span>(json.loads(x)) <br></code></pre></td></tr></table></figure><p><strong>什么是序列化？</strong></p><p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p><strong>为什么要序列化？</strong></p><p>1：持久保存状态</p><p>需知一个软件/程序的执行就在处理一系列状态的变化，在编程语言中，’状态’会以各种各样有结构的数据类型(也可简单的理解为变量)的形式被保存在内存中。</p><p>内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序的之前一段时间的数据（有结构）都被清空了。</p><p>在断电或重启程序之前将程序当前内存中所有的数据都保存下来（保存到文件中），以便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。</p><p>具体的来说，你玩使命召唤闯到了第13关，你保存游戏状态，关机走人，下次再玩，还能从上次的位置开始继续闯关。或如，虚拟机状态的挂起等。</p><p>2：跨平台数据交互</p><p>序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好实用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p><h3 id="json"><a href="#json" class="headerlink" title="json"></a><strong>json</strong></h3><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20210927145134605.png" alt="image-20210927145134605"></p><h3 id="如何序列化与反序列化"><a href="#如何序列化与反序列化" class="headerlink" title="如何序列化与反序列化"></a>如何序列化与反序列化</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import json<br><span class="hljs-attribute">res</span>=json.dumps([1,<span class="hljs-string">&#x27;aaa&#x27;</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>])<br><span class="hljs-builtin-name">print</span>(res.type(res))<br><span class="hljs-attribute">l</span>=json.loads(res)<br><span class="hljs-builtin-name">print</span>(l,type(l))<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>[1, “aaa”, true, false] &lt;class ‘str’&gt;<br>        [1, ‘aaa’, True, False] &lt;class ‘list’&gt;</p><p>json.dumps是序列化转换，将列表转换为json格式，其格式变为了str。</p><p>json.loads是反序列化转换，将其又转回了原来的列表格式。</p><p>示例2：存储为json格式</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">import json<br><span class="hljs-keyword">res</span>=json.dumps([<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;aaa&#x27;</span>,True,False])<br>with <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;1.json&quot;</span>,<span class="hljs-keyword">mode</span>=<span class="hljs-string">&quot;wt&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">file</span>:<br>    <span class="hljs-keyword">file</span>.<span class="hljs-keyword">write</span>(<span class="hljs-keyword">res</span>)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20210927151042187.png" alt="image-20210927151042187"></p><p>再读取json格式将其反序列化转换成原格式：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import json<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;1.json&quot;</span>,mode=<span class="hljs-string">&#x27;rt&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-keyword">a</span>=<span class="hljs-built_in">file</span>.<span class="hljs-built_in">read</span>()<br>    b=json.loads(<span class="hljs-keyword">a</span>)<br>    print(b)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>[1, ‘aaa’, True, False]</p><p>简单方法实现：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> json<br>with open(<span class="hljs-string">&quot;1.json&quot;</span>,mode=<span class="hljs-string">&quot;wt&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) as <span class="hljs-keyword">file</span>:<br>    json.<span class="hljs-keyword">dump</span>([<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>],<span class="hljs-keyword">file</span>)<br>    <br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import json<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;1.json&quot;</span>,mode=<span class="hljs-string">&#x27;rt&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    l=json.<span class="hljs-built_in">load</span>(<span class="hljs-built_in">file</span>)<br>    print(l)<br></code></pre></td></tr></table></figure><p>dump和load可以省略其文件的write和read方法</p><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> pickle<br><span class="hljs-attribute">res</span>=pickle.dumps(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;)<br><span class="hljs-attribute">print</span>(res,type(res))<br></code></pre></td></tr></table></figure><p>将python序列化转换成pickle形式，反序列化为loads，与json一致。</p><h2 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a>configparser模块</h2><p><strong>配置文件如下：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 注释1</span><br>; 注释2<br><br>[section1]<br>k1 = v1<br>k2:v2<br><span class="hljs-attribute">user</span>=egon<br><span class="hljs-attribute">age</span>=18<br><span class="hljs-attribute">is_admin</span>=<span class="hljs-literal">true</span><br><span class="hljs-attribute">salary</span>=31<br>[section2]<br>k1 = v1<br></code></pre></td></tr></table></figure><p><strong>读取</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import configparser<br><br>config=configparser<span class="hljs-selector-class">.ConfigParser</span>()<br>config<span class="hljs-selector-class">.read</span>(<span class="hljs-string">&#x27;a.cfg&#x27;</span>)<br><br>#查看所有的标题<br>res=config<span class="hljs-selector-class">.sections</span>() #<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;section1&#x27;</span>, <span class="hljs-string">&#x27;section2&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(res)</span></span><br><br>#查看标题section1下所有key=value的key<br>options=config<span class="hljs-selector-class">.options</span>(<span class="hljs-string">&#x27;section1&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(options)</span></span> #<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;k1&#x27;</span>, <span class="hljs-string">&#x27;k2&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;is_admin&#x27;</span>, <span class="hljs-string">&#x27;salary&#x27;</span>]</span><br><br>#查看标题section1下所有key=value的(key,value)格式<br>item_list=config<span class="hljs-selector-class">.items</span>(<span class="hljs-string">&#x27;section1&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(item_list)</span></span> #<span class="hljs-selector-attr">[(<span class="hljs-string">&#x27;k1&#x27;</span>, <span class="hljs-string">&#x27;v1&#x27;</span>), (<span class="hljs-string">&#x27;k2&#x27;</span>, <span class="hljs-string">&#x27;v2&#x27;</span>), (<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;egon&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>), (<span class="hljs-string">&#x27;is_admin&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>), (<span class="hljs-string">&#x27;salary&#x27;</span>, <span class="hljs-string">&#x27;31&#x27;</span>)]</span><br><br>#查看标题section1下user的值=&gt;字符串格式<br>val=config<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;section1&#x27;</span>,<span class="hljs-string">&#x27;user&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(val)</span></span> <span class="hljs-selector-id">#egon</span><br><br>#查看标题section1下age的值=&gt;整数格式<br>val1=config<span class="hljs-selector-class">.getint</span>(<span class="hljs-string">&#x27;section1&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(val1)</span></span> #<span class="hljs-number">18</span><br><br>#查看标题section1下is_admin的值=&gt;布尔值格式<br>val2=config<span class="hljs-selector-class">.getboolean</span>(<span class="hljs-string">&#x27;section1&#x27;</span>,<span class="hljs-string">&#x27;is_admin&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(val2)</span></span> <span class="hljs-selector-id">#True</span><br><br>#查看标题section1下salary的值=&gt;浮点型格式<br>val3=config<span class="hljs-selector-class">.getfloat</span>(<span class="hljs-string">&#x27;section1&#x27;</span>,<span class="hljs-string">&#x27;salary&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(val3)</span></span> #<span class="hljs-number">31.0</span><br></code></pre></td></tr></table></figure><p><strong>改写</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import configparser<br><br><span class="hljs-attribute">config</span>=configparser.ConfigParser()<br>config.read(<span class="hljs-string">&#x27;a.cfg&#x27;</span>,<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><br><span class="hljs-comment">#删除整个标题section2</span><br>config.remove_section(<span class="hljs-string">&#x27;section2&#x27;</span>)<br><br><span class="hljs-comment">#删除标题section1下的某个k1和k2</span><br>config.remove_option(<span class="hljs-string">&#x27;section1&#x27;</span>,<span class="hljs-string">&#x27;k1&#x27;</span>)<br>config.remove_option(<span class="hljs-string">&#x27;section1&#x27;</span>,<span class="hljs-string">&#x27;k2&#x27;</span>)<br><br><span class="hljs-comment">#判断是否存在某个标题</span><br><span class="hljs-builtin-name">print</span>(config.has_section(<span class="hljs-string">&#x27;section1&#x27;</span>))<br><br><span class="hljs-comment">#判断标题section1下是否有user</span><br><span class="hljs-builtin-name">print</span>(config.has_option(<span class="hljs-string">&#x27;section1&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>))<br><br><br><span class="hljs-comment">#添加一个标题</span><br>config.add_section(<span class="hljs-string">&#x27;egon&#x27;</span>)<br><br><span class="hljs-comment">#在标题egon下添加name=egon,age=18的配置</span><br>config.<span class="hljs-builtin-name">set</span>(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;egon&#x27;</span>)<br>config.<span class="hljs-builtin-name">set</span>(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>,18) #报错,必须是字符串<br><br><br><span class="hljs-comment">#最后将修改的内容写入文件,完成最终的修改</span><br>config.write(open(<span class="hljs-string">&#x27;a.cfg&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>))<br></code></pre></td></tr></table></figure><p>基于上述方法添加一个ini文档</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua">import configparser<br>  <br><span class="hljs-built_in">config</span> = configparser.ConfigParser()<br><span class="hljs-built_in">config</span>[<span class="hljs-string">&quot;DEFAULT&quot;</span>] = &#123;<span class="hljs-string">&#x27;ServerAliveInterval&#x27;</span>: <span class="hljs-string">&#x27;45&#x27;</span>,<br>                      <span class="hljs-string">&#x27;Compression&#x27;</span>: <span class="hljs-string">&#x27;yes&#x27;</span>,<br>                     <span class="hljs-string">&#x27;CompressionLevel&#x27;</span>: <span class="hljs-string">&#x27;9&#x27;</span>&#125;<br>  <br><span class="hljs-built_in">config</span>[<span class="hljs-string">&#x27;bitbucket.org&#x27;</span>] = &#123;&#125;<br><span class="hljs-built_in">config</span>[<span class="hljs-string">&#x27;bitbucket.org&#x27;</span>][<span class="hljs-string">&#x27;User&#x27;</span>] = <span class="hljs-string">&#x27;hg&#x27;</span><br><span class="hljs-built_in">config</span>[<span class="hljs-string">&#x27;topsecret.server.com&#x27;</span>] = &#123;&#125;<br>topsecret = <span class="hljs-built_in">config</span>[<span class="hljs-string">&#x27;topsecret.server.com&#x27;</span>]<br>topsecret[<span class="hljs-string">&#x27;Host Port&#x27;</span>] = <span class="hljs-string">&#x27;50022&#x27;</span>     # mutates the parser<br>topsecret[<span class="hljs-string">&#x27;ForwardX11&#x27;</span>] = <span class="hljs-string">&#x27;no&#x27;</span>  # same here<br><span class="hljs-built_in">config</span>[<span class="hljs-string">&#x27;DEFAULT&#x27;</span>][<span class="hljs-string">&#x27;ForwardX11&#x27;</span>] = <span class="hljs-string">&#x27;yes&#x27;</span><br>with <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.ini&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) as configfile:<br>   <span class="hljs-built_in">config</span>.<span class="hljs-built_in">write</span>(configfile)<br></code></pre></td></tr></table></figure><h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、什么叫<span class="hljs-built_in">hash</span>:<span class="hljs-built_in">hash</span>是一种算法（3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法），该算法接受传入的内容，经过运算得到一串<span class="hljs-built_in">hash</span>值</span><br><span class="hljs-meta">#</span><span class="bash"> 2、<span class="hljs-built_in">hash</span>值的特点是：</span><br><span class="hljs-meta">#</span><span class="bash">2.1 只要传入的内容一样，得到的<span class="hljs-built_in">hash</span>值必然一样=====&gt;要用明文传输密码文件完整性校验</span><br><span class="hljs-meta">#</span><span class="bash">2.2 不能由<span class="hljs-built_in">hash</span>值返解成内容=======》把密码做成<span class="hljs-built_in">hash</span>值，不应该在网络传输明文密码</span><br><span class="hljs-meta">#</span><span class="bash">2.3 只要使用的<span class="hljs-built_in">hash</span>算法不变，无论校验的内容有多大，得到的<span class="hljs-built_in">hash</span>值长度是固定的</span><br></code></pre></td></tr></table></figure><p> hash算法就像一座工厂，工厂接收你送来的原材料（可以用m.update()为工厂运送原材料），经过加工返回的产品就是hash值</p><p><img src="https://yinshiweiysw.github.io/images/assets/1036857-20180410101832069-1144106861.png" alt="img"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">1</span> import hashlib<br> <span class="hljs-attribute">2</span>  <br> <span class="hljs-attribute">3</span> m=hashlib.md<span class="hljs-number">5</span>()# m=hashlib.sha<span class="hljs-number">256</span>()<br> <span class="hljs-attribute">4</span>  <br> <span class="hljs-attribute">5</span> m.update(&#x27;hello&#x27;.encode(&#x27;utf<span class="hljs-number">8</span>&#x27;))<br> <span class="hljs-attribute">6</span> print(m.hexdigest())  #<span class="hljs-number">5</span>d<span class="hljs-number">41402</span>abc<span class="hljs-number">4</span>b<span class="hljs-number">2</span>a<span class="hljs-number">76</span>b<span class="hljs-number">9719</span>d<span class="hljs-number">911017</span>c<span class="hljs-number">592</span><br> <span class="hljs-attribute">7</span>  <br> <span class="hljs-attribute">8</span> m.update(&#x27;alvin&#x27;.encode(&#x27;utf<span class="hljs-number">8</span>&#x27;))<br> <span class="hljs-attribute">9</span>  <br><span class="hljs-attribute">10</span> print(m.hexdigest())  #<span class="hljs-number">92</span>a<span class="hljs-number">7</span>e<span class="hljs-number">713</span>c<span class="hljs-number">30</span>abbb<span class="hljs-number">0319</span>fa<span class="hljs-number">07</span>da<span class="hljs-number">2</span>a<span class="hljs-number">5</span>c<span class="hljs-number">4</span>af<br><span class="hljs-attribute">11</span>  <br><span class="hljs-attribute">12</span> m<span class="hljs-number">2</span>=hashlib.md<span class="hljs-number">5</span>()<br><span class="hljs-attribute">13</span> m<span class="hljs-number">2</span>.update(&#x27;helloalvin&#x27;.encode(&#x27;utf<span class="hljs-number">8</span>&#x27;))<br><span class="hljs-attribute">14</span> print(m<span class="hljs-number">2</span>.hexdigest()) #<span class="hljs-number">92</span>a<span class="hljs-number">7</span>e<span class="hljs-number">713</span>c<span class="hljs-number">30</span>abbb<span class="hljs-number">0319</span>fa<span class="hljs-number">07</span>da<span class="hljs-number">2</span>a<span class="hljs-number">5</span>c<span class="hljs-number">4</span>af<br><span class="hljs-attribute">15</span> <br><span class="hljs-attribute">16</span> &#x27;&#x27;&#x27;<br><span class="hljs-attribute">17</span> 注意：把一段很长的数据update多次，与一次update这段长数据，得到的结果一样<br><span class="hljs-attribute">18</span> 但是update多次为校验大文件提供了可能。<br><span class="hljs-attribute">19</span> &#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><p>以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>import hashlib<br><span class="hljs-symbol">2 </span> <br><span class="hljs-symbol">3 </span># ######## <span class="hljs-number">256</span> ########<br><span class="hljs-symbol">4 </span> <br><span class="hljs-symbol">5 </span>hash = hashlib.sha256(<span class="hljs-comment">&#x27;898oaFs09f&#x27;.encode(&#x27;utf8&#x27;))</span><br><span class="hljs-symbol">6 </span>hash.update(<span class="hljs-comment">&#x27;alvin&#x27;.encode(&#x27;utf8&#x27;))</span><br><span class="hljs-symbol">7 </span><span class="hljs-keyword">print</span> (hash.hexdigest())#e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7<br></code></pre></td></tr></table></figure><p>python 还有一个 hmac 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import hmac<br>h1=hmac<span class="hljs-selector-class">.new</span>(<span class="hljs-string">&#x27;hello&#x27;</span><span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>),digestmod=<span class="hljs-string">&#x27;md5&#x27;</span>)<br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.update</span>(<span class="hljs-string">&#x27;world&#x27;</span><span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(h1.hexdigest()</span></span>)<br></code></pre></td></tr></table></figure><h2 id="suprocess模块"><a href="#suprocess模块" class="headerlink" title="suprocess模块"></a>suprocess模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-number">1</span> <span class="hljs-keyword">import</span>  subprocess<br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span> <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"> 4 sh-3.2# ls /Users/egon/Desktop |grep txt$</span><br><span class="hljs-string"> 5 mysql.txt</span><br><span class="hljs-string"> 6 tt.txt</span><br><span class="hljs-string"> 7 事物.txt</span><br><span class="hljs-string"> 8 &#x27;&#x27;&#x27;</span><br> <span class="hljs-number">9</span> <br><span class="hljs-number">10</span> res1=subprocess.Popen(<span class="hljs-string">&#x27;ls /Users/jieli/Desktop&#x27;</span>,shell=<span class="hljs-literal">True</span>,stdout=subprocess.PIPE)<br><span class="hljs-number">11</span> res=subprocess.Popen(<span class="hljs-string">&#x27;grep txt$&#x27;</span>,shell=<span class="hljs-literal">True</span>,stdin=res1.stdout,<br><span class="hljs-number">12</span>                  stdout=subprocess.PIPE)<br><span class="hljs-number">13</span> <br><span class="hljs-number">14</span> <span class="hljs-built_in">print</span>(res.stdout.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-number">15</span> <br><span class="hljs-number">16</span> <br><span class="hljs-number">17</span> <span class="hljs-comment">#等同于上面,但是上面的优势在于,一个数据流可以和另外一个数据流交互,可以通过爬虫得到结果然后交给grep</span><br><span class="hljs-number">18</span> res1=subprocess.Popen(<span class="hljs-string">&#x27;ls /Users/jieli/Desktop |grep txt$&#x27;</span>,shell=<span class="hljs-literal">True</span>,stdout=subprocess.PIPE)<br><span class="hljs-number">19</span> <span class="hljs-built_in">print</span>(res1.stdout.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-number">20</span> <br><span class="hljs-number">21</span> <br><span class="hljs-number">22</span> <span class="hljs-comment">#windows下:</span><br><span class="hljs-number">23</span> <span class="hljs-comment"># dir | findstr &#x27;test*&#x27;</span><br><span class="hljs-number">24</span> <span class="hljs-comment"># dir | findstr &#x27;txt$&#x27;</span><br><span class="hljs-number">25</span> <span class="hljs-keyword">import</span> subprocess<br><span class="hljs-number">26</span> res1=subprocess.Popen(<span class="hljs-string">r&#x27;dir C:\Users\Administrator\PycharmProjects\test\函数备课&#x27;</span>,shell=<span class="hljs-literal">True</span>,stdout=subprocess.PIPE)<br><span class="hljs-number">27</span> res=subprocess.Popen(<span class="hljs-string">&#x27;findstr test*&#x27;</span>,shell=<span class="hljs-literal">True</span>,stdin=res1.stdout,<br><span class="hljs-number">28</span>                  stdout=subprocess.PIPE)<br><span class="hljs-number">29</span> <br><span class="hljs-number">30</span> <span class="hljs-built_in">print</span>(res.stdout.read().decode(<span class="hljs-string">&#x27;gbk&#x27;</span>)) <span class="hljs-comment">#subprocess使用当前系统默认编码，得到结果为bytes类型，在windows下需要用gbk解码</span><br></code></pre></td></tr></table></figure><h2 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h2><h3 id="1-日志级别以及模块"><a href="#1-日志级别以及模块" class="headerlink" title="1.日志级别以及模块"></a>1.日志级别以及模块</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span>logging.<span class="hljs-builtin-name">debug</span>(<span class="hljs-string">&quot;调试&quot;</span>)<br>logging.<span class="hljs-builtin-name">info</span>(<span class="hljs-string">&quot;消息信息&quot;</span>)<br>logging.<span class="hljs-builtin-name">warning</span>(<span class="hljs-string">&quot;警告信息&quot;</span>)<br>logging.<span class="hljs-builtin-name">error</span>(<span class="hljs-string">&quot;错误error信息&quot;</span>)<br>logging.critical(<span class="hljs-string">&quot;严重信息&quot;</span>)<br></code></pre></td></tr></table></figure><p>logging为模块名，有5种输出级别，对应调试，信息，警告，错误，严重错误。</p><p>该段代码运行效果：</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20211008145648843.png" alt="image-20211008145648843"></p><p>logging.告警级别 本质上就是直接在对应位置输出对应信息，信息内容包含在括号里面，这里打印时默认只输出了warning及其以上的信息，说明默认输出日志级别为warning。</p><h3 id="logging-basicConfig"><a href="#logging-basicConfig" class="headerlink" title="logging.basicConfig"></a>logging.basicConfig</h3><p>#======介绍<br>    可在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有<br>    filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。<br>    filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。<br>    format：指定handler使用的日志显示格式。<br>    datefmt：指定日期时间格式。<br>    level：设置rootlogger（后边会讲解具体概念）的日志级别<br>    stream：用指定的stream创建StreamHandler。可以指定输出到    sys.stderr,sys.stdout或者文件，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p><p>format参数中可能用到的格式化串：<br>%(name)s Logger的名字<br>%(levelno)s 数字形式的日志级别<br>%(levelname)s 文本形式的日志级别<br>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有<br>%(filename)s 调用日志输出函数的模块的文件名<br>%(module)s 调用日志输出函数的模块名<br>%(funcName)s 调用日志输出函数的函数名<br>%(lineno)d 调用日志输出函数的语句所在的代码行<br>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示<br>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数<br>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒<br>%(thread)d 线程ID。可能没有<br>%(threadName)s 线程名。可能没有<br>%(process)d 进程ID。可能没有<br>%(message)s用户输出的消息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br><br><br><br><span class="hljs-comment">#========使用</span><br>import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span>logging.basicConfig(<span class="hljs-attribute">filename</span>=<span class="hljs-string">&#x27;access.log&#x27;</span>,<br>                    <span class="hljs-attribute">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&#x27;</span>,<br>                    <span class="hljs-attribute">datefmt</span>=<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S %p&#x27;</span>,<br>                    <span class="hljs-attribute">level</span>=10)<br><br>logging.<span class="hljs-builtin-name">debug</span>(<span class="hljs-string">&#x27;调试debug&#x27;</span>)<br>logging.<span class="hljs-builtin-name">info</span>(<span class="hljs-string">&#x27;消息info&#x27;</span>)<br>logging.<span class="hljs-builtin-name">warning</span>(<span class="hljs-string">&#x27;警告warn&#x27;</span>)<br>logging.<span class="hljs-builtin-name">error</span>(<span class="hljs-string">&#x27;错误error&#x27;</span>)<br>logging.critical(<span class="hljs-string">&#x27;严重critical&#x27;</span>)<br><br><br>part2: 可以为logging模块指定模块级的配置,即所有logger的配置<br></code></pre></td></tr></table></figure><p>filename指定了日志文件，format指定其日志输出格式，datefmt指定日志输出时间的格式，level指定其日志输出级别，默认为30</p><p><strong>level为10,20,30,40,50，对应调试，信息，警告，错误和严重错误。</strong></p><h4 id="日志输出结果："><a href="#日志输出结果：" class="headerlink" title="日志输出结果："></a>日志输出结果：</h4><p><img src="https://yinshiweiysw.github.io/images/assets/image-20211008151019274.png" alt="image-20211008151019274"></p><p>如果这里不指定filename则默认输出到pycharm屏幕（python屏幕）</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20211008151301307.png" alt="image-20211008151301307"></p><h3 id="日志字典"><a href="#日志字典" class="headerlink" title="日志字典"></a>日志字典</h3><p>其作用为让日志在读取格式时直接通过自身模块从字典里读取形成多种格式的方法，字典本身多个key固定的名称。</p><h4 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py:"></a>settings.py:</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs clean">standard_format = <span class="hljs-string">&#x27;%(asctime)s - %(threadName)s:%(thread)d - 日志名字:%(name)s - %(filename)s:%(lineno)d -&#x27;</span> \<br>                  <span class="hljs-string">&#x27;%(levelname)s - %(message)s&#x27;</span><br><br>simple_format = <span class="hljs-string">&#x27;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&#x27;</span><br><br>test_format = <span class="hljs-string">&#x27;%(asctime)s] %(message)s&#x27;</span><br><br># <span class="hljs-number">3</span>、日志配置字典<br>LOGGING_DIC = &#123;<br>    <span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-number">1</span>,  #版本，可以随意定义<br>    <span class="hljs-string">&#x27;disable_existing_loggers&#x27;</span>: <span class="hljs-literal">False</span>,  # 禁用已经存在的logger实例，固定格式<br>    <span class="hljs-string">&#x27;formatters&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;standard&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;format&#x27;</span>: standard_format<br>        &#125;,<br>        <span class="hljs-string">&#x27;simple&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;format&#x27;</span>: simple_format<br>        &#125;,<br>        <span class="hljs-string">&#x27;test&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;format&#x27;</span>: test_format<br>        &#125;,<br>    &#125;, # 定义日志 格式化的 工具，上面定义的standard_format，simple_format，test_format对应三种输出格式<br>    <span class="hljs-string">&#x27;filters&#x27;</span>: &#123;&#125;,# 过滤<br>    # handlers是日志的接收者，不同的handler会将日志输出到不同的位置<br>    <span class="hljs-string">&#x27;handlers&#x27;</span>: &#123;<br>        #打印到终端的日志<br>        <span class="hljs-string">&#x27;console&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,<br>            <span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;logging.StreamHandler&#x27;</span>,  # 打印到屏幕<br>            <span class="hljs-string">&#x27;formatter&#x27;</span>: <span class="hljs-string">&#x27;simple&#x27;</span><br>        &#125;,<br>        <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,<br>            <span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,  # 保存到文件<br>            # <span class="hljs-string">&#x27;maxBytes&#x27;</span>: <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">5</span>,  # 日志大小 <span class="hljs-number">5</span>M<br>            <span class="hljs-string">&#x27;maxBytes&#x27;</span>: <span class="hljs-number">1000</span>,<br>            <span class="hljs-string">&#x27;backupCount&#x27;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-string">&#x27;filename&#x27;</span>: <span class="hljs-string">&#x27;a1.log&#x27;</span>,  # os.path.join(os.path.dirname(os.path.dirname(__file__)),<span class="hljs-string">&#x27;log&#x27;</span>,<span class="hljs-string">&#x27;a2.log&#x27;</span>)<br>            <span class="hljs-string">&#x27;encoding&#x27;</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>            <span class="hljs-string">&#x27;formatter&#x27;</span>: <span class="hljs-string">&#x27;standard&#x27;</span>,<br><br>        &#125;,<br>        #打印到文件的日志,收集info及以上的日志<br>        <span class="hljs-string">&#x27;other&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,<br>            <span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;logging.FileHandler&#x27;</span>,  # 保存到文件<br>            <span class="hljs-string">&#x27;filename&#x27;</span>: <span class="hljs-string">&#x27;a2.log&#x27;</span>, # os.path.join(os.path.dirname(os.path.dirname(__file__)),<span class="hljs-string">&#x27;log&#x27;</span>,<span class="hljs-string">&#x27;a2.log&#x27;</span>)<br>            <span class="hljs-string">&#x27;encoding&#x27;</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>            <span class="hljs-string">&#x27;formatter&#x27;</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br><br>        &#125;,<br>    &#125;,<br>    # loggers是日志的产生者，产生的日志会传递给handler然后控制输出<br>    <span class="hljs-string">&#x27;loggers&#x27;</span>: &#123;<br>        #logging.getLogger(__name__)拿到的logger配置<br>        <span class="hljs-string">&#x27;kkk&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;console&#x27;</span>,<span class="hljs-string">&#x27;other&#x27;</span>],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕<br>            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>, # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制)<br>            <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">False</span>,  # 默认为<span class="hljs-literal">True</span>，向上（更高level的logger）传递，通常设置为<span class="hljs-literal">False</span>即可，否则会一份日志向上层层传递<br>        &#125;,<br>        <span class="hljs-string">&#x27;终端提示&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;console&#x27;</span>,],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕<br>            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,  # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制)<br>            <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">False</span>,  # 默认为<span class="hljs-literal">True</span>，向上（更高level的logger）传递，通常设置为<span class="hljs-literal">False</span>即可，否则会一份日志向上层层传递<br>        &#125;,<br>        <span class="hljs-string">&#x27;&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;default&#x27;</span>, ],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕<br>            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,  # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制)<br>            <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">False</span>,  # 默认为<span class="hljs-literal">True</span>，向上（更高level的logger）传递，通常设置为<span class="hljs-literal">False</span>即可，否则会一份日志向上层层传递<br>        &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="src-py-主文件-："><a href="#src-py-主文件-：" class="headerlink" title="src.py(主文件)："></a>src.py(主文件)：</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> logging #导入logging模块<br><br><span class="hljs-keyword">import</span> settings #导入settings文件，上面定义的settings.py<br><span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> config,getLogger  #导入config和getlogger 这里需要单独导入<br><br>config.dictConfig(settings.LOGGING_DIC) #LOGGING_DIC为字典名，这里settings导入字典名，然后dictconfig解析。固定格式，只需将LOGGING_DIC替换为需要的字典名即可<br>logger4=getLogger(<span class="hljs-string">&#x27;终端提示&#x27;</span>) #loggers为发送者，这里也是将日志输出者定义为对应的loggers，并将其定义成一个变量。<br>logger4.info(<span class="hljs-string">&#x27;logger4产生的info日志&#x27;</span>)#调用info发送日志。<br></code></pre></td></tr></table></figure><h4 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤:"></a>代码步骤:</h4><h5 id="settings-py-1"><a href="#settings-py-1" class="headerlink" title="settings.py:"></a>settings.py:</h5><p>standard_format,simple_format,test_format定义三种输出格式</p><p><strong>LOGGING_DIC</strong>:</p><p>​    字典定义了日志输出相关配置</p><p>1.version，disable_existing_loggers 其格式固定就行</p><p>2.formatters 其中key也是固定的，里面定义了三种日志输出格式，这里里面的key和value都是自己定义的，其三种value也对应一开始定义的三种变量。</p><p>3.filters 略（过滤）</p><p>4.handlers：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">handlers是日志的接收者，不同的<span class="hljs-keyword">handler</span>会将日志输出到不同的位置<br></code></pre></td></tr></table></figure><p>这里定义了两种输出位置。level为输出级别，class为输出方式，formatter为其对应输出格式,filename输出文件,encoding输出字符。这里相当于定义其日志输出位置以及将上面定义的日志输出格式赋给日志这个日志输出位置。</p><p>5.loggers：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># loggers是日志的产生者，产生的日志会传递给handler然后控制输出</span><br></code></pre></td></tr></table></figure><p>这里loggers与handlers相当于是下级对上级，loggers产生日志，handlers接受日志，两边都可以设置其level，如果loggers的level低于handlers，那么实际日志输出只会根据handlers的level来进行输出（因为loggers发送了低于handlers的日志，但handlers只会接受并输出自己的level以上的。），正常情况两边level应一致。</p><p>handlers定义其输出位置（方式），level为其输出级别，propagate固定false。</p><p>如果定义的loggers为空 ‘’ 的话，后面在使用getlogger找不到loggers的所有日志名都会匹配到空。</p><h5 id="src-py"><a href="#src-py" class="headerlink" title="src.py"></a>src.py</h5><p>如上备注所示。</p><p><strong>其本身格式基本上为固定，直接拿着两个文件稍作修改就可以用于各种工作场景，无需过分理解，能看懂代码格式即可</strong></p><p><strong>日志字典本身就算是python日志的功能之一，所以其字典里面需要定义固定的key让其logging模块去解析它。而非自己定义一个字典再自己去解析，其格式固定。</strong></p><p>字典顺序：</p><p>loggers（日志输出者）-》handlers（接受者）-》formatters（日志输出格式（standard_format,simple_format,test_format）</p><h3 id="日志轮转："><a href="#日志轮转：" class="headerlink" title="日志轮转："></a>日志轮转：</h3><p>相当于日志备份，logging自带日志备份，可以设置日志最大大小和备份日志最大个数</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20211009154143282.png" alt="image-20211009154143282"></p><p>在字典handlers中有两个设置：maxbytes和backupcount</p><p>maxbytes为最大大小，其格式为字节</p><p>backupcount是最大备份文件为多少</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> settings #导入settings文件，上面定义的settings.py<br><span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> config,getLogger  #导入config和getlogger 这里需要单独导入<br><br>config.dictConfig(settings.LOGGING_DIC) #LOGGING_DIC为字典名，这里settings导入字典名，然后dictconfig解析。固定格式，只需将LOGGING_DIC替换为需要的字典名即可<br>logger4=getLogger(<span class="hljs-string">&#x27;随便输入&#x27;</span>) #loggers为发送者，这里也是将日志输出者定义为对应的loggers，并将其定义成一个变量。<br>logger4.info(<span class="hljs-string">&#x27;logger4产生的info日志&#x27;</span>)#调用info发送日志。<br></code></pre></td></tr></table></figure><p>运行主代码程序输出日志以后，当日志大小大于5字节，就会备份成”文件名.1”,然后如果再执行程序，则会将1备份成2，将源文件备份成1，依次类推到5。</p><p><img src="https://yinshiweiysw.github.io/images/assets/image-20211009154312364.png" alt="image-20211009154312364"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块导入</title>
    <link href="/2021/10/28/%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5_hexo/"/>
    <url>/2021/10/28/%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5_hexo/</url>
    
    <content type="html"><![CDATA[<p>import导入模块，在模块调用时必须加上模块名.方法名()</p><p>例：</p><p>import time</p><p>time.time</p><p>优点：所有属性和方法都属于模块所在的名称空间，不会与当前名称空间产生冲突</p><p>缺点：加前缀调用麻烦</p><p>from 模块名 import 方法名 </p><p>1.产生一个模块的名称空间</p><p>2.运行模块文件将允许过程中产生的名字都对到模块的名称空间中去</p><p>3.在当前名称空间中拿到一个名字，该名字与模块名称空间中的内存地址</p><p>例：</p><p>from time import time </p><p>time()</p><p>优点：不用加前缀</p><p>缺点：容易与当前名称空间混淆，如果当前空间中本身还有一个time，这个会造成覆盖。</p><h2 id="循环导入："><a href="#循环导入：" class="headerlink" title="循环导入："></a>循环导入：</h2><p>​    导入模块1时模块1中导入了模块2，且模块2中导入了m1，则造成了循环导入。</p><h2 id="查看已经加载到内存中的模块："><a href="#查看已经加载到内存中的模块：" class="headerlink" title="查看已经加载到内存中的模块："></a>查看已经加载到内存中的模块：</h2><p>import sys</p><p>print(sys.modules)</p><h2 id="加载本地路径模块："><a href="#加载本地路径模块：" class="headerlink" title="加载本地路径模块："></a>加载本地路径模块：</h2><p>import sys</p><p>sys.path.append(r’文件绝对路径’)</p><p>import foo(加载的模块名)</p><h2 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h2><p>1.包就是一个包含有__init__.py文件的文件夹</p><p>2.为何要有包</p><p>​    包的本质是模块的一种形式，包是用来被当做模块导入</p><p>​    导入模块(包)的流程：</p><p>​        1.产生一个名称空间</p><p>​        2.运行包下的init.py(这里的init左右有两个下划线),将运行过程中产生的名字都丢到1的名称空间中</p><p>​        3.再当前执行文件的名称空间中拿到一个名字mmm,mmm指向1的名称空间</p><p>​        import mmm #这里的mmm是一个文件夹，本质上是在导入mmm下的init.py</p><pre><code>     #本质上把功能都写进init.py，可以直接调用。</code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包与装饰器</title>
    <link href="/2021/10/28/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8_hexo/"/>
    <url>/2021/10/28/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8_hexo/</url>
    
    <content type="html"><![CDATA[<p>闭包：<br>    在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。<br>    闭包就是在函数内再定义一个内部函数，用内部函数来保存外部函数的的变量，其变量不会随着外部函数调用完而销毁</p><pre><code>简单闭包的示例代码：     定义一个外部函数    def func_out(num1):         定义一个内部函数        def func_inner(num2):             内部函数使用了外部函数的变量(num1)            result = num1 + num2            print(&quot;结果是:&quot;, result)         外部函数返回了内部函数，这里返回的内部函数就是闭包        return func_inner     创建闭包实例        f = func_out(1)     执行闭包    f(2)    f(3)    运行结果:    结果是: 3    结果是: 4        通过上面的输出结果可以看出闭包保存了外部函数内的变量num1，每次执行闭包都是在num1 = 1 基础上进行计算例2：     外部函数    def config_name(name):         内部函数        def say_info(info):            print(name + &quot;: &quot; + info)        return say_info    tom = config_name(&quot;Tom&quot;)    tom(&quot;你好!&quot;)    tom(&quot;你好, 在吗?&quot;)    jerry = config_name(&quot;jerry&quot;)    jerry(&quot;不在, 不和玩!&quot;)    运行结果:    Tom: 你好!    Tom: 你好, 在吗?    jerry: 不在, 不和玩!修改闭包内的外部变量：修改闭包内使用的外部函数变量使用 nonlocal 关键字来完成。 定义一个外部函数    def func_out(num1):         定义一个内部函数        def func_inner(num2):             这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1            nonlocal num1   告诉解释器，此处使用的是 外部变量a             修改外部变量num1            num1 = 10             内部函数使用了外部函数的变量(num1)            result = num1 + num2            print(&quot;结果是:&quot;, result)        print(num1)        func_inner(1)        print(num1)         外部函数返回了内部函数，这里返回的内部函数就是闭包        return func_inner     创建闭包实例    f = func_out(1)     执行闭包    f(2)</code></pre><p>装饰器：<br>    装饰器的目的是为了实现在原本函数之上添加功能（代码），本身不影响源代码。其目的是真正作为装饰而存在。<br>    装饰器的功能特点:<br>        不修改已有函数的源代码<br>        不修改已有函数的调用方式<br>        给已有函数增加额外的功能<br>        装饰器本质上就是一个闭包函数<br>    示例：<br>        def check(fn):<br>            def inner():<br>                print(“请先登录….”)<br>                fn()<br>            return inner<br>        def comment():<br>            print(“发表评论”)<br>        comment = check(comment)<br>        comment()</p><pre><code>    打印结果：        请先登录....        发表评论    可以看到，此处先定义了一个comment函数（发表评论），但是在添加功能（打印：请先登录）时，并没有直接在原有函数上添加代码，而是重新创建了一个函数，并在其内部函数中添加代码并调用源函数，以实现装饰器。并且由于装饰器其调用方式不能改变，所以最后再check调用时，把函数check赋给了comment，此时的comment其实就是check调用原来comment的新函数。把外部函数保存（调用）到内部函数本质上也是属于闭包。    装饰器本身就是套用函数，在原函数上面套用一个内部函数，也就是在这里添加代码实现装饰，再在内部函数外面套用一个外部函数，实现调用（调用最里面的函数，也是装饰器需要装饰的那个函数）。装饰器的语法糖写法：        Python给提供了一个装饰函数更加简单的写法，那就是语法糖，语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰    如果有多个函数都需要添加登录验证的功能，每次都需要编写func = check(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。    例：    def check(fn):        def inner():            print(&quot;请先登录....&quot;)            fn()        return inner    @check @check 等价于 comment = check(comment)    def comment():        print(&quot;发表评论&quot;)    comment()装饰器的使用：    1.通过装饰器给原函数传递参数        如果在添加装饰器时，原函数需要传递参数，则装饰器也需要和原函数一样传递参数        例：        def zsq_sum(s):            def inner(a,b):                print(&#39;正在执行计算&#39;)                s(a,b)            return inner        @zsq_sum        def sum_(a,b):            result = a + b            print(result)        sum_(1,2)                原函数在此处需要传递两个函数来实现相加，但添加装饰器以后，装饰器内部函数也需要传递参数，因执行@zsq_sum（sum_=zsq_sum(sum_)）后，此时原函数sum_ 等于s(),则此时真正在执行代码传递参数时，此时的参数是传递到inner函数中的s中，然后再传递到sum_。            2.装饰带有返回值的函数        以上面的代码为例，在result变量执行后 sum_并没有真正返回函数值，而是print打印了其函数值，下面的代码是将其原本的print改为返回函数值，使外部变量zsq_sum在调用时能直接拿到该值：        def zsq_sum(s):            def inner(a,b):                print(&#39;正在执行计算&#39;)                result = s(a,b)                return result            return inner        @zsq_sum        def sum_(a,b):            result = a + b            return result        result = sum_(1,2)        print(result)                此处sum_返回了result，则sum_函数返回值为result，inner中此处把s函数（也就是sum_）赋给了变量result，然后返回变量值（这里直接打印函数不会得到返回值，只能返回其内存地址信息，所以需要赋值）。    3.装饰带有不定长参数的函数        def zsq_sum(s):            def inner(*args,**kwargs):                print(&#39;正在执行计算&#39;)                result = s(*args,**kwargs)                return result            return inner        @zsq_sum        def sum_(*args,**kwargs):            result = 0            for i in args:                result += i            for i in kwargs.values:                result += i            return result        result = sum_(1,2)        print(result)        这里用args和kwargs接受位置参数和非位置参数（字典参数），然后for读取里面里面的值，字典需要跟上.values来读取值，否则为读取字典名。最内部的函数sum_和inner都需要传递参数（因其本身是从inner进去的）。    4.多个装饰器的使用示例代码        def make_div(func):            &quot;&quot;&quot;对被装饰的函数的返回值 div标签&quot;&quot;&quot;            def inner(*args, **kwargs):                return &quot;&lt;div&gt;&quot; + func() + &quot;&lt;/div&gt;&quot;            return inner        def make_p(func):            &quot;&quot;&quot;对被装饰的函数的返回值 p标签&quot;&quot;&quot;            def inner(*args, **kwargs):                return &quot;&lt;p&gt;&quot; + func() + &quot;&lt;/p&gt;&quot;            return inner         装饰过程: 1 content = make_p(content) 2 content = make_div(content)         content = make_div(make_p(content))        @make_div        @make_p        def content():            return &quot;人生苦短&quot;        result = content()        print(result)        代码说明:        多个装饰器的装饰过程是: 离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程        5.带有参数的装饰器介绍        带有参数的装饰器就是使用装饰器装饰函数的时候可以传入指定参数，语法格式: @装饰器(参数,...)        装饰器只能接收一个参数，并且还是函数类型。所以必须在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。         添加输出日志的功能            def logging(flag):                def decorator(fn):                    def inner(num1, num2):                        if flag == &quot;+&quot;:                            print(&quot;--正在努力加法计算--&quot;)                        elif flag == &quot;-&quot;:                            print(&quot;--正在努力减法计算--&quot;)                        result = fn(num1, num2)                        return result                    return inner                 返回装饰器                return decorator             使用装饰器装饰函数            @logging(&quot;+&quot;)            def add(a, b):                result = a + b                return result            @logging(&quot;-&quot;)            def sub(a, b):                result = a - b                return result            result = add(1, 2)            print(result)            result = sub(1, 2)            print(result)</code></pre><p>​<br>        6.类装饰器<br>        类装饰器的介绍<br>        装饰器还有一种特殊的用法就是类装饰器，就是通过定义一个类来装饰函数。</p><pre><code>    类装饰器示例代码:        class Check(object):            def __init__(self, fn):                 初始化操作在此完成                self.__fn = fn             实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。            def __call__(self, *args, **kwargs):                 添加装饰功能                print(&quot;请先登陆...&quot;)                self.__fn()        @Check        def comment():            print(&quot;发表评论&quot;)        comment()    @Check 等价于 comment = Check(comment), 所以需要提供一个init方法，并多增加一个fn参数。    要想类的实例对象能够像函数一样调用，需要在类里面使用call方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。    在call方法里进行对fn函数的装饰，可以添加额外的功能。    执行结果:    请先登陆...    发表评论</code></pre><p>迭代器：<br>    迭代器指的是迭代取值的工具，迭代是一个重复的过程，每次重复都是基于上一次的结果而继续的，单纯的重复并非迭代。</p><pre><code>为何要有迭代器    迭代器是用来迭代取值的工具，而涉及到把多个值循环取出来的类型    有：列表、字符串、元组、字典、集合、打开文件        l=[&#39;egon&#39;,&#39;liu&#39;,&#39;alex&#39;]    i=0    while i &lt; len(l):        print(l[i])        i+=1            上述迭代取值的方式只适用于有索引的数据类型：列表、字符串、元组    为了解决基于索引迭代器取值的局限性    python必须提供一种能够不依赖于索引的取值方式，这就是迭代器    如何用迭代器    可迭代的对象：但凡内置有__iter__方法的都称之为可迭代的对象，文件对象本身就是可迭代对象，无需再定义。          s1=&#39;&#39;    s1.__iter__()    l=[]    l.__iter__()    .....    测试所有类型的对象皆有iter方法。 调用可迭代对象下的__iter__方法会将其转换成迭代器对象    d=&#123;&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3&#125;    d_iterator=d.__iter__()     print(d_iterator)     print(d_iterator.__next__())  结果 1     print(d_iterator.__next__())   结果 2      print(d_iterator.__next__())   结果 3     print(d_iterator.__next__())  抛出异常StopIteration例子： while True:     try:         print(d_iterator.__next__())     except StopIteration:         break print(&#39;====&gt;&gt;&gt;&gt;&gt;&gt;&#39;)  在一个迭代器取值取干净的情况下，再对其取值娶不到 d_iterator=d.__iter__() while True:     try:         print(d_iterator.__next__())     except StopIteration:         break可迭代对象与迭代器对象详解  可迭代对象（&quot;可以转换成迭代器的对象&quot;）：内置有__iter__方法对象        可迭代对象.__iter__(): 得到迭代器对象  迭代器对象：内置有__next__方法并且内置有__iter__方法的对象        迭代器对象.__next__（）：得到迭代器的下一个值        迭代器对象.__iter__（）：得到迭代器的本身，说白了调了跟没调一个样子     dic=&#123;&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3&#125;         dic_iterator=dic.__iter__()     print(dic_iterator is dic_iterator.__iter__().__iter__().__iter__())for循环的工作原理：for循环可以称之为叫迭代器循环     d=&#123;&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3&#125;     1、d.__iter__()得到一个迭代器对象     2、迭代器对象.__next__()拿到一个返回值，然后将该返回值赋值给k     3、循环往复步骤2，直到抛出StopIteration异常for循环会捕捉异常然后结束循环     for k in d:         print(k) with open(&#39;a.txt&#39;,mode=&#39;rt&#39;,encoding=&#39;utf-8&#39;) as f:     for line in f:  f.__iter__()         print(line) list(&#39;hello&#39;) 原理同for循环6、迭代器优缺点总结 6.1 缺点： I、为序列和非序列类型提供了一种统一的迭代取值方式。 II、惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用next来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。 6.2 缺点： I、除非取尽，否则无法获取迭代器的长度 II、只能取下一个值，不能回到开始，更像是‘一次性的’，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值。</code></pre><p>生成器：<br>    生成器就是自定义迭代器。</p><pre><code> 如何得到自定义的迭代器： 在函数内一旦存在yield关键字，调用函数并不会执行函数体代码 会返回一个生成器对象，生成器即自定义的迭代器    def func():        print(&#39;第一次&#39;)        yield 1        print(&#39;第二次&#39;)        yield 2        print(&#39;第三次&#39;)        yield 3        print(&#39;第四次&#39;)     g=func()     print(g)     生成器就是迭代器     g.__iter__()     g.__next__()     会触发函数体代码的运行，然后遇到yield停下来，将yield后的值     当做本次调用的结果返回     res1=g.__next__()     print(res1)         res2=g.__next__()     print(res2)         res3=g.__next__()     print(res3)         res4=g.__next__() 应用案列    def my_range(start,stop,step=1):         print(&#39;start...&#39;)        while start &lt; stop:            yield start            start+=step         print(&#39;end....&#39;)     g=my_range(1,5,2)  1 3     print(next(g))     print(next(g))     print(next(g))    for n in my_range(1,7,2):        print(n)     总结yield：     有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值     </code></pre><p>生成式：<br>            # 1、列表生成式<br>                l = [‘alex_dsb’, ‘lxx_dsb’, ‘wxx_dsb’, “xxq_dsb”, ‘egon’]<br>                # new_l=[]<br>                # for name in l:<br>                #     if name.endswith(‘dsb’):<br>                #         new_l.append(name)</p><pre><code>            # new_l=[name for name in l if name.endswith(&#39;dsb&#39;)]            # new_l=[name for name in l]            # print(new_l)            # 把所有小写字母全变成大写            # new_l=[name.upper() for name in l]            # print(new_l)            # 把所有的名字去掉后缀_dsb            # new_l=[name.replace(&#39;_dsb&#39;,&#39;&#39;) for name in l]            # print(new_l)        # 2、字典生成式            # keys=[&#39;name&#39;,&#39;age&#39;,&#39;gender&#39;]            # dic=&#123;key:None for key in keys&#125;            # print(dic)            # items=[(&#39;name&#39;,&#39;egon&#39;),(&#39;age&#39;,18),(&#39;gender&#39;,&#39;male&#39;)]            # res=&#123;k:v for k,v in items if k != &#39;gender&#39;&#125;            # print(res)        # 3、集合生成式            # keys=[&#39;name&#39;,&#39;age&#39;,&#39;gender&#39;]            # set1=&#123;key for key in keys&#125;            # print(set1,type(set1))        # 4、生成器表达式            # g=(i for i in range(10) if i &gt; 3)            # ！！！！！！！！！！！强调！！！！！！！！！！！！！！！            # 此刻g内部一个值也没有            # print(g,type(g))            # print(g)            # print(next(g))            # print(next(g))            # print(next(g))            # print(next(g))            # print(next(g))            # print(next(g))            # print(next(g))</code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http for python</title>
    <link href="/2021/10/28/http_python_hexo/"/>
    <url>/2021/10/28/http_python_hexo/</url>
    
    <content type="html"><![CDATA[<p>—-http get请求报文<br>—-请求行—–<br>GET / HTTP/1.1 =&gt; 请求方法(方式) 请求的资源路径 http协议的版本<br>—-请求头—-<br>Host: <a href="http://www.itcast.cn/">www.itcast.cn</a>  =&gt; 服务器的主机ip地址和端口号，提示如果看不到端口号默认是80<br>Connection: keep-alive =&gt; 和服务端程序保存长连接，当客户端和服务端有一段时间(3-5)没有进行通信，那么服务器程序会主动向客户端断开连接<br>Upgrade-Insecure-Requests: 1 =&gt; 让客户端请求不安全请求，以后要使用https<br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36 =&gt; 用户代理，客户端程序名称，当后续讲爬虫的时候可以根据是否有User-Agent进行反爬机制<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3 =&gt; 告诉服务端程序可以接受的数据类型<br>Accept-Encoding: gzip, deflate =&gt; 告诉服务端程序支持的压缩算法<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 =&gt; 告诉服务端程序支持的语言<br>Cookie: UM_distinctid=169f06ab9d21a-0a52d93224ce3-12376d57-13c680-169f06ab9d571a; accessId=22bdcd10-6250-11e8-917f-9fb8db4dc43c; bad_id22bdcd10-6250-11e8-917f-9fb8db4dc43c=5c8a5a11-5811-11e9-975d-5932d6370ce7; parent_qimo_sid_22bdcd10-6250-11e8-917f-9fb8db4dc43c=69928890-5811-11e9-ac5b-eb2506ccad9a; CNZZDATA4617777=cnzz_eid%3D324231225-1554516145-%26ntime%3D1554521548; href=http%3A%2F%2F<a href="http://www.itcast.cn%2F">www.itcast.cn%2F</a>; pageViewNum=5; Hm_lvt_0cb375a2e834821b74efffa6c71ee607=1554516722,1554523431; Hm_lpvt_0cb375a2e834821b74efffa6c71ee607=1554523431; nice_id22bdcd10-6250-11e8-917f-9fb8db4dc43c=fc5f90f1-5820-11e9-b896-dba72e2578c0; openChat22bdcd10-6250-11e8-917f-9fb8db4dc43c=true =&gt; 客户端用户身份的标识<br>—–空行—–<br>\r\n</p><p>—–http get请求的原始报文数据————</p><p>—-请求行—–<br>GET / HTTP/1.1\r\n<br>—-请求头—-<br>Host: <a href="http://www.itcast.cn/r/n">www.itcast.cn\r\n</a><br>Connection: keep-alive\r\n<br>Upgrade-Insecure-Requests: 1\r\n<br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\r\n<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3\r\n<br>Accept-Encoding: gzip, deflate\r\n<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n<br>Cookie: UM_distinctid=169f06ab9d21a-0a52d93224ce3-12376d57-13c680-169f06ab9d571a; accessId=22bdcd10-6250-11e8-917f-9fb8db4dc43c; bad_id22bdcd10-6250-11e8-917f-9fb8db4dc43c=5c8a5a11-5811-11e9-975d-5932d6370ce7; parent_qimo_sid_22bdcd10-6250-11e8-917f-9fb8db4dc43c=69928890-5811-11e9-ac5b-eb2506ccad9a; CNZZDATA4617777=cnzz_eid%3D324231225-1554516145-%26ntime%3D1554521548; href=http%3A%2F%2F<a href="http://www.itcast.cn%2F">www.itcast.cn%2F</a>; pageViewNum=5; Hm_lvt_0cb375a2e834821b74efffa6c71ee607=1554516722,1554523431; Hm_lpvt_0cb375a2e834821b74efffa6c71ee607=1554523431; nice_id22bdcd10-6250-11e8-917f-9fb8db4dc43c=fc5f90f1-5820-11e9-b896-dba72e2578c0; openChat22bdcd10-6250-11e8-917f-9fb8db4dc43c=true\r\n<br>—–空行—–<br>\r\n</p><p>—–http get请求报文的格式—-<br>请求行\r\n<br>请求头\r\n<br>空行(\r\n)</p><p>提示: 每项信息之间都需要一个\r\n，是要http协议规定</p><p>—–http post请求报文的格式—-<br>请求行\r\n<br>请求头\r\n<br>空行(\r\n)<br>请求体</p><p>提示: 请求体就是浏览器发送给服务器的数据</p><p>—-http 响应报文解析—-<br>—- 响应行(状态行) ——–<br>HTTP/1.1 200 OK =&gt; http协议版本 状态码 状态描述<br>—- 响应头 ———-<br>Server: Tengine =&gt; 服务器的名称<br>Content-Type: text/html; charset=UTF-8  =&gt; 服务器发送给浏览器的内容类型及编码格式<br>Transfer-Encoding: chunked =&gt; 服务器发送给客户端程序(浏览器)的数据不确定数据长度， 数据发送结束的接收标识: 0\r\n，Content-Length: 200（字节），服务器发送给客户端程序的数据确定长度。 内容长度这两个选项只能二选一<br>Connection: keep-alive  =&gt; 和客户端保持长连接<br>Date: Sat, 06 Apr 2019 08:49:57 GMT =&gt; 服务器的时间<br>— 以下都是自定义响应头信息，字节定义响应头的名字和响应头的值，比如: is_login: True<br>Accept-Ranges: bytes<br>Ali-Swift-Global-Savetime: 1554540597<br>Via: cache45.l2nu29-1[3,200-0,M], cache11.l2nu29-1[4,0], kunlun2.cn249[30,200-0,M], kunlun2.cn249[33,0]<br>X-Cache: MISS TCP_MISS dirn:-2:-2<br>X-Swift-SaveTime: Sat, 06 Apr 2019 08:49:57 GMT<br>X-Swift-CacheTime: 0<br>Timing-Allow-Origin: *<br>EagleId: 2a51041615545405973986157e<br>—– 空行 —-<br>\r\n<br>—– 响应体 就是真正意义上给浏览器解析使用的数据—-<br>网页数据</p><p>提示： 对于请求头和响应头信息程序员都可以进行自定义，按照客户端和服务器约定好的方式来制定即可。</p><p>—-http 响应原始报文解析—-<br>—- 响应行(状态行) ——–<br>HTTP/1.1 200 OK\r\n<br>—- 响应头 ———-<br>Server: Tengine\r\n<br>Content-Type: text/html; charset=UTF-8\r\n<br>Transfer-Encoding: chunked\r\n<br>Connection: keep-alive\r\n<br>Date: Sat, 06 Apr 2019 08:49:57 GMT\r\n<br>— 以下都是自定义响应头信息，字节定义响应头的名字和响应头的值，比如: is_login: True<br>Accept-Ranges: bytes\r\n<br>Ali-Swift-Global-Savetime: 1554540597\r\n<br>Via: cache45.l2nu29-1[3,200-0,M], cache11.l2nu29-1[4,0], kunlun2.cn249[30,200-0,M], kunlun2.cn249[33,0]\r\n<br>X-Cache: MISS TCP_MISS dirn:-2:-2\r\n<br>X-Swift-SaveTime: Sat, 06 Apr 2019 08:49:57 GMT\r\n<br>X-Swift-CacheTime: 0\r\n<br>Timing-Allow-Origin: *\r\n<br>EagleId: 2a51041615545405973986157e\r\n<br>—– 空行 —-<br>\r\n<br>—– 响应体 就是真正意义上给浏览器解析使用的数据—-<br>网页数据</p><p>—- http响应报文的格式 —–</p><p>响应行\r\n<br>响应头\r\n<br>空行\r\n<br>响应体\r\n</p><p>提示: 每项信息之间都要有一个\r\n进行分割</p><p>http编程：<br>    http编程大体与网络编程一致，下面是网络编程步骤：<br>        tcp客户端:<br>            创建客户端套接字对象<br>            和服务端套接字建立连接<br>            发送数据<br>            接收数据<br>            关闭客户端套接字<br>            socket() -&gt; connect() -&gt; send() -&gt; recv () -&gt;close()<br>        tcp服务器：<br>            创建服务端端套接字对象<br>            绑定端口号<br>            设置监听<br>            等待接受客户端的连接请求<br>            接收数据<br>            发送数据<br>            关闭套接字<br>            socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;recv()-send()-&gt;close()<br>    由于程序员在编程时基本只用考虑服务器端的编程，所以这里以服务器端为主。<br>    步骤对应的代码为：<br>        创建服务端端套接字对象：<br>            tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>            一般创建套接字后为了让程序退出端口后立即释放会加上复用端口号<br>                复用端口号：<br>                     tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)<br>        绑定端口号：<br>            tcp_server_socket.bind((“”, 9000))<br>        设置监听：<br>            tcp_server_socket.listen(128)<br>        等待接受客户端的连接请求：<br>            new_socket, ip_port = self.tcp_server_socket.accept()<br>            #这里的new_socket为接受到的新套接字，ip_port为其请求的ip以及端口<br>        接收数据：<br>            recv_client_data = new_socket.recv(4096)<br>        发送数据：<br>            new_socket.send(response_data)<br>        关闭套接字：<br>            new_socket.close()<br>    http编程时其发送数据时应发送为http响应报文，其步骤与socket编程一致（因http本身基于socket）</p><pre><code>实例代码：import socketimport threadingimport frameworkclass Lei():    def __init__(self):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, 9000))        # 设置监听        tcp_server_socket.listen(128)        self.tcp_server_socket = tcp_server_socket    @staticmethod    def thead_http(new_socket):        recv_client_data = new_socket.recv(4096)        # 对二进制数据进行解码        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            new_socket.close()            return        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        #print(recv_client_content)        qiege = recv_client_content.split(&quot; &quot;,maxsplit=5)        uri = qiege[1]        if uri == &quot;/&quot;:            uri = &quot;/index.html&quot;        if uri.endswith(&quot;.html&quot;):             env = &#123;                 &quot;uri&quot; : uri,                 &quot;host&quot; : host,             &#125;             status,response_header,response_body=framework.handle_request(env)             print(&quot;返还给客户端的请求报文&quot;,status,response_header,response_body)             response_line = &quot;HTTP/1.1 %s\r\n&quot; %status             headers = &quot;&quot;             for header in response_header:                 headers += &quot;%s: %s\r\n&quot; % header             response_data = (response_line + headers + &quot;\r\n&quot; + response_body).encode(&quot;utf-8&quot;)             new_socket.send(response_data)             new_socket.close()        else:            try:                with open(&quot;static&quot; + uri, &quot;rb&quot;) as file:                    # 读取文件数据                    file_data = file.read()            except Exception as e:                with open(&quot;static/error.html&quot;,&quot;rb&quot;) as file:                    # 读取文件数据                    file_data = file.read()                # 响应行                response_line = &quot;HTTP/1.1 404 not found\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            else:                # 响应行                response_line = &quot;HTTP/1.1 200 OK\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)                # 关闭服务与客户端的套接字            finally:                new_socket.close()    def start(self):            while True:                # 等待接受客户端的连接请求                new_socket, ip_port = self.tcp_server_socket.accept()                # 代码执行到此，说明连接建立成功                threading_http = threading.Thread(target=self.thead_http, args=(new_socket,))                threading_http.start()def main():    duixiang=Lei()    duixiang.start()if __name__ == &#39;__main__&#39;:    main()该代码步骤：    1.首先定义了两个类 Lei(),和main（），将Lei定义成对象，调用其start方法。if name等于main魔法方法则执行main()表示其需要是主文件才会执行。    2.首先定义了对象方法，将创建tcp服务端套接字，绑定端口号，设置监听都直接定义在init魔法方法中，则在对象执行时，就会直接监听到端口，并把socket定义成了self.socket，以便于对象中其他类可以直接调用套接字。    3.此时因为main中执行了start方法，所以应该是从lei()中的start开始执行，首先执行类对象属性（init），然后此时创建套接字连接请求，并将其赋给new_socket,这里用while true死循环是因为可以（一直接受请求），多线程实现接收多个请求（同时）。此时调用多线程与thead_http上（也就是真正处理客户端请求的类），将接受到的数据参数传递到该类中，并启动该线程。    4.thead_http：建立连接后recv接受请求，首先判断其长度是否为0，如为0直接关闭套接字。decode将其转码，然后切割（split）拿到请求的uri，如果是/则重写为/index.html，然后当期为.html结尾（endswith取其拓展名）。此处html请求这里成为动态请求，因这里有index.html和center.html两个文件，所以会涉及两种请求，并且数据取自数据库。还需要建立一个framework.py的文件来写入其处理方法，并在这里调用，具体后面解释。    5.这里用了if else，并在里面套用了try，except，else，finally。如果不是html文件，则进入else，并执行try模块，这里则以其uri作为路径读取文件内容，如果有该文件则以http报文形式进行返回（如果有该文件进入else）。如果没有该文件则进入except，读取了error.html并封装为http响应报文，返回其错误信息。finally最后关闭这个套接字（执行完也相当于关闭这个线程）    6.最后是html动态请求，这里是framework.py    import pymysql    def index():        #返回的状态码以及请求头请求体        status = &quot;200 ok&quot;        response_header = [(&quot;server&quot;, &quot;PWS/1.1&quot;)]        with open(&quot;template/index.html&quot;, &quot;rb&quot;) as file:            file_data = file.read()        conn = pymysql.connect(host=&quot;10.10.10.85&quot;,                               port=3306,                               user=&quot;root&quot;,                               password=&quot;123456&quot;,                               database=&quot;python&quot;,                               charset=&quot;utf8&quot;)        cursor = conn.cursor()        sql = &quot;select * from info;&quot;        cursor.execute(sql)        result = cursor.fetchall()        cursor.close()        conn.close()        data = &quot;&quot;        for row in result:            data += &quot;&quot;&quot;&lt;tr&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;toAdd&quot; name=&quot;toAdd&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;                      &lt;/tr&gt;&quot;&quot;&quot; %row        response_body = file_data.decode().replace(&quot;&#123;%content%&#125;&quot;, data)        return status, response_header, response_body    def center():        #返回的状态码以及请求头请求体        status = &quot;200 ok&quot;        response_header = [(&quot;server&quot;, &quot;PWS/1.1&quot;)]        with open(&quot;template/center.html&quot;, &quot;rb&quot;) as file:            file_data = file.read()        conn = pymysql.connect(host=&quot;10.10.10.85&quot;,                               port=3306,                               user=&quot;root&quot;,                               password=&quot;123456&quot;,                               database=&quot;python&quot;,                               charset=&quot;utf8&quot;)        cursor = conn.cursor()        sql = &quot;select a.code,a.short,a.chg,a.turnover,a.price,a.highs,b.note_info from info as a inner join focus as b on a.id = b.info_id;&quot;        cursor.execute(sql)        result = cursor.fetchall()        cursor.close()        conn.close()        data = &quot;&quot;        for row in result:            data += &quot;&quot;&quot;&lt;tr&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;td&gt;%s&lt;/td&gt;                      &lt;/tr&gt;&quot;&quot;&quot; %row        response_body = file_data.decode().replace(&quot;&#123;%content%&#125;&quot;, data)        return status, response_header, response_body    def notfound():        status = &quot;404 notfound&quot;        response_header = [(&quot;server&quot;,&quot;PWS/1.1&quot;)]        response_body = &quot;not found&quot;        return  status,response_header,response_body    def handle_request(env):        uri = env[&quot;uri&quot;]        print (&quot;动态资源请求uri:&quot;, uri )        for path,func in route_list:             if uri == path:                 result = func()                 return  result       # if uri == &quot;/index.html&quot;:         #   #如果是index.html则返回index（）         #   result = index()         #   return result        else:            result = notfound()            return result    route_list = [         (&quot;/index.html&quot;, index),         (&quot;/center.html&quot;, center),    ]</code></pre><p>​<br>​          这里其实总结为三种处理方式，一种是没找到的，则返回notfound，一种是index.html,还有一种是center.html,所以这里一共4个类，index请求处理方式为一个类，center为一个类，notfound处理方式为一个类，最后handle_request是对这三种方式进行分发的方法类。<br>​            首先取到uri（这个uri首先是通过split切割得到然后再动态请求类中定义为字典并传递到framework.py中的）<br>​            然后if方法分析uri，这里if后面将route_list分隔为两个变量，route_list为集合，里面有两个元组，其数据有两个，第一个为uri，第二个则是其处理的类。则在这里赋给path和func，当uri变量等于path则执行器方法func。如果不等于，则else执行notefound，则三个类书写完毕。<br>​            需要注意的是center和index都使用了pymsql模块，在其本身html文件中有一处是”content”，这里则通过调用mysql查询将其替换为查询语句。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
