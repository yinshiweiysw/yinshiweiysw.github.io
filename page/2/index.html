<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-lvs_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/lvs_hexo/" class="article-date">
  <time datetime="2021-12-23T09:12:59.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/23/lvs_hexo/">lvs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="lvs"><a href="#lvs" class="headerlink" title="lvs"></a>lvs</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>LVS是一个开源软件，由章文嵩博士于1998年5月创立，可以实现Linux平台下的简单负载均衡。LVS是Linux Virtual Server的简写，是一个虚拟的服务器集群系统。在后续的维护过程中，LVS添加了各种新的支持，包括FreeBSD的支持、IPV6的支持、TCPHA的支持等等。</p>
<p>LVS为传输层协议，基于linux内核的netfilter模块，现在一般都集成与linux内核模块，无需单独安装，使用命令：lsmod | grep ip_vs，可以查看lvs是否已在内核模块中。</p>
<p>lvs分为ipvs和ipvsadmin，前者为已集成与内核模块的ipvs核心功能模块（内核如没有可以编译进内核），后者为lvs的命令行工具，其命令格式也类似与iptables。</p>
<p>lvs工作模式：ipvs是工作在内核中netfilter的INPUT的钩子函数上，对进入的报文在没有进入用户空间前，对这些报文进行操作。优点是性能高，支持并发大，无socket限制和最大文件句柄数限制。缺点是调度方式简单，仅能通过ip+port进行调度。</p>
<h3 id="2-调度模式"><a href="#2-调度模式" class="headerlink" title="2.调度模式"></a>2.调度模式</h3><p>lvs有三种调度模式，NAT,DR,TUN</p>
<p>备注：CIP(客户端IP)，VIP（lvs调度器的外网监听IP），DIP（lvs调度器和后端realserver联系的IP），RIP（后端realserver的IP）</p>
<h4 id="2-1-NAT模式"><a href="#2-1-NAT模式" class="headerlink" title="2.1 NAT模式"></a>2.1 NAT模式</h4><p>nat模式是通过地址转换来实现的调度方式，当客户端访问服务器时，访问的地址应是lvs监听的外网地址，也就是VIP，此时请求报文的地址应为CIP-&gt;VIP（请求地址-&gt;目标地址），到达lvs调度器以后，lvs通过修改该报文的目标地址，来进行转发到后端server，此时该报文为CIP-&gt;RIP（通过DIP转发）。后端realserver在处理完请求之后再将处理完的报文发送到lvs，此时报文为RIP-&gt;CIP（因为此时realserver指定的出口网关为DIP，所以即使该报文目标地址为CIP，也会发送到DIP所在的lvs调度服务器上面）。lvs调度器收到报文后将该报文改为VIP-&gt;CIP，再发送给客户端，完成处理本次请求。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231041277.jpeg" alt="image.png"></p>
<p>NAT模式优缺点：</p>
<ol>
<li>NAT技术将请求的报文和响应的报文都需要通过LB进行地址改写，因此网站访问量比较大的时候LB负载均衡调度器有比较大的瓶颈，一般要求最多之能10-20台节点</li>
<li>只需要在LB上配置一个公网IP地址就可以了。</li>
<li>每台内部的节点服务器的网关地址必须是调度器LB的内网地址。</li>
<li>NAT模式支持对IP地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。</li>
</ol>
<h4 id="2-2-TUN模式"><a href="#2-2-TUN模式" class="headerlink" title="2.2 TUN模式"></a>2.2 TUN模式</h4><p>virtual server via ip tunneling模式:采用NAT模式时，由于请求和响应的报文必须通过调度器地址重写，当客户请求越来越多时，调度器处理能力将成为瓶颈。为了解决这个问题，调度器把请求的报文通过IP隧道转发到真实的服务器。真实的服务器将响应处理后的数据直接返回给客户端。这样调度器就只处理请求入站报文，由于一般网络服务应答数据比请求报文大很多，采用VS/TUN模式后，集群系统的最大吞吐量可以提高10倍。</p>
<p>VS/TUN的工作流程图如下所示，它和NAT模式不同的是，它在LB和RS之间的传输不用改写IP地址。而是把客户请求包封装在一个IP tunnel里面，然后发送给RS节点服务器，节点服务器接收到之后解开IP tunnel后，进行响应处理。并且直接把包通过自己的外网地址发送给客户不用经过LB服务器。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231042480.jpeg" alt="image.png"></p>
<p>原理图过程简述：</p>
<ol>
<li>客户请求数据包，目标地址VIP发送到LB上。</li>
<li>LB接收到客户请求包，进行IP Tunnel封装。即在原有的包头加上IP Tunnel的包头。然后发送出去。</li>
<li>RS节点服务器根据IP Tunnel包头信息（此时就又一种逻辑上的隐形隧道，只有LB和RS之间懂）收到请求包，然后解开IP Tunnel包头信息，得到客户的请求包并进行响应处理。</li>
<li>响应处理完毕之后，RS服务器使用自己的出公网的线路，将这个响应数据包发送给客户端。源IP地址还是VIP地址。（RS节点服务器需要在本地回环接口配置VIP，后续会讲到）</li>
</ol>
<h4 id="2-3-DR模式"><a href="#2-3-DR模式" class="headerlink" title="2.3 DR模式"></a>2.3 DR模式</h4><p>DR模式是通过改写请求报文的目标MAC地址，将请求发给真实服务器的，而真实服务器响应后的处理结果直接返回给客户端用户。同TUN模式一样，DR模式可以极大的提高集群系统的伸缩性。而且DR模式没有IP隧道的开销，对集群中的真实服务器也没有必要必须支持IP隧道协议的要求。但是要求调度器LB与真实服务器RS都有一块网卡连接到同一物理网段上，必须在同一个局域网环境。</p>
<p>DR模式是<a target="_blank" rel="noopener" href="http://www.it165.net/news/nhlw/">互联网</a>使用比较多的一种模式。</p>
<p>DR模式原理图：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231042526.jpeg" alt="image.png"></p>
<p>VS/DR模式的工作流程图如上图所示，它的连接调度和管理与NAT和TUN中的一样，它的报文转发方法和前两种不同。DR模式将报文直接路由给目标真实服务器。在DR模式中，调度器根据各个真实服务器的负载情况，连接数多少等，动态地选择一台服务器，不修改目标IP地址和目标端口，也不封装IP报文，而是将请求报文的数据帧的目标MAC地址改为真实服务器的MAC地址。然后再将修改的数据帧在服务器组的局域网上发送。因为数据帧的MAC地址是真实服务器的MAC地址，并且又在同一个局域网。那么根据局域网的通讯原理，真实复位是一定能够收到由LB发出的数据包。真实服务器接收到请求数据包的时候，解开IP包头查看到的目标IP是VIP。<em>（此时只有自己的IP符合目标IP才会接收进来，所以我们需要在本地的回环借口上面配置VIP。另：由于网络接口都会进行ARP广播响应，但集群的其他机器都有这个VIP的lo接口，都响应就会冲突。所以我们需要把真实服务器的lo接口的ARP响应关闭掉。）</em>然后真实服务器做成请求响应，之后根据自己的路由信息将这个响应数据包发送回给客户，并且源IP地址还是VIP。</p>
<p>DR模式小结：</p>
<ol>
<li>通过在调度器LB上修改数据包的目的MAC地址实现转发。注意源地址仍然是CIP，目的地址仍然是VIP地址。</li>
<li>请求的报文经过调度器，而RS响应处理后的报文无需经过调度器LB，因此并发访问量大时使用效率很高（和NAT模式比）</li>
<li>因为DR模式是通过MAC地址改写机制实现转发，因此所有RS节点和调度器LB只能在一个局域网里面</li>
<li>RS主机需要绑定VIP地址在LO接口上，并且需要配置ARP抑制。</li>
<li>RS节点的默认网关不需要配置成LB，而是直接配置为上级路由的网关，能让RS直接出网就可以。</li>
<li>由于DR模式的调度器仅做MAC地址的改写，所以调度器LB就不能改写目标端口，那么RS服务器就得使用和VIP相同的端口提供服务。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231041271.jpeg" alt="image.png"></p>
<p>lvs调度算法</p>
<p>Lvs的调度算法决定了如何在集群节点之间分布工作负荷。当director调度器收到来自客户端访问VIP的上的集群服务的入站请求时，director调度器必须决定哪个集群节点应该处理请求。Director调度器用的调度方法基本分为两类：</p>
<p>固定调度算法：rr，wrr，dh，sh</p>
<p>动态调度算法：wlc，lc，lblc，lblcr<img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231042661.jpeg" alt="image.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/lvs_hexo/" data-id="ckxjra7p60013r0v10ysfc55a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/nginx_hexo/" class="article-date">
  <time datetime="2021-12-23T09:12:59.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/23/nginx_hexo/">nginx</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-nginx概述"><a href="#一-nginx概述" class="headerlink" title="一.nginx概述"></a>一.nginx概述</h1><p>nginx是一款开源的http，web应用服务器，其功能模块化，高性能高可靠。</p>
<p>特性：<br>功能模块少：源代码仅保留http与核心模块代码，其余不够核心代码会作为插件来安装<br>代码模块化：易读，便于二次开发<br>优势：<br>适合当前主流架构趋势，微服务，云架构，中间层<br>统一技术栈，降低维护成本，降低技术成本更新成本</p>
<p>Nginx特点是占有<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1082.htm">内存</a>少，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/684757.htm">并发</a>能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p>
<p><strong>Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。</strong></p>
<h2 id="Nginx相对于Apache优点："><a href="#Nginx相对于Apache优点：" class="headerlink" title="Nginx相对于Apache优点："></a>Nginx相对于Apache优点：</h2><ol>
<li><strong>高并发响应性能非常好，官方Nginx处理静态文件并发5w/s</strong></li>
<li><strong>反向代理性能非常强。（可用于负载均衡）</strong></li>
<li><strong>内存和cpu占用率低。（为Apache的1/5-1/10）</strong></li>
<li><strong>对后端服务有健康检查功能。</strong></li>
<li><strong>支持PHP cgi方式和fastcgi方式。</strong></li>
<li>配置代码简洁且容易上手。</li>
<li>nginx采用epoll模型（异步非阻塞），而apache采用select模型。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select 和epoll模型的区别</span><br><span class="line">	select:当用户发起一次请求，select模型就会进行一次遍历扫描，从而导致性能低下</span><br><span class="line">	epoll：当用户发起请求，epoll模型会直接进行处理，效率高效，并无连接限制。</span><br><span class="line"></span><br><span class="line">	select和epoll对比</span><br><span class="line"></span><br><span class="line">select</span><br><span class="line">随着连接数增加，急剧下降。处理成千上万并发连接数时，性能很差。</span><br><span class="line">连接数有限制，处理的最大连接数不超过1024。如果要处理超过1024个连接数，则需要修改FD_SETSIZE宏，并重新编译 。</span><br><span class="line">线性轮询</span><br><span class="line">开发复杂性低</span><br><span class="line">epoll</span><br><span class="line">随着连接数增加，性能基本上没有下降。处理成千上万并发连接时，性能很好。</span><br><span class="line">连接数无限制。</span><br><span class="line">回调callback</span><br><span class="line">开发复杂性中</span><br></pre></td></tr></table></figure>

<h2 id="nginx应用场景："><a href="#nginx应用场景：" class="headerlink" title="nginx应用场景："></a>nginx应用场景：</h2><p>静态服务：<br>浏览器缓存，防资源盗用，资源分类，资源压缩，资源缓存，跨域访问<br>代理服务：<br>协议类型，正向代理，反向代理，负载均衡，代理缓存，动静分离<br>安全服务：<br>访问控制，访问限制，流量限制，拦截共计，拦截异常请求，拦截sql注入<br>流行框架<br>nginx+php，nginx+java ，nginx+python</p>
<h1 id="二-nginx安装"><a href="#二-nginx安装" class="headerlink" title="二.nginx安装"></a>二.nginx安装</h1><p><a target="_blank" rel="noopener" href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a> #nginx官网地址</p>
<p>nginx一般有两种安装方式：</p>
<p>源码安装和rpm安装：</p>
<p>rpm安装：</p>
<p>epel源：版本低，功能少<br>官方源：官方编译好的，封装成rpm包，提供yum源 版本新</p>
<h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h2><h3 id="官方源："><a href="#官方源：" class="headerlink" title="官方源："></a>官方源：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install yum-utils</span><br></pre></td></tr></table></figure>

<p>To set up the yum repository, create the file named <strong>/etc/yum.repos.d/nginx.repo</strong> with the following contents:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>

<p>By default, the repository for stable nginx packages is used. If you would like to use mainline nginx packages, run the following command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --enable nginx-mainline</span><br></pre></td></tr></table></figure>

<p>To install nginx, run the following command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure>

<p>When prompted to accept the GPG key, verify that the fingerprint matches 573B FD6B 3D8F BC64 1079 A6AB ABF5 BD82 7BD9 BF62, and if so, accept it.</p>
<p>上面的为最新包的安装，下面的为稳定版的安装，文档内容截自官方文档，如为其他系统则参考官方文档 ：<strong><a target="_blank" rel="noopener" href="http://nginx.org/en/linux_packages.html#RHEL-CentOS">http://nginx.org/en/linux_packages.html#RHEL-CentOS</a></strong></p>
<h3 id="epel源："><a href="#epel源：" class="headerlink" title="epel源："></a>epel源：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release.noarch  ```#首先安装epel源，如已有则跳过，如还没有yum源则先把yum源配置好</span><br><span class="line">yum makecache #加载epel源</span><br><span class="line">yum -y install nginx #安装nginx</span><br><span class="line">安装完成以后</span><br><span class="line">nginx -V 查看nginx安装配置以及版本</span><br></pre></td></tr></table></figure>

<h2 id="源码安装："><a href="#源码安装：" class="headerlink" title="源码安装："></a>源码安装：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.19.6.tar.gz #下载nginx</span><br><span class="line"></span><br><span class="line">useradd -s /sbin/nologin -M nginx #添加nginx用户</span><br><span class="line"></span><br><span class="line">tar -xvf nginx-1.19.6.tar.gz &amp;&amp; cd nginx-1.19.6/</span><br><span class="line"></span><br><span class="line">yum install -y gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel #解决依赖</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-http_auth_request_module --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install  #编译</span><br><span class="line"></span><br><span class="line">ll /usr/local/nginx/  #查看nginx</span><br></pre></td></tr></table></figure>

<p>源码安装的好处在于其所有nginx相关文件都可以放在一起，方便数据迁移。相比于yum麻烦的是：</p>
<p>源码安装完成以后linux环境变量没有nginx路径，需要配置（才能直接在命令行找到命令）</p>
<p>systemd不会自动生成nginx启动文件（无法通过systemctl直接启动关闭nginx）</p>
<p>所以这两个都需要手动进行生成</p>
<h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd:"></a>systemd:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/systemd/system/nginx.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=The nginx HTTP and reverse proxy server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line"># Nginx will fail to start if /run/nginx.pid already exists but has the wrong</span><br><span class="line"># SELinux context. This might happen when running `nginx -t` from the cmdline.</span><br><span class="line"># https://bugzilla.redhat.com/show_bug.cgi?id=1268621</span><br><span class="line">ExecStartPre=/usr/bin/rm -f $PIDFile</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">ExecReload=/bin/kill -s HUP PIDFileExecStartPre=/usr/local/nginx/sbin/nginx−tExecStart=/usr/local/nginx/sbin/nginxExecReload=/bin/kill−sHUP$MAINPID</span><br><span class="line">KillSignal=SIGQUIT</span><br><span class="line">TimeoutStopSec=5</span><br><span class="line">KillMode=mixed</span><br><span class="line">PrivateTmp=true[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>将systemd文件写入以后可以使用systemctl start nginx测试一下</p>
<h3 id="加入环境变量"><a href="#加入环境变量" class="headerlink" title="加入环境变量"></a>加入环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/profile.d/nginx.sh &lt;&lt; EOF</span><br><span class="line">export PATH=/usr/local/nginx/sbin:$PATH</span><br><span class="line">EOF</span><br><span class="line">source /etc/profile.d/nginx.sh #生效到当前环境变量</span><br><span class="line">nginx -V #使用命令测试一下</span><br></pre></td></tr></table></figure>

<h1 id="三-nginx配置文件"><a href="#三-nginx配置文件" class="headerlink" title="三. nginx配置文件"></a>三. nginx配置文件</h1><blockquote>
<p>nginx配置文件：<br>主配置文件：<br>/etc/nginx<br>/etc/nginx/nginx.conf<br>/etc/nginx/conf.d/*<br>cgi,fastcgi,uwcgi配置文件<br>/etc/nginx/fastcgi_params<br>/etc/nginx/scgi_params<br>/etc/nginx/uwsgi_params<br>编码转换映射文件<br>/etc/nginx/win-utf<br>/etc/nginx/koi-utf<br>/etc/nginx/koi-win<br>http协议的conten-type与扩展名<br>/etc/nginx/mime.types<br>systemd：<br>/usr/lib/systemd/system/nginx.service<br>nginx日志轮询，日志切割<br>/etc/logrotate.d/nginx<br>模块目录<br>/etc/nginx/modules<br>/usr/lib64/nginx<br>/usr/lib64/nginx/modules<br>默认站点目录<br>/usr/share/nginx<br>/usr/share/nginx/html/*.html<br>logs:<br>/var/log/nginx<br>缓存：<br>/var/cache/nginx</p>
</blockquote>
<p>默认使用rpm包的nginx相关配置文件如上，如果是源码安装的如果没特别指定路径一般在编译安装prefix指定的nginx根目录下，也有些文件夹不会自动生成可以手动生成。比较重要的配置文件有</p>
<p><strong>conf/nginx.conf：这个是nginx的根配置文件</strong></p>
<p><strong>html站点目录：这个是网站文件夹的路径（也可以不用默认的路径）</strong></p>
<p><strong>nginx.logs:nginx日志生成目录</strong></p>
<h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><h3 id="nginx配置文件格式一般为："><a href="#nginx配置文件格式一般为：" class="headerlink" title="nginx配置文件格式一般为："></a>nginx配置文件格式一般为：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...   # 全局配置段，例如nginx日志文件路径，pid文件路径，nginx用户，进程信息在这里配置</span><br><span class="line">events&#123;</span><br><span class="line"></span><br><span class="line">...  #事件驱动配置端，可定义nginx的事件驱动模型，最大连接数等信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">...  #http定义一个http服务的相关配置，一般下面会包含多个server，一个server又会包含多个location</span><br><span class="line">server&#123;</span><br><span class="line"></span><br><span class="line">... #server定义的是一个虚拟主机的信息，下面可能会有多个location</span><br><span class="line">location &#123;</span><br><span class="line"></span><br><span class="line">.. #location定义的是虚拟主机，location 指令的功能是用来匹配不同的 URI 请求，进而对请求做不同的处理和响应。例如一个网站的/根目录会匹配到服务器主机的哪个文件目录，就是在这里定义的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; #一个配置段由&#123; 开始 &#125; 结尾,  ...表示省略的具体配置信息</span><br></pre></td></tr></table></figure>

<h3 id="完整配置文件以及常用到的一些配置："><a href="#完整配置文件以及常用到的一些配置：" class="headerlink" title="完整配置文件以及常用到的一些配置："></a>完整配置文件以及常用到的一些配置：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user  www www;</span><br><span class="line">#启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  8;</span><br><span class="line">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</span><br><span class="line">#为每个进程分配cpu，上例中将8个进程分配到8个cpu，当然可以写多个，或者将一个进程分配到多个cpu。</span><br><span class="line">worker_rlimit_nofile 102400;</span><br><span class="line">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打</span><br><span class="line">#开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀</span><br><span class="line">#，所以最好与ulimit -n的值保持一致。</span><br><span class="line">#全局错误日志及PID文件</span><br><span class="line">error_log  /usr/local/nginx/logs/error.log; </span><br><span class="line">#错误日志定义等级，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">pid        /usr/local/nginx/nginx.pid;</span><br><span class="line">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀.</span><br><span class="line">#所以建议与ulimit -n的值保持一致。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">#工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    use   epoll;             	#epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    worker_connections  102400;	#单个后台worker process进程的最大并发链接数 （最大连接数=连接数*进程数）</span><br><span class="line">    multi_accept  on; #尽可能多的接受请求</span><br><span class="line">&#125;</span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    access_log    /usr/local/nginx/log/nginx/access.log;</span><br><span class="line">	 sendfile      on;</span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用必须设为 on</span><br><span class="line">	#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span><br><span class="line">	#autoindex  on;  #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">	tcp_nopush on; #防止网络阻塞</span><br><span class="line">	keepalive_timeout  60;</span><br><span class="line">	#keepalive超时时间，客户端到服务器端的连接持续有效时间,当出现对服务器的后,继请求时,keepalive-timeout功能可避免建立或重新建立连接。</span><br><span class="line">    tcp_nodelay   on; #提高数据的实时响应性</span><br><span class="line">   #开启gzip压缩</span><br><span class="line">   gzip on;</span><br><span class="line">	gzip_min_length  1k;</span><br><span class="line">	gzip_buffers     4 16k;</span><br><span class="line">	gzip_http_version 1.1;</span><br><span class="line">	gzip_comp_level  4; #压缩级别大小，最大为9，值越小，压缩后比例越小，CPU处理更快。</span><br><span class="line">	#值越大，消耗CPU比较高。</span><br><span class="line">	gzip_types       text/plain application/x-javascript text/css application/xml;</span><br><span class="line">	gzip_vary on;</span><br><span class="line">	client_max_body_size 10m;      #允许客户端请求的最大单文件字节数</span><br><span class="line">    client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">    proxy_connect_timeout 120;      #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">    proxy_send_timeout 120;         #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">    proxy_read_timeout 120;         #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">    proxy_buffer_size 4k;          #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">    proxy_buffers 4 32k;           #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span><br><span class="line">    proxy_busy_buffers_size 64k;   #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line"></span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    large_client_header_buffers  4 4k;</span><br><span class="line">	client_header_buffer_size 4k;</span><br><span class="line">	#客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k</span><br><span class="line">	#不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">	open_file_cache max=102400 inactive=20s;</span><br><span class="line">	#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">	open_file_cache_valid 30s;</span><br><span class="line">	#这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">	open_file_cache_min_uses 1;</span><br><span class="line">	#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive</span><br><span class="line">    #包含其它配置文件，如自定义的虚拟主机</span><br><span class="line">   #include  vhosts.conf;</span><br><span class="line">#这里为后端服务器wugk应用集群配置，根据后端实际情况修改即可，tdt_wugk为负载均衡名称，可以任意指定</span><br><span class="line">	#但必须跟vhosts.conf虚拟主机的pass段一致，否则不能转发后端的请求。weight配置权重，在fail_timeout内检查max_fails次数，失败则剔除均衡。</span><br><span class="line">	upstream tdt_wugk &#123;</span><br><span class="line">		server   127.0.0.1:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">		server   127.0.0.1:8081 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">	&#125;</span><br><span class="line">   #虚拟主机配置</span><br><span class="line">	server &#123;</span><br><span class="line">		#侦听80端口</span><br><span class="line">        listen       80;</span><br><span class="line">        #定义使用www.wuguangke.cn访问</span><br><span class="line">        server_name  www.wuguangke.cn;</span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs/access.log  main;</span><br><span class="line">			root   /data/webapps/wugk;  #定义服务器的默认网站根目录位置</span><br><span class="line">        index index.php index.html index.htm;   #定义首页索引文件的名称</span><br><span class="line">        #默认请求</span><br><span class="line">        location ~ /&#123;</span><br><span class="line">          root   /data/www/wugk;      #定义服务器的默认网站根目录位置</span><br><span class="line">          index index.php index.html index.htm;   #定义首页索引文件的名称</span><br><span class="line">          #以下是一些反向代理的配置.</span><br><span class="line">		  proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line">		  #如果后端的服务器返回502、504、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">		   proxy_pass  http://tdt_wugk;     #请求转向后端定义的均衡模块</span><br><span class="line">       &#125;</span><br><span class="line">		#配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。</span><br><span class="line">		location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$</span><br><span class="line">		&#123;</span><br><span class="line">			root /data/www/wugk;</span><br><span class="line">			#expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力。</span><br><span class="line">			expires      30d;</span><br><span class="line">		&#125;</span><br><span class="line">        #PHP脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root /root;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param SCRIPT_FILENAME /data/www/wugk$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status  on;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-nginx常用命令"><a href="#四-nginx常用命令" class="headerlink" title="四.nginx常用命令"></a>四.nginx常用命令</h1><p>nginx -v #查看版本号</p>
<p>nginx -V #查看版本号以及安装时安装的模块</p>
<p>nginx -s reload | stop 重新载入配置文件|停止nginx</p>
<p>nginx -t 检查配置文件语法是否正确</p>
<p>nginx 直接输入命令表示启动nginx进程</p>
<h1 id="五-nginx常用模块功能"><a href="#五-nginx常用模块功能" class="headerlink" title="五.nginx常用模块功能"></a>五.nginx常用模块功能</h1><h2 id="1-nginx目录索引"><a href="#1-nginx目录索引" class="headerlink" title="1.nginx目录索引"></a>1.nginx目录索引</h2><p>目录索引模块：ngx_http_autoindex_module</p>
<p>默认：编译进内核</p>
<p>编译参数：<code>--without-http_autoindex_module</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">autoindex on;</span><br><span class="line">加在对应location里面即可实现目录索引浏览（autoindex也可加在http，server里面，但一般不这么用）Syntax:autoindex on|off;</span><br><span class="line">default： autoindex off;</span><br><span class="line">context: http server location常用参数</span><br><span class="line">autoindex_exact_size off;</span><br><span class="line">默认为on，显示出文件的确切大小，单位为bytes</span><br><span class="line">off，显示文件的大概大小，单位为kb or MB or GBautoindex_localtime on;</span><br><span class="line">默认为off，显示的文件时间为GMT时间</span><br><span class="line">默认为on，显示的文件时间为文件的服务器时间charset utf-8,gbk;</span><br><span class="line">默认中文目录乱码，添加防止乱码。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109524.jpeg" alt="image.png"></p>
<p>nginx -s reload #重载配置文件</p>
<p>访问：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109551.jpeg" alt="image.png"></p>
<h2 id="2-nginx状态监控"><a href="#2-nginx状态监控" class="headerlink" title="2.nginx状态监控"></a>2.nginx状态监控</h2><p>状态监控模块：ngx_http_stub_status_module</p>
<p>默认：不编译进内核</p>
<p>编译参数：<code>--with-http_stub_status_module</code></p>
<p>配置实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location = /status &#123;</span><br><span class="line">stub_status;</span><br><span class="line">access_log off;</span><br><span class="line">&#125;</span><br><span class="line">#启动状态时可关闭日志。</span><br></pre></td></tr></table></figure>

<p>访问：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109509.jpeg" alt="image.png"></p>
<p>因安全缘由，建议status状态页面仅内网开放访问或限制访问ip访问认证限制。</p>
<h2 id="3-nginx访问控制"><a href="#3-nginx访问控制" class="headerlink" title="3.nginx访问控制"></a>3.nginx访问控制</h2><p>基于IP的访问控制模块： http_access_module 默认：编译进内核 编译参数：<code>--without-http_access_module</code><br>基于用户登录认证模块： http_auth_basic_module 默认：编译进内核 编译参数：<code>--without-http_auth_basic_module</code></p>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP:"></a>IP:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">允许:</span><br><span class="line">syntax: allow address |CIDR |unix:  |all;</span><br><span class="line">Default:-</span><br><span class="line">context: httpx server,location,limit_except</span><br><span class="line">拒绝:</span><br><span class="line">syntax: deny address |CIDR |unix:   |all;</span><br><span class="line">context: http, server, location, limit_except</span><br><span class="line">default： -</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231110021.jpeg" alt="image.png"></p>
<p>本机访问（本机ip为10.10.10.214）</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109487.jpeg" alt="image.png"></p>
<p>已被拒绝，其他同网端服务器访问没问题。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231110203.jpeg" alt="image.png"></p>
<h3 id="登录认证访问："><a href="#登录认证访问：" class="headerlink" title="登录认证访问："></a>登录认证访问：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//配置语法</span><br><span class="line">syntax: auth_basic string|off;</span><br><span class="line">default: auth_basic off;</span><br><span class="line">Context:</span><br><span class="line">http, server， location，limit_except</span><br><span class="line">//用户密码记录配置文件</span><br><span class="line">syntax: auth_basic_user_file file;</span><br><span class="line">Default: -</span><br><span class="line">Context:</span><br><span class="line">http, server, location，limit_except</span><br></pre></td></tr></table></figure>

<p>yum -y install httpd-tools (安装http工具包)<br>htpasswd -b -c /x/x/x admin 123456</p>
<p>前面是用户后面是密码，生产用户密码文件</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109831.jpeg" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231110808.jpeg" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109047.jpeg" alt="image.png"></p>
<h2 id="4-访问限制"><a href="#4-访问限制" class="headerlink" title="4.访问限制"></a>4.访问限制</h2><p>经常会遇到这种情况，服务器流量异常，负载过大等等。对于大流量恶意的攻击访问，会带来带宽的浪费，服务器压力，影响业务，往往考虑对同一个IP的连接数，并发数进行限制。</p>
<p>限制连接数：<code>ngx_http_limit_req_module</code></p>
<p>限制请求频率：<code>ngx_http_limit_conn_module</code></p>
<p>默认：编译进内核</p>
<p>编译参数：<code>--without-http_limit_conn_module</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--without-http_limit_req_module</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html">limit_req_zone</a> 用来限制单位时间内的请求数，即速率限制,采用的<strong>漏桶算法 “leaky bucket”</strong></p>
<p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html">limit_conn_zone</a> 用来限制同一时间连接数，即并发限制</p>
<h3 id="limit-conn-zone"><a href="#limit-conn-zone" class="headerlink" title="limit_conn_zone:"></a>limit_conn_zone:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_conn_zone key zone=name:size;</span><br><span class="line">默认：	—</span><br><span class="line">内容：	http </span><br><span class="line">Syntax: limit_conn zone number</span><br><span class="line"> Default: — </span><br><span class="line">Context: http,server, location</span><br><span class="line">可能有几个`limit_conn`指令。例如，以下配置将限制每个客户端IP与服务器的连接数，并同时限制与虚拟服务器的连接总数：</span><br><span class="line">limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=addr:10m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location /download/ &#123;</span><br><span class="line">        limit_conn addr 1;<span class="comment">#一次每个IP地址只允许一个连接。</span></span><br><span class="line">    &#125;</span><br><span class="line">limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=perip:10m;</span><br><span class="line">limit_conn_zone <span class="variable">$server_name</span> zone=perserver:10m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    limit_conn perip 10;</span><br><span class="line">    limit_conn perserver 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当且仅当<code>limit_conn</code>当前级别上未定义任何指令时，这些指令才从先前的配置级别继承。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_conn_dry_run on | off;</span><br><span class="line">默认：</span><br><span class="line">limit_conn_dry_run off;</span><br><span class="line">内容：	http，server，location</span><br></pre></td></tr></table></figure>

<p>启用空运行模式。在这种模式下，连接数不受限制，但是，在共享内存区域中，过多连接的数将照常计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_conn_log_level info | notice | warn | error;</span><br><span class="line">默认：</span><br><span class="line">limit_conn_log_level error;</span><br><span class="line">内容：	http，server，location</span><br></pre></td></tr></table></figure>

<p>为服务器限制连接数的情况设置所需的日志记录级别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_conn_status code;</span><br><span class="line">默认：</span><br><span class="line">limit_conn_status 503;</span><br><span class="line">内容：	http，server，location</span><br></pre></td></tr></table></figure>

<p>设置状态代码以响应被拒绝的请求而返回。</p>
<h3 id="limit-req-zone"><a href="#limit-req-zone" class="headerlink" title="limit_req_zone:"></a>limit_req_zone:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_req_zone key zone=name:size rate=rate [sync];</span><br><span class="line">默认：	—</span><br><span class="line">内容：	http</span><br><span class="line"></span><br><span class="line">Sntax:	limit_req zone=name [burst=number] [nodelay | delay=number];</span><br><span class="line">Default:	—</span><br><span class="line">Context:	http, server, location</span><br><span class="line">http &#123;</span><br><span class="line">    limit_req_zone <span class="variable">$binary_remote_addr</span> zone=one:10m rate=1r/s;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            limit_req zone=one burst=5;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>http{<br>//http段配置请求限制,rate限制速率，限制一秒钟最多一个IP请求<br>limit_req_zone $binary_remote_addr zone=req_zone:10m rate=1r/s;<br>…<br>server {<br>…<br>location / {<br>//1r/s只接收一个请求,其余请求拒绝处理并返回错误码给客户端..<br>limit_req zone=req_zone;<br>//请求超过1r/s,剩下的将被延迟处理,请求数超过burst定义的数量，多余的请求返回503<br>#limit_req zone=req_zone burst=3 nodelay;<br>}<br>}}<br>rate=1r/s表示每秒最大一个请求，burst=3表示请求队列最大为3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_req_dry_run on | off;</span><br><span class="line">默认：</span><br><span class="line">limit_req_dry_run off;</span><br><span class="line">内容：	http，server，location</span><br></pre></td></tr></table></figure>

<p>启用空运行模式。在这种模式下，请求处理速率不受限制，但是，在共享内存区域中，过多请求的数量将照常计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_req_log_level info | notice | warn | error;</span><br><span class="line">默认：</span><br><span class="line">limit_req_log_level error;</span><br><span class="line">内容：	http，server，location</span><br></pre></td></tr></table></figure>

<p>在服务器由于速率超出而拒绝处理请求或延迟请求处理的情况下，设置所需的日志记录级别。延迟的记录级别比拒绝的记录级别少1分；例如，如果<code>limit_req_log_level notice</code>指定“ ” ，则将延迟记录为该<code>info</code>级别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">句法：	limit_req_status code;</span><br><span class="line">默认：</span><br><span class="line">limit_req_status 503;</span><br><span class="line">内容：	http，server，location</span><br></pre></td></tr></table></figure>

<p>设置状态代码以响应被拒绝的请求而返回。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$server_name</span> 表示服务器的变量</span><br><span class="line"><span class="variable">$binary_remote_addr</span> 变量长度是固定的4字节</span><br><span class="line"><span class="variable">$remote_addr</span> 变量长度是7-15字节</span><br><span class="line">一个IP地址=32bit=4字节，所以一般用第一个变量即可</span><br><span class="line">两个都是代表IP地址的变量，区别在于变量存储长度（也可直接换成某个IP地址，但是限制一般针对所有IP地址，而非一个ip地址，所以使用变量）</span><br></pre></td></tr></table></figure>

<h2 id="5-日志模块"><a href="#5-日志模块" class="headerlink" title="5.日志模块"></a>5.日志模块</h2><p>日志模块：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_log_module.html">ngx_http_log_module</a></li>
</ul>
<p>默认：编译进内核（在官方文档的编译模块中，没有日志模块的编译或不编译进内核的选项）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	log_format name [escape=default|json|none] string ...;</span><br><span class="line">Default:</span><br><span class="line">log_format combined &quot;...&quot;;</span><br><span class="line">Context:	http</span><br><span class="line"></span><br><span class="line">Syntax:	access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];</span><br><span class="line">access_log off;</span><br><span class="line">Default:</span><br><span class="line">access_log logs/access.log combined;</span><br><span class="line">Context:	http, server, location, if in location, limit_except</span><br></pre></td></tr></table></figure>

<p>配置示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">access_log logs/access.log main;</span><br></pre></td></tr></table></figure>

<p>log_format是定义的日志格式，access_log是存放的位置。main为日志的名称，下面通过这个main来进行调用</p>
<p>log_format 后面首先定义日志名称，然后’’中间代表日志显示格式，调用的是nginx变量，例如$remote_addr是客户端ip地址 , remote_user是客户端用户,下面是日志实际显示示例：</p>
<p><img src="https://b3logfile.com/file/2021/02/image-677a1224.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image.png"></p>
<p>nginx常见内置变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">嵌入式变量</span><br><span class="line">该ngx_http_core_module模块支持名称与Apache Server变量匹配的嵌入式变量。首先，这些是代表客户端请求标头字段的变量，例如$http_user_agent，$http_cookie等。另外还有其他变量：</span><br><span class="line"></span><br><span class="line">$arg_name</span><br><span class="line">name请求行中的 参数</span><br><span class="line"></span><br><span class="line">$args</span><br><span class="line">请求行中的参数</span><br><span class="line"></span><br><span class="line">$binary_remote_addr</span><br><span class="line">客户端地址（二进制形式），对于IPv4地址，值的长度始终为4个字节，对于IPv6地址，值的长度始终为16个字节</span><br><span class="line"></span><br><span class="line">$body_bytes_sent</span><br><span class="line">发送给客户端的字节数，不计算响应头；此变量与 Apache模块 的“ %B”参数 兼容mod_log_config</span><br><span class="line"></span><br><span class="line">$bytes_sent</span><br><span class="line">发送给客户端的字节数（1.3.8、1.2.5）</span><br><span class="line"></span><br><span class="line">$connection</span><br><span class="line">连接序列号（1.3.8、1.2.5）</span><br><span class="line"></span><br><span class="line">$connection_requests</span><br><span class="line">通过连接发出的当前请求数（1.3.8、1.2.5）</span><br><span class="line"></span><br><span class="line">$content_length</span><br><span class="line">“内容长度”请求标头字段</span><br><span class="line"></span><br><span class="line">$content_type</span><br><span class="line">“内容类型”请求标头字段</span><br><span class="line"></span><br><span class="line">$cookie_name</span><br><span class="line">该name饼干</span><br><span class="line"></span><br><span class="line">$document_root</span><br><span class="line">当前请求的根或别名指令的值</span><br><span class="line"></span><br><span class="line">$document_uri</span><br><span class="line">和...一样 $uri</span><br><span class="line">$host</span><br><span class="line">优先顺序如下：请求行中的主机名，或“主机”请求标头字段中的主机名，或与请求匹配的服务器名</span><br><span class="line"></span><br><span class="line">$hostname</span><br><span class="line">主机名</span><br><span class="line"></span><br><span class="line">$http_name</span><br><span class="line">任意请求头字段；变量名称的最后一部分是字段名称，该字段名称已转换为小写，并用短划线代替了下划线</span><br><span class="line"></span><br><span class="line">$https</span><br><span class="line">on如果连接以SSL模式运行，则为 “ ”，否则为空字符串</span><br><span class="line"></span><br><span class="line">$is_args</span><br><span class="line">“ ?”（如果请求行包含参数），否则为空字符串</span><br><span class="line"></span><br><span class="line">$limit_rate</span><br><span class="line">设置此变量将启用响应率限制；参见limit_rate</span><br><span class="line"></span><br><span class="line">$msec</span><br><span class="line">以毫秒为单位的当前时间（以秒为单位）（1.3.9，1.2.6）</span><br><span class="line"></span><br><span class="line">$nginx_version</span><br><span class="line">Nginx版本</span><br><span class="line"></span><br><span class="line">$pid</span><br><span class="line">工作进程的PID</span><br><span class="line"></span><br><span class="line">$pipe</span><br><span class="line">“ p”如果请求被流水线.“ ”否则（1.3.12，1.2.7）</span><br><span class="line"></span><br><span class="line">$proxy_protocol_addr</span><br><span class="line">来自PROXY协议标头（1.5.12）的客户端地址</span><br><span class="line">必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。</span><br><span class="line"></span><br><span class="line">$proxy_protocol_port</span><br><span class="line">PROXY协议标头（1.11.0）中的客户端端口</span><br><span class="line">必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。</span><br><span class="line"></span><br><span class="line">$proxy_protocol_server_addr</span><br><span class="line">PROXY协议标头中的服务器地址（1.17.6）</span><br><span class="line">必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。</span><br><span class="line"></span><br><span class="line">$proxy_protocol_server_port</span><br><span class="line">PROXY协议标头中的服务器端口（1.17.6）</span><br><span class="line">必须通过proxy_protocol在listen指令中设置参数来预先启用PROXY协议 。</span><br><span class="line"></span><br><span class="line">$query_string</span><br><span class="line">和...一样 $args</span><br><span class="line">$realpath_root</span><br><span class="line">绝对路径名，对应于当前请求的 根或别名指令的值，所有符号链接都解析为真实路径</span><br><span class="line">$remote_addr</span><br><span class="line">客户地址</span><br><span class="line"></span><br><span class="line">$remote_port</span><br><span class="line">客户端口</span><br><span class="line"></span><br><span class="line">$remote_user</span><br><span class="line">基本身份验证随附的用户名</span><br><span class="line"></span><br><span class="line">$request</span><br><span class="line">完整的原始请求行</span><br><span class="line"></span><br><span class="line">$request_body</span><br><span class="line">请求主体</span><br><span class="line">当将请求正文读取到内存缓冲区时， 该变量的值可在proxy_pass， fastcgi_pass， uwsgi_pass和 scgi_pass指令处理的位置 使用。</span><br><span class="line"></span><br><span class="line">$request_body_file</span><br><span class="line">带有请求正文的临时文件的名称</span><br><span class="line">在处理结束时，需要删除文件。要始终将请求正文写入文件， 需要启用client_body_in_file_only。当在代理请求中或在对FastCGI / uwsgi / SCGI服务器的请求中传递临时文件的名称时，应分别通过 proxy_pass_request_body off， fastcgi_pass_request_body off， uwsgi_pass_request_body off或 scgi_pass_request_body off 指令来禁用传递请求正文。 。</span><br><span class="line"></span><br><span class="line">$request_completion</span><br><span class="line">“ OK”（如果请求已完成），否则为空字符串</span><br><span class="line"></span><br><span class="line">$request_filename</span><br><span class="line">基于root或alias 指令以及请求URI 的当前请求的文件路径</span><br><span class="line"></span><br><span class="line">$request_id</span><br><span class="line">从16个随机字节生成的唯一请求标识符，以十六进制（1.11.0）</span><br><span class="line"></span><br><span class="line">$request_length</span><br><span class="line">请求长度（包括请求行，标头和请求正文）（1.3.12，1.2.7）</span><br><span class="line"></span><br><span class="line">$request_method</span><br><span class="line">请求方法，通常是“ GET”或“ POST”</span><br><span class="line"></span><br><span class="line">$request_time</span><br><span class="line">请求以毫秒为单位的处理时间（以秒为单位）（1.3.9、1.2.6）；从客户端读取第一个字节以来经过的时间</span><br><span class="line"></span><br><span class="line">$request_uri</span><br><span class="line">完整的原始请求URI（带有参数）</span><br><span class="line"></span><br><span class="line">$scheme</span><br><span class="line">请求方案，“ http”或“ https”</span><br><span class="line"></span><br><span class="line">$sent_http_name</span><br><span class="line">任意响应头字段；变量名称的最后一部分是字段名称，该字段名称已转换为小写，并用短划线代替了下划线</span><br><span class="line"></span><br><span class="line">$sent_trailer_name</span><br><span class="line">在响应末尾发送的任意字段（1.13.2）；变量名称的最后一部分是字段名称，该字段名称已转换为小写，并用短划线代替了下划线</span><br><span class="line"></span><br><span class="line">$server_addr</span><br><span class="line">接受请求的服务器的地址</span><br><span class="line">计算此变量的值通常需要一个系统调用。为避免系统调用，listen伪指令必须指定地址并使用bind参数。</span><br><span class="line"></span><br><span class="line">$server_name</span><br><span class="line">接受请求的服务器的名称</span><br><span class="line"></span><br><span class="line">$server_port</span><br><span class="line">接受请求的服务器的端口</span><br><span class="line"></span><br><span class="line">$server_protocol</span><br><span class="line">请求协议，通常是“ HTTP/1.0”，“ HTTP/1.1”或“ HTTP / 2.0 ”</span><br><span class="line"></span><br><span class="line">$status</span><br><span class="line">响应状态（1.3.2、1.2.2）</span><br><span class="line"></span><br><span class="line">$tcpinfo_rtt， $tcpinfo_rttvar， $tcpinfo_snd_cwnd， $tcpinfo_rcv_space</span><br><span class="line">有关客户端TCP连接的信息；在支持TCP_INFO套接字选项的 系统上可用</span><br><span class="line"></span><br><span class="line">$time_iso8601</span><br><span class="line">ISO 8601标准格式（1.3.12，1.2.7）的本地时间</span><br><span class="line"></span><br><span class="line">$time_local</span><br><span class="line">通用日志格式的本地时间（1.3.12，1.2.7）</span><br><span class="line"></span><br><span class="line">$uri</span><br><span class="line">请求中的当前URI，已规范化</span><br><span class="line"></span><br><span class="line">$uri在请求处理期间，例如在进行内部重定向或使用索引文件时， 的值可能会更改。</span><br></pre></td></tr></table></figure>

<p>更多变量：<code>https://nginx.org/en/docs/http/ngx_http_core_module.html#var_status</code></p>
<p>error_log(核心模块):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	error_log file [level];</span><br><span class="line">Default:</span><br><span class="line">error_log logs/error.log error;</span><br><span class="line">Context:	main, http, mail, stream, server, location</span><br></pre></td></tr></table></figure>

<h2 id="6-虚拟站点"><a href="#6-虚拟站点" class="headerlink" title="6.虚拟站点"></a>6.虚拟站点</h2><p>所属模块：ngx_http_core_module（server和location都属于该模块）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	server &#123; ... &#125;</span><br><span class="line">Default:	—</span><br><span class="line">Context:	http</span><br><span class="line"></span><br><span class="line">Syntax:	server_name name ...;</span><br><span class="line">Default:</span><br><span class="line">server_name <span class="string">&quot;&quot;</span>;</span><br><span class="line">Context:	server</span><br><span class="line"></span><br><span class="line">Syntax:	listen address[:port] [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="built_in">bind</span>] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line">listen port [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="built_in">bind</span>] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line">listen unix:path [default_server] [ssl] [http2 | spdy] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="built_in">bind</span>] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line">Default:</span><br><span class="line">listen *:80 | *:8000;</span><br><span class="line">Context:	server</span><br></pre></td></tr></table></figure>

<p>一个server表示一个虚拟主机，一个服务器可能有多个虚拟主机（多个网站），实现虚拟主机的方式有三种：</p>
<p>基于IP：</p>
<p>每个server监听不同的IP地址，用server_name来指定（域名和IP都是通过server_name指定）</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109366.jpeg" alt="image.png"></p>
<p>基于域名：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231111658.jpeg" alt="image.png"></p>
<p>需要注意的是基于域名的虚拟主机首先需要通过DNS能解析到，所以要么是已经购买的域名并且配置解析到该服务器的IP上，要么是本地内部DNS配置以后整个内网可以访问到。需要基于DNS解析。但这里是测试，所以把解析放在 /etc/hosts文件即可（linux在解析主机名时会优先去查看hosts文件是否有解析条目）。域名相较于IP和端口的优点是只需要一个端口和一个ip地址即可用于多个虚拟主机，但需要多个域名以区分访问地址。</p>
<p>基于端口：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231109353.jpeg" alt="image.png"></p>
<p>修改listen后的数字即可，默认是80，如果是https的话需要监听443且拥有证书。改为非80（443）端口后再浏览器访问时需主动输入端口号，不然浏览器默认会访问80端口。</p>
<h2 id="7-location"><a href="#7-location" class="headerlink" title="7. location"></a>7. location</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">location @name &#123; ... &#125;</span><br><span class="line">Default:	—</span><br><span class="line">Context:	server, location</span><br></pre></td></tr></table></figure>

<p>location一般放置与server里面，一个server可以有多个location，location是用于匹配访问地址的uri</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=  精确匹配。如果这个查询匹配，那么将停止搜索并立即处理此请求。</span><br><span class="line">~  为区分大小写匹配(可用正则表达式)</span><br><span class="line">~*  为不区分大小写匹配(可用正则表达式)</span><br><span class="line">^~  如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式。</span><br></pre></td></tr></table></figure>

<p>location匹配优先级：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```(location `=` ) &gt; (location `完整路径` ) &gt; (location `^~` 路径) &gt; (location `~`,`~*` 从上向下正则顺序，匹配在最后一条终止) &gt; (location 部分起始路径) &gt; (`/`)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">[ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">[ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">[ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">[ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">[ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The “/”  匹配 configuration A,</span><br><span class="line">the “/index.html”  匹配 configuration B,</span><br><span class="line">the “/documents/document.html”  匹配 configuration C,</span><br><span class="line">the “/images/1.gif”  匹配 configuration D,</span><br><span class="line">and the “/documents/1.jpg”  匹配 configuration E.</span><br></pre></td></tr></table></figure>

<p>locaiton定义以后还需要将其匹配到linux服务器上对应的文件，就需要用到两个配置参数，root和index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	root path;</span><br><span class="line">Default:</span><br><span class="line">root html;</span><br><span class="line">Context:	http, server, location, if in location</span><br><span class="line">Module ngx_http_index_module:(INDEX非core模块，而是单独模块)</span><br><span class="line">Syntax:	index file ...;</span><br><span class="line">Default:</span><br><span class="line">index index.html;</span><br><span class="line">Context:	http, server, location</span><br></pre></td></tr></table></figure>

<p>root是定义其的路径，如root /tmp 放在/的location里面则，当访问路径为根时，会访问到/tmp目录，但是到具体的访问文件时，是由index定义的，一般index定义为index.html或index.htm，如为.php会涉及到fastcgi协议，因为nginx本身只能处理静态html文件。</p>
<h2 id="8-rewrite"><a href="#8-rewrite" class="headerlink" title="8.rewrite"></a>8.rewrite</h2><p>所属模块：Module ngx_http_rewrite_module</p>
<p>默认：编译进模块 编译参数：<code>--without-http_rewrite_module</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	rewrite regex replacement [flag];</span><br><span class="line">Default:	—</span><br><span class="line">Context:	server, location, <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line">rewrite的含义：该指令是实现URL重写的指令。</span><br><span class="line">regex的含义：用于匹配URI的正则表达式。</span><br><span class="line">replacement：将regex正则匹配到的内容替换成 replacement。</span><br><span class="line">flag: flag标记。</span><br><span class="line"></span><br><span class="line">flag有如下值：</span><br><span class="line"></span><br><span class="line">last: 本条规则匹配完成后，继续向下匹配新的location URI 规则。(不常用)</span><br><span class="line"><span class="built_in">break</span>: 本条规则匹配完成即终止，不再匹配后面的任何规则(不常用)。</span><br><span class="line">redirect: 返回302临时重定向，浏览器地址会显示跳转新的URL地址。</span><br><span class="line">permanent: 返回301永久重定向。浏览器地址会显示跳转新的URL地址。</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break;</span><br><span class="line">rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  break;</span><br><span class="line">rewrite ^/(.*) http://www.test.com/$1 permanent;</span><br></pre></td></tr></table></figure>

<p>服务器如需看rewrite日志需要做以下配置：</p>
<p>1.设置nginx的错误日志级别为notice<br>error_log /var/log/nginx/error.log notice;<br>2.在http模块层，增加一行rewrite_log日志<br>http{<br>…<br>rewrite_log on;<br>…<br>}</p>
<h3 id="if"><a href="#if" class="headerlink" title="if:"></a>if:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	<span class="keyword">if</span> (condition) &#123; ... &#125;</span><br><span class="line">Default:	—</span><br><span class="line">Context:	server, location</span><br></pre></td></tr></table></figure>

<p>指定的<code>condition</code>被评估。如果为true，则执行括号内指定的此模块伪指令，并在伪指令内为请求分配配置 <code>if</code>。<code>if</code>指令中的配置是从先前的配置级别继承的。</p>
<p>条件可以是以下任意一种：</p>
<ul>
<li><p>变量名；如果变量的值为空字符串或“</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p>  ”，则为false；否则为false 。</p>
<blockquote>
<p>在1.0.1版之前，任何以“ <code>0</code>”开头的字符串都被视为错误值。</p>
</blockquote>
</li>
<li><p>使用“ <code>=</code>”和“ <code>!=</code>”运算符将变量与字符串进行比较；</p>
</li>
<li><p>使用“ <code>~</code>”（区分大小写的匹配）和“ <code>~*</code>”（区分大小写的匹配）运算符将变量与正则表达式进行匹配。正则表达式可以包含捕获，这些捕获可用于以后在<code>$1</code>..<code>$9</code>变量中重用。负运算符“ <code>!~</code>”和“ <code>!~*</code>”也可用。如果正则表达式包含“ <code>&#125;</code>”或“ <code>;</code>”字符，则整个表达式应用单引号或双引号引起来。</p>
</li>
<li><p>使用“ <code>-f</code>”和“ <code>!-f</code>”运算符检查文件是否存在；</p>
</li>
<li><p>使用“ <code>-d</code>”和“ <code>!-d</code>”运算符检查目录是否存在；</p>
</li>
<li><p>使用“ <code>-e</code>”和“ <code>!-e</code>”运算符检查文件，目录或符号链接是否存在；</p>
</li>
<li><p>使用“ <code>-x</code>”和“ <code>!-x</code>”运算符检查可执行文件。</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下</span><br><span class="line"></span><br><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line"></span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#如果cookie匹配正则，设置变量$id等于正则引用部分</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    set $id $1;</span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</span><br><span class="line"></span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line"></span><br><span class="line">    return 405;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#限速，$slow可以通过 set 指令设置</span><br><span class="line"></span><br><span class="line">if ($slow) &#123;</span><br><span class="line"></span><br><span class="line">    limit_rate 10k;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</span><br><span class="line"></span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line"></span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">    proxy_pass  http://127.0.0.1;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#如果query string中包含&quot;post=140&quot;，永久重定向到example.com</span><br><span class="line"></span><br><span class="line">if ($args ~ post=140)&#123;</span><br><span class="line"></span><br><span class="line">    rewrite ^ http://example.com/ permanent;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#防盗链</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line"></span><br><span class="line">    valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line"></span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line"></span><br><span class="line">        return 404;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if可使用的全局变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">变量名称</span><br><span class="line"></span><br><span class="line">变量说明</span><br><span class="line"></span><br><span class="line"><span class="variable">$args</span></span><br><span class="line"></span><br><span class="line">这个变量等于请求行中的参数，同<span class="variable">$query_string</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$content_length</span></span><br><span class="line"></span><br><span class="line">请求头中的Content-length字段</span><br><span class="line"></span><br><span class="line"><span class="variable">$content_type</span></span><br><span class="line"></span><br><span class="line">请求头中的Content-Type字段</span><br><span class="line"></span><br><span class="line"><span class="variable">$document_root</span></span><br><span class="line"></span><br><span class="line">当前请求在root指令中指定的值</span><br><span class="line"></span><br><span class="line"><span class="variable">$host</span></span><br><span class="line"></span><br><span class="line">请求主机头字段，否则为服务器名称</span><br><span class="line"></span><br><span class="line"><span class="variable">$http_user_agent</span></span><br><span class="line"></span><br><span class="line">客户端agent信息</span><br><span class="line"></span><br><span class="line"><span class="variable">$http_cookie</span></span><br><span class="line"></span><br><span class="line">客户端cookie信息</span><br><span class="line"></span><br><span class="line"><span class="variable">$limit_rate</span></span><br><span class="line"></span><br><span class="line">这个变量可以限制连接速率</span><br><span class="line"></span><br><span class="line"><span class="variable">$request_method</span></span><br><span class="line"></span><br><span class="line">客户端请求的动作，通常为GET或POST</span><br><span class="line"></span><br><span class="line"><span class="variable">$remote_addr</span></span><br><span class="line"></span><br><span class="line">客户端的IP地址</span><br><span class="line"></span><br><span class="line"><span class="variable">$remote_port</span></span><br><span class="line"></span><br><span class="line">客户端的端口</span><br><span class="line"></span><br><span class="line"><span class="variable">$remote_user</span></span><br><span class="line"></span><br><span class="line">已经经过Auth Basic Module验证的用户名</span><br><span class="line"></span><br><span class="line"><span class="variable">$request_filename</span></span><br><span class="line"></span><br><span class="line">当前请求的文件路径，由root或<span class="built_in">alias</span>指令与URI请求生成</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheme</span></span><br><span class="line"></span><br><span class="line">HTTP方法（如http，https）</span><br><span class="line"></span><br><span class="line"><span class="variable">$server_protocol</span></span><br><span class="line"></span><br><span class="line">请求使用的协议，通常是HTTP/1.0或HTTP/1.1</span><br><span class="line"></span><br><span class="line"><span class="variable">$server_addr</span></span><br><span class="line"></span><br><span class="line">服务器地址，在完成一次系统调用后可以确定这个值</span><br><span class="line"></span><br><span class="line"><span class="variable">$server_name</span></span><br><span class="line"></span><br><span class="line">服务器名称</span><br><span class="line"></span><br><span class="line"><span class="variable">$server_port</span></span><br><span class="line"></span><br><span class="line">请求到达服务器的端口号</span><br><span class="line"></span><br><span class="line"><span class="variable">$request_uri</span></span><br><span class="line"></span><br><span class="line">包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”</span><br><span class="line"></span><br><span class="line"><span class="variable">$uri</span></span><br><span class="line"></span><br><span class="line">不带请求参数的当前URI，<span class="variable">$uri</span>不包含主机名，如”/foo/bar.html”</span><br><span class="line"></span><br><span class="line"><span class="variable">$document_uri</span></span><br><span class="line"></span><br><span class="line">与<span class="variable">$uri</span>相同</span><br></pre></td></tr></table></figure>

<h2 id="9-proxy模块"><a href="#9-proxy模块" class="headerlink" title="9.proxy模块"></a>9.proxy模块</h2><p>所属模块：ngx_http_proxy_module</p>
<p>默认：编译进模块 编译参数：<code>--without-http_proxy_module</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">句法：	proxy_pass URL;</span><br><span class="line">默认：	—</span><br><span class="line">内容：	location，<span class="keyword">if</span> <span class="keyword">in</span> location，limit_except</span><br><span class="line"></span><br><span class="line">Syntax:	proxy_set_header field value;</span><br><span class="line">Default:</span><br><span class="line">proxy_set_header Host <span class="variable">$proxy_host</span>;</span><br><span class="line">proxy_set_header Connection close;</span><br><span class="line">Context:	http, server, location</span><br></pre></td></tr></table></figure>

<h3 id="proxy："><a href="#proxy：" class="headerlink" title="proxy："></a>proxy：</h3><p>proxy_pass和proxy_set_header是proxy模块中最常用到的两个功能</p>
<p>proxy_pass例子：</p>
<blockquote>
<p>proxy_pass http：// localhost：8000 / uri /;</p>
</blockquote>
<blockquote>
<p>proxy_pass http：//unix/tmp/backend.socket/uri/;</p>
</blockquote>
<p>一般放在location下面，当location匹配到对应的uri之后，如果下面是proxy_pass而不是root，就会通过nginx去反向代理到proxy_pass指定的地址上面去请求访问。</p>
<p>反代的地址可以是ip地址，域名，sock文件地址，也可以是upstream指定的名称。</p>
<p>这个upstream是nginx的另一个模块叫做：ngx_http_upstream_module</p>
<h3 id="ngx-http-upstream-module"><a href="#ngx-http-upstream-module" class="headerlink" title="ngx_http_upstream_module"></a>ngx_http_upstream_module</h3><p>upstream最重要的功能是定义一组后端服务器，然后proxy_pass可以根据upstream定义好的直接调用，完成以后proxy_pass收到请求会将反向代理到upstream所定义的一组服务器上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	upstream name &#123; ... &#125;</span><br><span class="line">Default:	—</span><br><span class="line">Context:	http</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com       weight=5;</span><br><span class="line">    server backend2.example.com:8080;</span><br><span class="line">    server unix:/tmp/backend3;</span><br><span class="line"></span><br><span class="line">    server backup1.example.com:8080   backup;</span><br><span class="line">    server backup2.example.com:8080   backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>upstream定义了一组后端服务器后，当然也会有调度方式：</p>
<p>1.如不进行任何配置，默认的调度方式为轮训调度。</p>
<p>2.weight:设置后端服务器的权重，权重大的优先访问</p>
<p>server 192.168.0.15 weight=10;</p>
<p>3.ip_hash:每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</p>
<p>upstream backend {<br>ip_hash;<br>server 192.168.0.14:88;}</p>
<p>4.fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<p>upstream backend {</p>
<p>fair;</p>
<p>server 192.168.0.14:88;}</p>
<p>5.url_hash（第三方）<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
<p>6.least_conn:</p>
<p>最少连接数,那个机器连接数少就分发（lc）<br>7.wlc:<br>加权最少连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">server squid1:3128;</span><br><span class="line">server squid2:3128;</span><br><span class="line"><span class="built_in">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">hash_method crc32;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#定义负载均衡设备的Ip及设备状态</span></span><br><span class="line">upstream backend&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 127.0.0.1:9090 down;</span><br><span class="line">server 127.0.0.1:8080 weight=2;</span><br><span class="line">server 127.0.0.1:6060;</span><br><span class="line">server 127.0.0.1:7070 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用参数：down ,backup,fail_timeout=time,max_fails=number,wight,max_conns=number<br>down:<br>当前的server暂时不参与负载均衡<br>backup:<br>预留的备份服务器<br>max_fails:<br>允许请求失败的次数<br>fail_timeout:<br>经过max_fails夫败后,服务暂停时间<br>max_conns:<br>限制最大的接收连接数</p>
<h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header:"></a>proxy_set_header:</h3><p>这几个的参数的作用是向后端转发的时候添加头信息；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header   Host    <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">proxy_set_header   X-Real-IP   <span class="variable">$remote_addr</span>;</span><br><span class="line">proxy_set_header   X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文要说明nginx中的Host、X-Real-IP、X-Forwarded-For。</p>
<p>先看一个配置示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  192.168.1.2;</span><br><span class="line">    error_log   /usr/local/etc/nginx/logs/test.error.log;</span><br><span class="line">    access_log  /usr/local/etc/nginx/logs/test.access.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header   Host             $http_host;</span><br><span class="line">        proxy_set_header   X-NginX-Proxy    true;</span><br><span class="line">        proxy_set_header   Connection &quot;&quot;;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">        proxy_pass  http://127.0.0.1:8889;</span><br><span class="line">    &#125;  </span><br><span class="line">    location /app &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header   Host             $proxy_host;</span><br><span class="line">        proxy_set_header   X-NginX-Proxy    true;</span><br><span class="line">        proxy_set_header   Connection &quot;&quot;;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_pass http://192.168.1.3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端地址（请求服务的地址）：192.168.1.1</p>
<p>nignx服务器地址：192.168.1.2</p>
<p>后端服务器地址：192.168.1.3</p>
<p>首先说明proxy_set_header是用来设置请求头的，设置了请求头后，后端服务器就可以获取到这些变量值。</p>
<p><strong>一、X-Real-IP</strong></p>
<p>是指客户端的真实IP，如果设置了$remote_addr这个值，后端服务器就能获取到客户端的真实IP，也就是此例中的192.168.1.1</p>
<p><strong>二、Host</strong></p>
<p>host的值设置为$proxy<em>host，</em>是指proxy_pass中设置的host值，也就是192.168.1.3，也就是服务器的IP地址。</p>
<p>若客户端发过来的请求header中有HOST这个字段，$http_host和$host表示的就是原始请求host，比如请求的时候HOST的值是<a href="https://link.zhihu.com/?target=http://test.com">http://test.com</a>，那么反代后还是<a href="https://link.zhihu.com/?target=http://test.com">http://test.com</a>。</p>
<p>若客户端发过来的请求header中没有HOST这个字段，$host表示nginx代理服务器的地址，也就是此例中的192.168.1.2。</p>
<p>$http<em>host不是一个固定的变量，他其实是$http</em>_HEADER通配后的结果，这里的HEADER是一个通配符，通配的是请求头里的header属性，例如<code>$http_content_type</code>表示请求头里<code>content-type</code>属性的值，同理，<code>$http_host</code>指的就是请求头里的<code>host</code>属性。</p>
<p><strong>三、X-Forwarded-For</strong></p>
<p>这个变量的值有$proxy_add_x_forwarded_for和$remote_addr，在只有一个代理服务器的转发的情况下，两者的效果貌似差不多，都可以真实的显示出客户端原始ip。</p>
<p>举例说明，用户A的IP是192.168.1.1，请求一个经过两次nginx转发的应用，在第一台nginx中（192.168.1.2），配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure>

<p>现在$proxy_add_x_forwarded_for变量的”X-Forwarded-For”部分是空的，所以只有$remote_addr，而$remote_addr的值是用户的ip，那么X-Forwarded-For变量的值就是用户的ip：192.168.1.1。</p>
<p>到第二台nginx，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure>

<p>现在的$proxy_add_x_forwarded_for变量，X-Forwarded-For部分包含的是用户的真实ip，$remote_addr部分的值是上一台nginx的ip地址，那么X-Forwarded-For的值就变成了”用户的真实ip，第一台nginx的ip”，也就是“192.168.1.1， 192.168.1.2”</p>
<p>所以还是建议X-Forwarded-For的值设置成$proxy_add_x_forwarded_for。</p>
</blockquote>
<h3 id="nginx正向代理："><a href="#nginx正向代理：" class="headerlink" title="nginx正向代理："></a>nginx正向代理：</h3><p>示例配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">resolver                       223.5.5.5;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://$http_host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中重要的配置主要是：proxy_pass和 resolver</p>
<p>proxy指定其正向代理所转发的地址 $http_host为其url</p>
<p>$request_uri为其请求的uri</p>
<p>resolver后面跟的是其转发时使用的dns地址，如没指定，nginx无法正常解析dns，则无法访问域名网站。</p>
<h2 id="10-四层负载均衡"><a href="#10-四层负载均衡" class="headerlink" title="10.四层负载均衡"></a>10.四层负载均衡</h2><p>proxy模块默认只支持七层代理，也就是基于http协议代理，如果想要进行四层转发的话（也就是对其他协议进行转发），可以用到stream模块：</p>
<p>所属模块：ngx_stream_core_module</p>
<p>默认：该<code>ngx_stream_core_module</code>模块自1.9.0版开始可用。默认情况下未构建此模块，应使用<code>--with-stream</code> 配置参数启用它 。使用官方源默认会编译该模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	stream &#123; ... &#125;</span><br><span class="line">Default:	—</span><br><span class="line">Context:	main</span><br></pre></td></tr></table></figure>

<p>在配置文件里面，其模块位置于http同级，下面是示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line"></span><br><span class="line">error_log /var/log/nginx/error.log info;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        hash $remote_addr consistent;</span><br><span class="line"></span><br><span class="line">        server backend1.example.com:12345 weight=5;</span><br><span class="line">        server 127.0.0.1:12345            max_fails=3 fail_timeout=30s;</span><br><span class="line">        server unix:/tmp/backend3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream dns &#123;</span><br><span class="line">       server 192.168.0.1:53535;</span><br><span class="line">       server dns.example.com:53;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 12345;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 127.0.0.1:53 udp reuseport;</span><br><span class="line">        proxy_timeout 20s;</span><br><span class="line">        proxy_pass dns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen [::1]:12345;</span><br><span class="line">        proxy_pass unix:/tmp/stream.socket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里于七层代理在配置文件上最大的区别就是http换成了stream</p>
<p>下面是我在本地做的一个实例：</p>
<p>效果为将一台服务器的ssh协议转发到后端两台服务器</p>
<p>调度器：10.10.10.105</p>
<p>后端服务器：10.10.10.187 ,10.10.10.243</p>
<p>调度服务器nginx 配置添加如下</p>
<blockquote>
<p>stream {<br>upstream backend {<br>server 10.10.10.187:22;<br>server 10.10.10.243:22;<br>}<br>server {<br>listen 88 ;<br>proxy_pass backend;<br>}<br>}</p>
</blockquote>
<p>三台服务器都是虚拟机，添加好配置以后使用xshell进行测试</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231111912.jpeg" alt="image.png"></p>
<p>在弹出的对话框输入账号密码，然后测试成功！</p>
<p><strong>需要注意的是经过测试，stream模块是转发请求而非代理，严格意义上来说是四层转发，其功能于lvs无异。</strong></p>
<p>11.HTTPS</p>
<p>https在http中加入TLS/SSL层，http为明文传输，而https为密文传输，也更为安全。https默认监听端口443，需要证书进行认证，一般证书都有第三方机构或CA颁发。</p>
<p>所属模块：http_ssl_module</p>
<p>默认：不编译进内核 编译参数：–with-http_ssl_module</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax: ssl on | off;</span><br><span class="line">Default: ssl off;</span><br><span class="line">context: http, server</span><br><span class="line"></span><br><span class="line">syntax : ssl_certificate file;</span><br><span class="line">Default: -</span><br><span class="line">context: http, server</span><br><span class="line"></span><br><span class="line">syntax: ssl_certificate_key file;</span><br><span class="line">Default: -</span><br><span class="line">context: http, server</span><br></pre></td></tr></table></figure>

<p>nginx.conf配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  www.oldboy.com;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      ssl_key/server.crt;</span><br><span class="line">        ssl_certificate_key  ssl_key/server.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /code/https;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中ssl_certificate为证书文件，ssl_certificate_key为秘钥文件。</p>
<p>在公司内部使用时，也可使用私有证书（公网中无法验证证书）。</p>
<p>私有证书颁发步骤：</p>
<p>1.生成key秘钥<br>2.生成证书签名请求文件 csr<br>3.生成证书签名文件 ca</p>
<p>要求：<br>1.openssl大于1.0.2<br>[root@localhost ~]# openssl version<br>OpenSSL 1.1.1g FIPS 21 Apr 2020</p>
<p>2.nginx必须有ssl模块<br>nginx -V</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">生成RSA密钥(过程需要设置一个密码,记住这个密码)</span><br><span class="line">openssl genrsa -des3 -out domain.key 1024</span><br><span class="line"></span><br><span class="line">拷贝一个不需要输入密码的密钥文件</span><br><span class="line">openssl rsa -<span class="keyword">in</span> domain.key -out domain_nopass.key</span><br><span class="line">生成一个证书请求</span><br><span class="line">openssl req -new -key domain.key -out domain.csr</span><br><span class="line">这里会提示输入国家,地区组织,email等信息.最重要的一个是<span class="string">&quot;common name&quot;</span>,需要与网站域名相同.</span><br><span class="line"></span><br><span class="line">Enter pass phrase <span class="keyword">for</span> domain.key:              <span class="comment"># 之前设置的密码</span></span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN            <span class="comment"># 国家</span></span><br><span class="line">State or Province Name (full name) []:Jilin         <span class="comment"># 地区或省份</span></span><br><span class="line">Locality Name (eg, city) [Default City]:Changchun      <span class="comment"># 地区局部名</span></span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:Python <span class="comment"># 机构名称</span></span><br><span class="line">Organizational Unit Name (eg, section) []:Python      <span class="comment"># 组织单位名称</span></span><br><span class="line">Common Name (eg, your name or your server<span class="string">&#x27;s hostname) []:domain.com # 网站域名</span></span><br><span class="line"><span class="string">Email Address []:123@domain.com               # 邮箱</span></span><br><span class="line"><span class="string">A challenge password []:                  # 私钥保护密码,可直接回车</span></span><br><span class="line"><span class="string">An optional company name []:                # 一个可选公司名称,可直接回车</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入完这些就会生成一个domain.csr文件,提交给ssl提供商的时候就是这个csr文件.当然这里并没有向任何证书提供商申请,而是自己签发证书.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用上面的密钥和CSR对证书签名</span></span><br><span class="line"><span class="string">openssl x509 -req -days 365 -in domain.csr -signkey domain.key -out domain.crt</span></span><br><span class="line"><span class="string">最后将crt文件与key文件放入nginx配置文件中去</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/nginx_hexo/" data-id="ckxjra7p9001hr0v12n159a42" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rsync_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/rsync_hexo/" class="article-date">
  <time datetime="2021-12-23T09:12:59.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/23/rsync_hexo/">rsync</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-rsync简介"><a href="#1-rsync简介" class="headerlink" title="1.rsync简介"></a>1.rsync简介</h1><p>rysnc是一种备份工具。支持增量备份和差异备份。rsync有三种备份方式，第一种是本地备份类似与cp命令，第二种是远程备份，类似与scp，使用的是ssh传输通道（需要进行ssh身份验证）。第三种是守护进程模式，需要有一台linux主机作为服务器监听端口，其他主要通过服务器的ip和端口进行访问（备份）操作</p>
<h1 id="2-rsync用法"><a href="#2-rsync用法" class="headerlink" title="2.rsync用法"></a>2.rsync用法</h1><h2 id="2-1选项"><a href="#2-1选项" class="headerlink" title="2.1选项"></a>2.1选项</h2><p>rsync有许多选项：</p>
<p>-n: 在不确定命令是否能按意愿执行时，务必要事先测试；-n可以完成此功能；<br>-v: –verbose，详细输出模式<br>-q: –quiet，静默模式<br>-c: –checksum，开启校验功能，强制对文件传输进行校验<br>-r: –recursive，递归复制；<br>-a: –archives，归档，保留文件的原有属性<br>-p: –perms 保留文件的权限<br>-t: –times 保留文件的时间戳<br>-l: –links 保留文件的符号链接<br>-g: –group 保留文件的属组<br>-o: –owner 保留文件的属主<br>-D： –devices 保留设备文件<br>-H, –hard-links 保留硬链结;<br>-S, –sparse 对稀疏文件进行特殊处理以节省DST的 空间;<br>-e ssh: 表示使用ssh协议作承载<br>-z: 对文件压缩后传输<br>–progress：显示进度条<br>–stats: 显示如何执行压缩和传输<br>–delete：删除那些DST中有而SRC没有的文件，即删除DST中多余的文件</p>
<h2 id="2-2命令格式"><a href="#2-2命令格式" class="headerlink" title="2.2命令格式"></a>2.2命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Local:  rsync [OPTION...] SRC... [DEST]</span><br><span class="line"> </span><br><span class="line">Access via remote shell:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br><span class="line"> </span><br><span class="line">Access via rsync daemon:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]</span><br><span class="line">        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST</span><br><span class="line">        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</span><br></pre></td></tr></table></figure>

<p>由此语法可知，rsync有三种工作方式：</p>
<p>(1).本地文件系统上实现同步。命令行语法格式为上述”Local”段的格式。</p>
<p>(2).本地主机使用远程shell和远程主机通信。命令行语法格式为上述”Access via remote shell”段的格式。</p>
<p>(3).本地主机通过网络套接字连接远程主机上的rsync daemon。命令行语法格式为上述”Access via rsync daemon”段的格式。</p>
<p>前两者的本质是通过管道通信，即使是远程shell。而方式(3)则是让远程主机上运行rsync服务，使其监听在一个端口上，等待客户端的连接。</p>
<h2 id="2-3-配置文件"><a href="#2-3-配置文件" class="headerlink" title="2.3 配置文件"></a>2.3 配置文件</h2><p>rsync配置文件一般为/etc/rsyncd.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake super = yes</span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line">use chroot = no</span><br><span class="line">max connections = 10</span><br><span class="line">timeout = 600</span><br><span class="line">motd file = /var/rsyncd/rsyncd.moth</span><br><span class="line">pid file = /var/rsyncd/rsync.pid</span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line">log file = /var/rsyncd/rsyncd.log</span><br><span class="line">dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</span><br><span class="line">[backup]</span><br><span class="line">path = /backup</span><br><span class="line">igonre errors</span><br><span class="line">read only = false</span><br><span class="line">write only = false</span><br><span class="line">list = false</span><br><span class="line">auth users = rsyncd_backup</span><br><span class="line">secrets file = /etc/rsyncd.passwd</span><br></pre></td></tr></table></figure>



<h3 id="rsyncd-conf配置文件常用参数说明"><a href="#rsyncd-conf配置文件常用参数说明" class="headerlink" title="rsyncd.conf配置文件常用参数说明"></a>rsyncd.conf配置文件常用参数说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">| rsyncd.conf参数 | 参数说明 |</span><br><span class="line">| - | - |</span><br><span class="line">| uid=rsync | rsync使用的用户。 |</span><br><span class="line">| gid=rsync | rsync使用的用户组（用户所在的组） |</span><br><span class="line">| use chroot=no | 如果为true，daemon会在客户端传输文件前“chroot to the path”。这是一种安全配置，因为我们大多数都在内网，所以不配也没关系 |</span><br><span class="line">| max connections=200 | 设置最大连接数，默认0，意思无限制，负值为关闭这个模块 |</span><br><span class="line">| timeout=400 | 默认为0，表示no timeout，建议300-600（5-10分钟） |</span><br><span class="line">| pid file | rsync daemon启动后将其进程pid写入此文件。如果这个文件存在，rsync不会覆盖该文件，而是会终止 |</span><br><span class="line">| lock file | 指定lock文件用来支持“max connections”参数，使得总连接数不会超过限制 |</span><br><span class="line">| log file | 不设或者设置错误，rsync会使用rsyslog输出相关日志信息 |</span><br><span class="line">| ignore errors | 忽略I/O错误 |</span><br><span class="line">| read only=false | 指定客户端是否可以上传文件，默认对所有模块为true |</span><br><span class="line">| list=false | 是否允许客户端可以查看可用模块列表，默认为可以 |</span><br><span class="line">| hosts allow | 指定可以联系的客户端主机名或和ip地址或地址段，默认情况没有此参数，即都可以连接 |</span><br><span class="line">| hosts deny | 指定不可以联系的客户端主机名或ip地址或地址段，默认情况没有此参数，即都可以连接 |</span><br><span class="line">| auth users | 指定以空格或逗号分隔的用户可以使用哪些模块，用户不需要在本地系统中存在。默认为所有用户无密码访问 |</span><br><span class="line">| secrets file | 指定用户名和密码存放的文件，格式；用户名；密码，密码不超过8位 |</span><br><span class="line">| [backup] | 这里就是模块名称，需用中括号扩起来，起名称没有特殊要求，但最好是有意义的名称，便于以后维护 |</span><br><span class="line">| path | 这个模块中，daemon使用的文件系统或目录，目录的权限要注意和配置文件中的权限一致，否则会遇到读写的问题 |</span><br></pre></td></tr></table></figure>



<h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3.实验"></a>3.实验</h1><h2 id="3-1-本地传输"><a href="#3-1-本地传输" class="headerlink" title="3.1 本地传输"></a>3.1 本地传输</h2><p>文件同步<br>rsync -avz /etc/fstab /data/<br>目录同步<br>rsync -avz /data /opt<br>data 后面加/表示将data下的内容同步过去 不加/表示将data目录同步过去</p>
<p>–delete 让目标目录与原目录数据同步</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032537.jpeg" alt="image.png"></p>
<h2 id="3-2远程传输"><a href="#3-2远程传输" class="headerlink" title="3.2远程传输"></a>3.2远程传输</h2><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032672.jpeg" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032782.jpeg" alt="image.png"></p>
<p>备注：需要注意的是，远程传输方式使用的是ssh传输通道，ssh传输通道本身传输数据加密的，是安全的，但也有几个缺点：</p>
<p>1.用户权限问题<br>2.用户身份暴露（安全隐患）<br>3.文件路径暴露（安全隐患）</p>
<p>tcp传输过程，每传输一个数据都会有连接的建立，维护，断开过程。所以传输多个文件会比较慢</p>
<p>且两边都需要安装rsync程序。</p>
<p>第一次传输需要进行秘钥确定，且每次登陆需要输入密码，如不想输入密码，可生成秘钥并发送到远程主机。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231032617.jpeg" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231034667.png" alt="image-20211123103427345"></p>
<p>使用ssh-keygen生成秘钥，并使用ssh-copy-id 发送至远程主机</p>
<p>此时传输数据便不会提示输入密码（ssh登陆亦是如此）</p>
<h2 id="3-3-守护进程方式"><a href="#3-3-守护进程方式" class="headerlink" title="3.3 守护进程方式"></a>3.3 守护进程方式</h2><p>守护进程方式需要一台机器作为server端，启动rsync deamon程序，监听端口，通过ip+socket来进行交互。</p>
<p>1.rpm -ql rsync查看rsync是否有安装（有的rsync把rsync与rsync-deamon分开，需要注意下）</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231034944.jpeg" alt="image.png"></p>
<p>如果没有的话则需要安装</p>
<p>yum -y install rsync-deamon rsync</p>
<p>2.编辑配置文件</p>
<p>vim /etc/rsyncd.conf<br>3.创建程序用户<br>useradd -M -s /sbin/nologin rsync<br>chown -R rsync.rsync /backup<br>4.创建目录<br>mkdir /backup &amp;&amp; chown -R rsync.rsync /backup<br>5.创建虚拟用户认证文件<br>echo “rsync_backup:1” &gt; /etc/rsync.password<br>chmod 600 rsync.password<br>6.启动守护进程<br>systemctl start rsyncd</p>
<p>使用rsync带上参数–password-file=xxx指定密码文件可以免输入密码</p>
<p>首先 echo 123456 &gt;　/etc/rsync_password; chmod 600 /etc/rsync_password</p>
<p>然后 rsync -avz xxx <a href="mailto:rsyncd_backup@192.168.1.1">rsyncd_backup@192.168.1.1</a>::bakcup –password-file=/etc/rsync_password</p>
<p>或者设置环境变量：</p>
<p>export RSYNC_PASSWORD =123456</p>
<p>这样不用跟上参数也可以免密码传输</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/rsync_hexo/" data-id="ckxjra7pa001kr0v1eeqhbko1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vmware问题及解决方法_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/vmware%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95_hexo/" class="article-date">
  <time datetime="2021-12-23T09:12:59.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/23/vmware%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95_hexo/">vmware问题及解决方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ovf导入到vsphere-client失败"><a href="#ovf导入到vsphere-client失败" class="headerlink" title="ovf导入到vsphere client失败"></a>ovf导入到vsphere client失败</h1><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049312.jpeg" alt="image.png"></p>
<h2 id="具体问题："><a href="#具体问题：" class="headerlink" title="具体问题："></a>具体问题：</h2><p>导入镜像到客户方的服务器，客户方使用的是esxi，然后这台计算机通过vsphereclient连接到server的，需要将已经准备好的ova导入到客户方，但在ovf部署时出现该报错。</p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>这个问题是说OVF文件的hash值，与.mf文件中记录的hash值不同导致。解决方法简单，可以重新生成OVF文件的hash(256)值，也可以直接把.mf文件删掉。</p>
<p>直接删除掉.mf文件即可，如为.ova文件则改名为.rar，解压以后将其中的.mf删掉然后导入其中的.ovf文件。</p>
<h2 id="其他报错："><a href="#其他报错：" class="headerlink" title="其他报错："></a>其他报错：</h2><p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231050340.jpeg" alt="image.png"></p>
<p>这个错误的意思是说，用VWware导出的OVF文件中，有些功能设置在vSphere中无法找到，即功能模块不兼容的情况。这时就需要修改OVF文件，把用不上的功能设置点去掉。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049355.jpeg" alt="image.png"></p>
<p>打开ovf文件，找到vmx-16的system项设置，这里意思是vmx输出的ovf模板兼容类型是16版本，而vSphere不支持这么高版本，所以只要把它降低就行了。由于不知道服务器上部署的是什么版本，所以这里可以逐个降低进行尝试，直到可以为止。我的最高兼容11版本。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049410.jpeg" alt="image.png"></p>
<p>修改之后就可以了：</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231050117.jpeg" alt="image.png"></p>
<p>然后一路向下，根据提示进行部署。</p>
<p>然后又出现一个设备配置无效的错误；</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049322.jpeg" alt="image.png"></p>
<p>这个错误的意思是说，用VWware导出的OVF文件中，有些功能设置在vSphere中无法找到，即功能模块不兼容的情况。这时就需要修改OVF文件，把用不上的功能设置点去掉。</p>
<p>这里要注意一个点，就是仅靠这个错误提示：设备“0”的配置无效，是无法确切定位到哪个功能在vSphere中是不受支持的，所以还是要逐个尝试，直到找到为止。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049694.jpeg" alt="image.png"></p>
<p>ovf里面的每个item都是一个功能点配置信息，逐个删除、恢复进行尝试，我这里是这一项配置不兼容。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049720.jpeg" alt="image.png"></p>
<p>直接删掉，再导入，就成功了。</p>
<p><img src="https://raw.githubusercontent.com/yinshiweiysw/images/master/assets/202111231049641.jpeg" alt="image.png"></p>
<h1 id="FTP上传或下载文件提示错误：421-Data-timeout-Reconnect-Sorry的解决方法"><a href="#FTP上传或下载文件提示错误：421-Data-timeout-Reconnect-Sorry的解决方法" class="headerlink" title="FTP上传或下载文件提示错误：421 Data timeout. Reconnect. Sorry的解决方法"></a>FTP上传或下载文件提示错误：421 Data timeout. Reconnect. Sorry的解决方法</h1><p>data_connection_timeout，网上是这样解释这个参数的：数据连接后数据连接等待的空闲时间超时，超过时间后，数据连接将断开连接；我发现这个参数在vsftpd安装之后的默认值是1，也就是说，在数据连接后数据连接等待空闲时间超过1秒后，数据连接将断开，那么看来可能就是这个问题导致的，我将参数值改为10之后，发现文件传输马上正常了。</p>
<p>总结：ftp传输文件错误“421 Data timeout. Reconnect”，代表数据连接超时，连接被服务器强制断开了，只要我们找到vsftpd.conf文件，将文件里面的data_connection_timeout参数值改大一点的就可以解决问题了，特别是当我们网络环境不好的时候特别容易出现这个问题。</p>
<h1 id="windows-VMWARE虚拟机开机自启动设置"><a href="#windows-VMWARE虚拟机开机自启动设置" class="headerlink" title="windows VMWARE虚拟机开机自启动设置"></a>windows VMWARE虚拟机开机自启动设置</h1><p>在<strong>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</strong> 或 <strong>%programdata%\Microsoft\Windows\Start Menu\Programs\Startup</strong></p>
<p>里面写入start.bat(名字自定义，需设置为bat脚本执行文件)</p>
<p><strong>“C:\Program Files (x86)\VMware\VMware Workstation\vmware.exe” -X “C:\Users\93202\Documents\Virtual Machines\macOS 10.12\macOS 10.12.vmx”</strong></p>
<p>里面的内容指定其vmware位置和需要启动的虚拟机镜像位置</p>
<p>网上有很多用start参数启动的，但应该是版本问题，我用start测试都会失败，所以这里用-x</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/vmware%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95_hexo/" data-id="ckxjra7pb001nr0v14d5hb5bv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-增加Swap分区_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/%E5%A2%9E%E5%8A%A0Swap%E5%88%86%E5%8C%BA_hexo/" class="article-date">
  <time datetime="2021-12-23T09:12:59.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/23/%E5%A2%9E%E5%8A%A0Swap%E5%88%86%E5%8C%BA_hexo/">增加Swap分区</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="增加Swap分区"><a href="#增加Swap分区" class="headerlink" title="增加Swap分区"></a>增加Swap分区</h1><p>1.创建交换分区的文件:增加1G大小的交换分区，则命令写法如下，其中的 count 等于想要的块大小。</p>
<p>dd if=/dev/zero of=/home/swap bs=1M count=1024</p>
<p>2.设置交换分区文件:</p>
<p>mkswap /home/swap #建立swap的文件系统</p>
<p>3.立即启用交换分区文件:</p>
<p>swapon /home/swap #启用swap文件</p>
<p>4.使系统开机时自启用，在文件 /etc/fstab 中添加一行：<br>/home/swap swap swap defaults 0 0</p>
<p>三、修改 Swap 的使用优先级 swappiness</p>
<p>swappiness=0 表示最大限度使用物理内存，swappiness＝100 表示积极的使用swap分区，并且把内存上的数据及时的搬运到 swap。</p>
<p>cat /proc/sys/vm/swappiness #查看系统默认的 swappiness 值</p>
<p>sudo sysctl vm.swappiness=10 #修改swappiness值为10，临时性的修改，重启系统后会恢复默认值</p>
<p>sudo vi /etc/sysctl.conf</p>
<p>#在文档的最后加上这样一行（永久修改 swappiness）:<br>vm.swappiness = 10<br>\3. # sudo sysctl -p #使 /etc/sysctl.conf 的修改立即生效</p>
<p>推荐的 Swap 和 Ram 之间的大小关系</p>
<table>
<thead>
<tr>
<th>RAM</th>
<th>Swap Space</th>
</tr>
</thead>
<tbody><tr>
<td>Between 1024 MB and 2048 MB</td>
<td>1.5 times the size of RAM</td>
</tr>
<tr>
<td>Between 2049 MB and 8192 MB</td>
<td>Equal to the size of RAM</td>
</tr>
<tr>
<td>More than 8192 MB</td>
<td>0.75 times the size of RAM</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/%E5%A2%9E%E5%8A%A0Swap%E5%88%86%E5%8C%BA_hexo/" data-id="ckxjra7pg0024r0v13qfuddwu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-进程与线程_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/18/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_hexo/" class="article-date">
  <time datetime="2021-11-18T09:24:47.000Z" itemprop="datePublished">2021-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/18/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_hexo/">进程与线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程本质上就是程序数据从硬盘中读取到内存中运行，从而形成一个进程。</p>
<h2 id="进程运行三种状态："><a href="#进程运行三种状态：" class="headerlink" title="进程运行三种状态："></a>进程运行三种状态：</h2><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhbmdoYW9kcmVhbQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>1、就绪状态。某些进程“万事俱备”(必要资源)，只差CPU。（就绪队列）      </p>
<p> 2、执行状态。某进程占有CPU并在CPU上执行其程序。      </p>
<p> 3、阻塞状态。某些进程由于某种原因不能继续运行下去，等待处 理问题。也称为等待状态或封锁状态。如：请求I/O。（多个等待队列）      </p>
<h3 id="进程状态转换的原因："><a href="#进程状态转换的原因：" class="headerlink" title="进程状态转换的原因："></a>进程状态转换的原因：</h3><p>1）就绪-→执行：</p>
<p>对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p>
<p>2）执行-→阻塞：</p>
<p>正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态。</p>
<p>如：进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；</p>
<p>3）阻塞-→就绪：</p>
<p>处于阻塞状态的进程，在其等待的事件已经完成，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p>
<p>4）执行-→就绪：</p>
<p>正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞是用来定义程序的运行状态：</p>
<p>​    阻塞:阻塞态<br>​            非阻塞:就绪态、运行态</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a><strong>同步和异步</strong></h3><p>正常情况下，一个进程运行首先进入就绪态，因一个cpu不能同时调度多个作业，所以需要排队等待进入运行态。进入运行态时，此时的进程正在被cpu调度运行。当进程进入i/o状态时，此时该进程就会从运行态变为阻塞态（系统此时会把cpu分给其他进程）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;描述的是任务的提交方式&quot;&quot;&quot;</span><br><span class="line">同步:任务提交之后，原地等待任务的返回结果，等待的过程中不做任何事(干等)</span><br><span class="line">  	程序层面上表现出来的感觉就是卡住了</span><br><span class="line"></span><br><span class="line">异步:任务提交之后，不原地等待任务的返回结果，直接去做其他事情</span><br><span class="line">  	我提交的任务结果如何获取？</span><br><span class="line">    任务的返回结果会有一个异步回调机制自动处理</span><br></pre></td></tr></table></figure>



<h2 id="开启进程的两种方式"><a href="#开启进程的两种方式" class="headerlink" title="开启进程的两种方式"></a>开启进程的两种方式</h2><p>定心丸:代码开启进程和线程的方式，代码书写基本是一样的，你学会了如何开启进程就学会了如何开启线程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span>%name)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is over&#x27;</span>%name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1 创建一个对象</span></span><br><span class="line">    p = Process(target=task, args=(<span class="string">&#x27;jason&#x27;</span>,))</span><br><span class="line">    <span class="comment"># 容器类型哪怕里面只有1个元素 建议要用逗号隔开</span></span><br><span class="line">    <span class="comment"># 2 开启进程</span></span><br><span class="line">    p.start()  <span class="comment"># 告诉操作系统帮你创建一个进程  异步</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第二种方式 类的继承</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello bf girl&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get out!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess()</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">创建进程就是在内存中申请一块内存空间将需要运行的代码丢进去</span><br><span class="line">一个进程对应在内存中就是一块独立的内存空间</span><br><span class="line">多个进程对应在内存中就是多块独立的内存空间</span><br><span class="line">进程与进程之间数据默认情况下是无法直接交互,如果想交互可以借助于第三方工具、模块</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>join是让主进程等待子进程代码运行结束之后，再继续运行。不影响其他子进程的执行</p>
<p>下面的代码当主进程P.start执行运行子进程代码后，主进程并不会等子进程运行完再往下运行，所以正常情况下程序输出‘主进程已经结束这句话不会再最后面’，如果想让主进程等待子进程执行完字节代码再往下执行就在再需要等待子进程执行完再执行的主代码前面加上join方法</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109103747341.png" alt="image-20211109103747341"></p>
<p>方法如下，此时主进程会等待子进程执行完再打印’主进程已经结束’。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109104132647.png" alt="image-20211109104132647"></p>
<h2 id="管理进程pid"><a href="#管理进程pid" class="headerlink" title="管理进程pid"></a>管理进程pid</h2><p>​    方法: os.getpid,os.getppid,进程对象.terminate,进程对象.is_alive</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">一台计算机上面运行着很多进程，那么计算机是如何区分并管理这些进程服务端的呢？</span><br><span class="line">计算机会给每一个运行的进程分配一个PID号 </span><br><span class="line">如何查看</span><br><span class="line">	windows电脑 </span><br><span class="line">		进入cmd输入tasklist即可查看</span><br><span class="line">		tasklist |findstr PID查看具体的进程</span><br><span class="line">	mac电脑 </span><br><span class="line">		进入终端之后输入ps aux</span><br><span class="line">		ps aux|grep PID查看具体的进程 </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from multiprocessing import Process, current_process</span><br><span class="line">current_process().pid  # 查看当前进程的进程号</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">os.getpid()  # 查看当前进程进程号</span><br><span class="line">os.getppid()  # 查看当前进程的父进程进程号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.terminate()  # 杀死当前进程</span><br><span class="line"># 是告诉操作系统帮你去杀死当前进程 但是需要一定的时间 而代码的运行速度极快</span><br><span class="line">time.sleep(0.1)</span><br><span class="line">print(p.is_alive())  # 判断当前进程是否存活</span><br></pre></td></tr></table></figure>

<h3 id="僵尸进程与孤儿进程-了解"><a href="#僵尸进程与孤儿进程-了解" class="headerlink" title="僵尸进程与孤儿进程(了解)"></a>僵尸进程与孤儿进程(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 僵尸进程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">死了但是没有死透</span></span><br><span class="line"><span class="string">当你开设了子进程之后 该进程死后不会立刻释放占用的进程号</span></span><br><span class="line"><span class="string">因为我要让父进程能够查看到它开设的子进程的一些基本信息 占用的pid号 运行时间。。。</span></span><br><span class="line"><span class="string">所有的进程都会步入僵尸进程</span></span><br><span class="line"><span class="string">	父进程不死并且在无限制的创建子进程并且子进程也不结束</span></span><br><span class="line"><span class="string">	回收子进程占用的pid号</span></span><br><span class="line"><span class="string">		父进程等待子进程运行结束</span></span><br><span class="line"><span class="string">		父进程调用join方法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 孤儿进程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">子进程存活，父进程意外死亡</span></span><br><span class="line"><span class="string">操作系统会开设一个“儿童福利院”专门管理孤儿进程回收相关资源</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>在python中，当子进程设置守护进程以后，如果主进程结束，此时子进程也会立即结束，主进程不会在等待子进程运行完毕。这里设置守护进程必须在子进程启动以前设置，否则报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def ceshi():</span><br><span class="line">	print(&#x27;子进程正在运行&#x27;)</span><br><span class="line">	time.sleep(3)</span><br><span class="line">	print(&#x27;子进程已经结束&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">	P = Process(target=ceshi,)</span><br><span class="line">	print(&#x27;主进程正在运行&#x27;)</span><br><span class="line">	P.daemon = True</span><br><span class="line">	P.start()</span><br><span class="line">	print(&#x27;主进程已经结束&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111009514.png" alt="image-20211109111009514"></p>
<p>这里甚至子进程都没有运行出来就结束了（主进程运行速度太快了，子进程刚创建还没来得及运行，主进程就结束了，并直接结束了子进程。）</p>
<p>如果这里主进程sleep1秒的话，则子进程就开始运行了。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211109111117503.png" alt="image-20211109111117503"></p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>多个进程操作同一份数据的时候，会出现数据错乱的问题</p>
<p>针对上述问题，解决方式就是加锁处理:<strong>将并发变成串行，牺牲效率但是保证了数据的安全</strong></p>
<h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">def write(i):</span><br><span class="line">	with open(&#x27;ceshi.txt&#x27;,&#x27;w&#x27;) as f:</span><br><span class="line">		f.write(str(i))</span><br><span class="line">def read():</span><br><span class="line">	with open(&#x27;ceshi.txt&#x27;,&#x27;r&#x27;) as f:</span><br><span class="line">		i=f.read()</span><br><span class="line">		return i</span><br><span class="line">#定义读和写两个函数</span><br><span class="line">def ceshi():</span><br><span class="line">	i = int(read())</span><br><span class="line">	if i == 1:</span><br><span class="line">		i -= 1</span><br><span class="line">		write(i)</span><br><span class="line">		print(&#x27;测试1判断i=1，则将i-1&#x27;)</span><br><span class="line"></span><br><span class="line">def ceshi2():</span><br><span class="line">	i = int(read())</span><br><span class="line">	if i == 1:</span><br><span class="line">		i -= 1</span><br><span class="line">		write(i)</span><br><span class="line">		print(&#x27;测试2判断i=1，则将i-1&#x27;)</span><br><span class="line">		</span><br><span class="line">#两个测试函数分别判断i是否等于1，如果为1则修改</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">	i=1</span><br><span class="line">	write(i)</span><br><span class="line">	#读取文件时先将1设置为1</span><br><span class="line">	P = Process(target=ceshi,)</span><br><span class="line">	P2 = Process(target=ceshi2,)</span><br><span class="line">	P.start()</span><br><span class="line">	P2.start()</span><br><span class="line">	P.join()</span><br><span class="line">	P2.join()</span><br><span class="line">	i = read() #等两个文件操作完再读取文件</span><br><span class="line">	print(f&#x27;主进程已经结束,i的值为&#123;i&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>两个子进程运行时，都会读取判断文件ceshi.txt里面的值是否为1，如果某一个文件先读取，那么只有一个文件能修改到值，那程序无任何问题，但当两个子进程同时读取文件时，就会出现两个进程都判断其值为1且对其进行修改值操作，显然对于程序来说，不应如此。例如火车抢票，此时票数为1，抢到票时火车的票就-1，如果两个人都同时抢票发现这个时候票为1，于是就都会抢票成功，显然这是一个bug，此时应该在上面加上锁。</p>
<p><strong>改为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Lock</span><br><span class="line">def write(i):</span><br><span class="line">	with open(&#x27;ceshi.txt&#x27;,&#x27;w&#x27;) as f:</span><br><span class="line">		f.write(str(i))</span><br><span class="line">def read():</span><br><span class="line">	with open(&#x27;ceshi.txt&#x27;,&#x27;r&#x27;) as f:</span><br><span class="line">		i=f.read()</span><br><span class="line">		return i</span><br><span class="line">def ceshi(lock):</span><br><span class="line">		l=run(lock)</span><br><span class="line">		if l is True:</span><br><span class="line">			print(&#x27;测试1判断i=1，则将i-1&#x27;)</span><br><span class="line"></span><br><span class="line">def ceshi2(lock):</span><br><span class="line">		l=run(lock)</span><br><span class="line">		if l is True:</span><br><span class="line">			print(&#x27;测试2判断i=1，则将i-1&#x27;)</span><br><span class="line">def run(lock):</span><br><span class="line">	lock.acquire()</span><br><span class="line">	i = int(read())</span><br><span class="line">	if i == 1:</span><br><span class="line">		i -= 1</span><br><span class="line">		write(i)</span><br><span class="line">		lock.release()</span><br><span class="line">		return True</span><br><span class="line">	else:</span><br><span class="line">		return False</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">	i=1</span><br><span class="line">	write(i)</span><br><span class="line">	lock = Lock()</span><br><span class="line">	P = Process(target=ceshi,args=(lock,))</span><br><span class="line">	P2 = Process(target=ceshi2,args=(lock,))</span><br><span class="line">	P.start()</span><br><span class="line">	P2.start()</span><br><span class="line">	P.join()</span><br><span class="line">	P2.join()</span><br><span class="line">	i = read()</span><br><span class="line">	print(f&#x27;主进程已经结束,i的值为&#123;i&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>从run函数可以看到，此时读和写都从并发改为串行了，此时只能一个一个读然后再写，真正再项目环境可以把读写分开，以免一个人在读数据时其他人都要等着，应该是一个人在写数据时再上锁。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h4 id="队列Queue模块"><a href="#队列Queue模块" class="headerlink" title="队列Queue模块"></a>队列Queue模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">管道:subprocess </span></span><br><span class="line"><span class="string">	stdin stdout stderr</span></span><br><span class="line"><span class="string">队列:管道+锁</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">队列:先进先出</span></span><br><span class="line"><span class="string">堆栈:先进后出</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个队列</span></span><br><span class="line">q = Queue(<span class="number">5</span>)  <span class="comment"># 括号内可以传数字 标示生成的队列最大可以同时存放的数据量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 往队列中存数据</span></span><br><span class="line">q.put(<span class="number">111</span>)</span><br><span class="line">q.put(<span class="number">222</span>)</span><br><span class="line">q.put(<span class="number">333</span>)</span><br><span class="line"><span class="comment"># print(q.full())  # 判断当前队列是否满了</span></span><br><span class="line"><span class="comment"># print(q.empty())  # 判断当前队列是否空了</span></span><br><span class="line">q.put(<span class="number">444</span>)</span><br><span class="line">q.put(<span class="number">555</span>)</span><br><span class="line"><span class="comment"># print(q.full())  # 判断当前队列是否满了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># q.put(666)  # 当队列数据放满了之后 如果还有数据要放程序会阻塞 直到有位置让出来 不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">存取数据 存是为了更好的取</span></span><br><span class="line"><span class="string">千方百计的存、简单快捷的取</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同在一个屋檐下</span></span><br><span class="line"><span class="string">差距为何那么大</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去队列中取数据</span></span><br><span class="line">v1 = q.get()</span><br><span class="line">v2 = q.get()</span><br><span class="line">v3 = q.get()</span><br><span class="line">v4 = q.get()</span><br><span class="line">v5 = q.get()</span><br><span class="line"><span class="comment"># print(q.empty())</span></span><br><span class="line"><span class="comment"># V6 = q.get_nowait()  # 没有数据直接报错queue.Empty</span></span><br><span class="line"><span class="comment"># v6 = q.get(timeout=3)  # 没有数据之后原地等待三秒之后再报错  queue.Empty</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    v6 = q.get(timeout=<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(v6)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;一滴都没有了!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # v6 = q.get()  # 队列中如果已经没有数据的话 get方法会原地阻塞</span></span><br><span class="line"><span class="comment"># print(v1, v2, v3, v4, v5, v6)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">q.full()</span></span><br><span class="line"><span class="string">q.empty()</span></span><br><span class="line"><span class="string">q.get_nowait()</span></span><br><span class="line"><span class="string">在多进程的情况下是不精确</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue, Process</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">研究思路</span></span><br><span class="line"><span class="string">    1.主进程跟子进程借助于队列通信</span></span><br><span class="line"><span class="string">    2.子进程跟子进程借助于队列通信</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q</span>):</span></span><br><span class="line">    q.put(<span class="string">&#x27;我是23号技师 很高兴为您服务&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=producer,args=(q,))</span><br><span class="line">    p1 = Process(target=consumer,args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    p1.start()</span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">生产者:生产/制造东西的</span></span><br><span class="line"><span class="string">消费者:消费/处理东西的</span></span><br><span class="line"><span class="string">该模型除了上述两个之外还需要一个媒介</span></span><br><span class="line"><span class="string">	生活中的例子做包子的将包子做好后放在蒸笼(媒介)里面，买包子的取蒸笼里面拿</span></span><br><span class="line"><span class="string">	厨师做菜做完之后用盘子装着给你消费者端过去</span></span><br><span class="line"><span class="string">	生产者和消费者之间不是直接做交互的，而是借助于媒介做交互</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">生产者(做包子的) + 消息队列(蒸笼) + 消费者(吃包子的)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">name,food,q</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        data = <span class="string">&#x27;%s生产了%s%s&#x27;</span>%(name,food,i)</span><br><span class="line">        <span class="comment"># 模拟延迟</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        <span class="comment"># 将数据放入 队列中</span></span><br><span class="line">        q.put(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">name,q</span>):</span></span><br><span class="line">    <span class="comment"># 消费者胃口很大 光盘行动</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food = q.get()  <span class="comment"># 没有数据就会卡住</span></span><br><span class="line">        <span class="comment"># 判断当前是否有结束的标识</span></span><br><span class="line">        <span class="comment"># if food is None:break</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s吃了%s&#x27;</span>%(name,food))</span><br><span class="line">        q.task_done()  <span class="comment"># 告诉队列你已经从里面取出了一个数据并且处理完毕了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># q = Queue()</span></span><br><span class="line">    q = JoinableQueue()</span><br><span class="line">    p1 = Process(target=producer,args=(<span class="string">&#x27;大厨egon&#x27;</span>,<span class="string">&#x27;包子&#x27;</span>,q))</span><br><span class="line">    p2 = Process(target=producer,args=(<span class="string">&#x27;马叉虫tank&#x27;</span>,<span class="string">&#x27;泔水&#x27;</span>,q))</span><br><span class="line">    c1 = Process(target=consumer,args=(<span class="string">&#x27;春哥&#x27;</span>,q))</span><br><span class="line">    c2 = Process(target=consumer,args=(<span class="string">&#x27;新哥&#x27;</span>,q))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    <span class="comment"># 将消费者设置成守护进程</span></span><br><span class="line">    c1.daemon = <span class="literal">True</span></span><br><span class="line">    c2.daemon = <span class="literal">True</span></span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    <span class="comment"># 等待生产者生产完毕之后 往队列中添加特定的结束符号</span></span><br><span class="line">    <span class="comment"># q.put(None)  # 肯定在所有生产者生产的数据的末尾</span></span><br><span class="line">    <span class="comment"># q.put(None)  # 肯定在所有生产者生产的数据的末尾</span></span><br><span class="line">    q.join()  <span class="comment"># 等待队列中所有的数据被取完再执行往下执行代码</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    JoinableQueue 每当你往该队列中存入数据的时候 内部会有一个计数器+1</span></span><br><span class="line"><span class="string">    没当你调用task_done的时候 计数器-1</span></span><br><span class="line"><span class="string">    q.join() 当计数器为0的时候 才往后运行</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 只要q.join执行完毕 说明消费者已经处理完数据了  消费者就没有存在的必要了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线程理论"><a href="#线程理论" class="headerlink" title="线程理论"></a>线程理论</h1><ul>
<li><p>什么是线程</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">进程:资源单位</span></span><br><span class="line"><span class="string">线程:执行单位</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">将操作系统比喻成一个大的工厂</span></span><br><span class="line"><span class="string">那么进程就相当于工厂里面的车间</span></span><br><span class="line"><span class="string">而线程就是车间里面的流水线</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">每一个进程肯定自带一个线程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">再次总结:</span></span><br><span class="line"><span class="string">	进程:资源单位(起一个进程仅仅只是在内存空间中开辟一块独立的空间)</span></span><br><span class="line"><span class="string">	线程:执行单位(真正被cpu执行的其实是进程里面的线程，线程指的就是代码的执行过程，执行代码中所需要使用到的资源都找所在的进程索要)</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">进程和线程都是虚拟单位，只是为了我们更加方便的描述问题</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>为何要有线程</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">开设进程</span></span><br><span class="line"><span class="string">	1.申请内存空间	耗资源</span></span><br><span class="line"><span class="string">	2.“拷贝代码”   耗资源</span></span><br><span class="line"><span class="string">开线程</span></span><br><span class="line"><span class="string">	一个进程内可以开设多个线程，在用一个进程内开设多个线程无需再次申请内存空间操作</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">总结:</span></span><br><span class="line"><span class="string">	开设线程的开销要远远的小于进程的开销</span></span><br><span class="line"><span class="string">	同一个进程下的多个线程数据是共享的!!!</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">我们要开发一款文本编辑器</span><br><span class="line">	获取用户输入的功能</span><br><span class="line">  实时展示到屏幕的功能</span><br><span class="line">  自动保存到硬盘的功能</span><br><span class="line">针对上面这三个功能，开设进程还是线程合适？？？</span><br><span class="line">	开三个线程处理上面的三个功能更加的合理</span><br></pre></td></tr></table></figure></li>
<li><p>如何使用</p>
</li>
</ul>
<h2 id="开启线程的两种方式"><a href="#开启线程的两种方式" class="headerlink" title="开启线程的两种方式"></a>开启线程的两种方式</h2><h3 id="导入模块式"><a href="#导入模块式" class="headerlink" title="导入模块式"></a>导入模块式</h3><p><img src="https://yinshiweiysw.github.io/images/assets.%E8%BF%9B%E7%A8%8B/image-20211111094637428.png" alt="image-20211111094637428"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Thread</span><br><span class="line">duxiangming=Thread(target=ceshi,args=(i,))</span><br></pre></td></tr></table></figure>

<h3 id="集成类式"><a href="#集成类式" class="headerlink" title="集成类式"></a>集成类式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">class ceshi(Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;g&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        cs = ceshi()</span><br><span class="line">        cs.start()</span><br></pre></td></tr></table></figure>

<h2 id="线程与进程区别"><a href="#线程与进程区别" class="headerlink" title="线程与进程区别"></a>线程与进程区别</h2><p>在使用方法上，例如join，互斥锁，join方法，queue消息队列都与进程一致。两者的区别在于线程无需开辟新的内存空间，进程的创建需要开启新的内存空间，因此线程相较于进程来讲，其创建的开销要小很多，但是由于cpython（python用的最多的解释器）的GIL解释器锁的原因，python线程无法实现真正的多线程（利用多核），只能单核使用，但由于其线程创建开销少，所以还是适用于密集型i/o程序，如果是密集型运算程序，还是需要使用多进程。</p>
<h3 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">python解释器其实有多个版本</span><br><span class="line">	Cpython</span><br><span class="line">	Jpython</span><br><span class="line">	Pypypython</span><br><span class="line">但是普遍使用的都是CPython解释器</span><br><span class="line"></span><br><span class="line">在CPython解释器中GIL是一把互斥锁，用来阻止同一个进程下的多个线程的同时执行</span><br><span class="line">	同一个进程下的多个线程无法利用多核优势！！！</span><br><span class="line">	疑问:python的多线程是不是一点用都没有？？？无法利用多核优势</span><br><span class="line">	</span><br><span class="line">因为cpython中的内存管理不是线程安全的</span><br><span class="line">内存管理(垃圾回收机制)</span><br><span class="line">	1.应用计数</span><br><span class="line">	2.标记清楚</span><br><span class="line">	3.分代回收</span><br><span class="line">	</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">重点:</span><br><span class="line">	1.GIL不是python的特点而是CPython解释器的特点</span><br><span class="line">	2.GIL是保证解释器级别的数据的安全</span><br><span class="line">	3.GIL会导致同一个进程下的多个线程的无法同时执行即无法利用多核优势(******)</span><br><span class="line">	4.针对不同的数据还是需要加不同的锁处理 </span><br><span class="line">	5.解释型语言的通病:同一个进程下多个线程无法利用多核优势</span><br></pre></td></tr></table></figure>

<h3 id="GIL与普通互斥锁的区别"><a href="#GIL与普通互斥锁的区别" class="headerlink" title="GIL与普通互斥锁的区别"></a>GIL与普通互斥锁的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread,Lock</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutex = Lock()</span><br><span class="line">money = 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task():</span><br><span class="line">    global money</span><br><span class="line">    # with mutex:</span><br><span class="line">    #     tmp = money</span><br><span class="line">    #     time.sleep(0.1)</span><br><span class="line">    #     money = tmp -1</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    tmp = money</span><br><span class="line">    time.sleep(0.1)  # 只要你进入IO了 GIL会自动释放</span><br><span class="line">    money = tmp - 1</span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t_list = []</span><br><span class="line">    for i in range(100):</span><br><span class="line">        t = Thread(target=task)</span><br><span class="line">        t.start()</span><br><span class="line">        t_list.append(t)</span><br><span class="line">    for t in t_list:</span><br><span class="line">        t.join()</span><br><span class="line">    print(money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">100个线程起起来之后  要先去抢GIL</span><br><span class="line">我进入io GIL自动释放 但是我手上还有一个自己的互斥锁</span><br><span class="line">其他线程虽然抢到了GIL但是抢不到互斥锁 </span><br><span class="line">最终GIL还是回到你的手上 你去操作数据</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="进程池与线程池"><a href="#进程池与线程池" class="headerlink" title="进程池与线程池"></a>进程池与线程池</h3><p>先回顾之前TCP服务端实现并发的效果是怎么玩的</p>
<p>每来一个人就开设一个进程或者线程去处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">无论是开设进程也好还是开设线程也好 是不是都需要消耗资源</span></span><br><span class="line"><span class="string">只不过开设线程的消耗比开设进程的稍微小一点而已</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们是不可能做到无限制的开设进程和线程的 因为计算机硬件的资源更不上！！！</span></span><br><span class="line"><span class="string">硬件的开发速度远远赶不上软件呐</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们的宗旨应该是在保证计算机硬件能够正常工作的情况下最大限度的利用它</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 池的概念</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">什么是池?</span></span><br><span class="line"><span class="string">	池是用来保证计算机硬件安全的情况下最大限度的利用计算机</span></span><br><span class="line"><span class="string">	它降低了程序的运行效率但是保证了计算机硬件的安全 从而让你写的程序能够正常运行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pool = ThreadPoolExecutor(5)  # 池子里面固定只有五个线程</span></span><br><span class="line"><span class="comment"># 括号内可以传数字 不传的话默认会开设当前计算机cpu个数五倍的线程</span></span><br><span class="line">pool = ProcessPoolExecutor(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 括号内可以传数字 不传的话默认会开设当前计算机cpu个数进程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">池子造出来之后 里面会固定存在五个线程</span></span><br><span class="line"><span class="string">这个五个线程不会出现重复创建和销毁的过程</span></span><br><span class="line"><span class="string">池子造出来之后 里面会固定的几个进程</span></span><br><span class="line"><span class="string">这个几个进程不会出现重复创建和销毁的过程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">池子的使用非常的简单</span></span><br><span class="line"><span class="string">你只需要将需要做的任务往池子中提交即可 自动会有人来服务你</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(n,os.getpid())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> n**n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;call_back&gt;&gt;&gt;:&#x27;</span>,n.result())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">任务的提交方式</span></span><br><span class="line"><span class="string">    同步:提交任务之后原地等待任务的返回结果 期间不做任何事</span></span><br><span class="line"><span class="string">    异步:提交任务之后不等待任务的返回结果 执行继续往下执行</span></span><br><span class="line"><span class="string">        返回结果如何获取？？？</span></span><br><span class="line"><span class="string">        异步提交任务的返回结果 应该通过回调机制来获取</span></span><br><span class="line"><span class="string">        回调机制</span></span><br><span class="line"><span class="string">            就相当于给每个异步任务绑定了一个定时炸弹</span></span><br><span class="line"><span class="string">            一旦该任务有结果立刻触发爆炸</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># pool.submit(task, 1)  # 朝池子中提交任务  异步提交</span></span><br><span class="line">    <span class="comment"># print(&#x27;主&#x27;)</span></span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):  <span class="comment"># 朝池子中提交20个任务</span></span><br><span class="line">        <span class="comment"># res = pool.submit(task, i)  # &lt;Future at 0x100f97b38 state=running&gt;</span></span><br><span class="line">        res = pool.submit(task, i).add_done_callback(call_back)</span><br><span class="line">        <span class="comment"># print(res.result())  # result方法   同步提交</span></span><br><span class="line">        <span class="comment"># t_list.append(res)</span></span><br><span class="line">    <span class="comment"># 等待线程池中所有的任务执行完毕之后再继续往下执行</span></span><br><span class="line">    <span class="comment"># pool.shutdown()  # 关闭线程池  等待线程池中所有的任务运行完毕</span></span><br><span class="line">    <span class="comment"># for t in t_list:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;&gt;&gt;&gt;:&#x27;,t.result())  # 肯定是有序的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">程序有并发变成了串行</span></span><br><span class="line"><span class="string">任务的为什么打印的是None</span></span><br><span class="line"><span class="string">res.result() 拿到的就是异步提交的任务的返回结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line">pool = ProcessPoolExecutor(<span class="number">5</span>)</span><br><span class="line">pool.submit(task, i).add_done_callback(call_back)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/18/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_hexo/" data-id="ckxjra7pm002or0v13z0g326b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-IO模型_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/18/IO%E6%A8%A1%E5%9E%8B_hexo/" class="article-date">
  <time datetime="2021-11-18T09:24:46.000Z" itemprop="datePublished">2021-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/18/IO%E6%A8%A1%E5%9E%8B_hexo/">IO模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="IO模型简介"><a href="#IO模型简介" class="headerlink" title="IO模型简介"></a>IO模型简介</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们这里研究的IO模型都是针对网络IO的</span></span><br><span class="line"><span class="string">Stevens在文章中一共比较了五种IO Model：</span></span><br><span class="line"><span class="string">    * blocking IO           阻塞IO</span></span><br><span class="line"><span class="string">    * nonblocking IO      非阻塞IO</span></span><br><span class="line"><span class="string">    * IO multiplexing      IO多路复用</span></span><br><span class="line"><span class="string">    * signal driven IO     信号驱动IO</span></span><br><span class="line"><span class="string">    * asynchronous IO    异步IO</span></span><br><span class="line"><span class="string">    由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#1）等待数据准备 (Waiting for the data to be ready)</span></span><br><span class="line"><span class="comment">#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</span></span><br><span class="line"></span><br><span class="line">同步异步</span><br><span class="line">阻塞非阻塞</span><br><span class="line">常见的网络阻塞状态:</span><br><span class="line">  	accept</span><br><span class="line">    recv</span><br><span class="line">    recvfrom</span><br><span class="line">    </span><br><span class="line">    send虽然它也有io行为 但是不在我们的考虑范围</span><br></pre></td></tr></table></figure>

<h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>最广泛的模型是阻塞I/O模型，默认情况下，所有套接口都是阻塞的。 进程调用recvfrom系统调用，整个过程是阻塞的，直到数据复制到进程缓冲区时才返回（当然，系统调用被中断也会返回）。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110813568-874888915.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们之前写的都是阻塞IO模型  协程除外</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line">            conn.send(data.upper())</span><br><span class="line">        <span class="keyword">except</span> ConnectionResetError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 在服务端开设多进程或者多线程 进程池线程池 其实还是没有解决IO问题	</span></span><br><span class="line">该等的地方还是得等 没有规避</span><br><span class="line">只不过多个人等待的彼此互不干扰</span><br></pre></td></tr></table></figure>

<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>当我们把一个套接口设置为非阻塞时，就是在告诉内核，当请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。当数据没有准备好时，内核立即返回EWOULDBLOCK错误，第四次调用系统调用时，数据已经存在，这时将数据复制到进程缓冲区中。这其中有一个操作时轮询（polling）。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110823926-1104935376.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">要自己实现一个非阻塞IO模型</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8081</span>))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 将所有的网络阻塞变为非阻塞</span></span><br><span class="line">r_list = []</span><br><span class="line">del_list = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn, addr = server.accept()</span><br><span class="line">        r_list.append(conn)</span><br><span class="line">    <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">        <span class="comment"># time.sleep(0.1)</span></span><br><span class="line">        <span class="comment"># print(&#x27;列表的长度:&#x27;,len(r_list))</span></span><br><span class="line">        <span class="comment"># print(&#x27;做其他事&#x27;)</span></span><br><span class="line">        <span class="keyword">for</span> conn <span class="keyword">in</span> r_list:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = conn.recv(<span class="number">1024</span>)  <span class="comment"># 没有消息 报错</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:  <span class="comment"># 客户端断开链接</span></span><br><span class="line">                    conn.close()  <span class="comment"># 关闭conn</span></span><br><span class="line">                    <span class="comment"># 将无用的conn从r_list删除</span></span><br><span class="line">                    del_list.append(conn)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                conn.send(data.upper())</span><br><span class="line">            <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">except</span> ConnectionResetError:</span><br><span class="line">                conn.close()</span><br><span class="line">                del_list.append(conn)</span><br><span class="line">        <span class="comment"># 挥手无用的链接</span></span><br><span class="line">        <span class="keyword">for</span> conn <span class="keyword">in</span> del_list:</span><br><span class="line">            r_list.remove(conn)</span><br><span class="line">        del_list.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    client.send(<span class="string">b&#x27;hello world&#x27;</span>)</span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">虽然非阻塞IO给你的感觉非常的牛逼</span></span><br><span class="line"><span class="string">但是该模型会	长时间占用着CPU并且不干活 让CPU不停的空转</span></span><br><span class="line"><span class="string">我们实际应用中也不会考虑使用非阻塞IO模型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">任何的技术点都有它存在的意义 </span></span><br><span class="line"><span class="string">实际应用或者是思想借鉴</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>此模型用到select和poll函数，这两个函数也会使进程阻塞，select先阻塞，有活动套接字才返回，但是和阻塞I/O不同的是，<strong>这两个函数可以同时阻塞多个I/O操作</strong>，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写（<strong>就是监听多个socket</strong>）。select被调用后，进程会被阻塞，内核监视所有select负责的socket，当有任何一个socket的数据准备好了，select就会返回套接字可读，我们就可以调用recvfrom处理数据。<br><strong>正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用。</strong></p>
<p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110830667-163640114.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当监管的对象只有一个的时候 其实IO多路复用连阻塞IO都比比不上！！！</span></span><br><span class="line"><span class="string">但是IO多路复用可以一次性监管很多个对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server = socket.socket()</span></span><br><span class="line"><span class="string">conn,addr = server.accept()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">监管机制是操作系统本身就有的 如果你想要用该监管机制(select)</span></span><br><span class="line"><span class="string">需要你导入对应的select模块</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line">read_list = [server]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r_list, w_list, x_list = select.select(read_list, [], [])</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    帮你监管</span></span><br><span class="line"><span class="string">    一旦有人来了 立刻给你返回对应的监管对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># print(res)  # ([&lt;socket.socket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;127.0.0.1&#x27;, 8080)&gt;], [], [])</span></span><br><span class="line">    <span class="comment"># print(server)</span></span><br><span class="line">    <span class="comment"># print(r_list)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> r_list:  <span class="comment">#</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;针对不同的对象做不同的处理&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">is</span> server:</span><br><span class="line">            conn, addr = i.accept()</span><br><span class="line">            <span class="comment"># 也应该添加到监管的队列中</span></span><br><span class="line">            read_list.append(conn)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = i.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span>:</span><br><span class="line">                i.close()</span><br><span class="line">                <span class="comment"># 将无效的监管对象 移除</span></span><br><span class="line">                read_list.remove(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            i.send(<span class="string">b&#x27;heiheiheiheihei&#x27;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    client.send(<span class="string">b&#x27;hello world&#x27;</span>)</span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">监管机制其实有很多</span></span><br><span class="line"><span class="string">select机制  windows linux都有</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">poll机制    只在linux有   poll和select都可以监管多个对象 但是poll监管的数量更多</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上述select和poll机制其实都不是很完美 当监管的对象特别多的时候</span></span><br><span class="line"><span class="string">可能会出现 极其大的延时响应</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">epoll机制   只在linux有</span></span><br><span class="line"><span class="string">	它给每一个监管对象都绑定一个回调机制</span></span><br><span class="line"><span class="string">	一旦有响应 回调机制立刻发起提醒</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">针对不同的操作系统还需要考虑不同检测机制 书写代码太多繁琐</span></span><br><span class="line"><span class="string">有一个人能够根据你跑的平台的不同自动帮你选择对应的监管机制</span></span><br><span class="line"><span class="string">selectors模块</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h3><p>　　首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110837225-1379057547.png" alt="img"></p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>　　这个模型工作机制是：告诉内核启动某个操作，并让内核在整个操作(包括第二阶段，即将数据从内核拷贝到进程缓冲区中)完成后通知我们。</p>
<p>这种模型和前一种模型区别在于：信号驱动I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.IO%E6%A8%A1%E5%9E%8B/137084-20180611110843727-154944469.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">异步IO模型是所有模型中效率最高的 也是使用最广泛的</span></span><br><span class="line"><span class="string">相关的模块和框架</span></span><br><span class="line"><span class="string">	模块:asyncio模块</span></span><br><span class="line"><span class="string">	异步框架:sanic tronado twisted</span></span><br><span class="line"><span class="string">		速度快！！！</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world %s&#x27;</span>%threading.current_thread())</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 换成真正的IO操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world %s&#x27;</span> % threading.current_thread())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [hello(),hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p><strong>高性能IO模型浅析</strong> </p>
<p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：</p>
<p>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。</p>
<p>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase">Java</a>的NIO（New IO）库。</p>
<p>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，Java中的Selector和<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/linux">Linux</a>中的epoll都是这种模型。</p>
<p>（4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/18/IO%E6%A8%A1%E5%9E%8B_hexo/" data-id="ckxjra7oj0000r0v1abee60j1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql for python_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/18/mysql%20for%20python_hexo/" class="article-date">
  <time datetime="2021-11-18T09:24:46.000Z" itemprop="datePublished">2021-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/18/mysql%20for%20python_hexo/">mysql for python</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="mysql-for-python"><a href="#mysql-for-python" class="headerlink" title="mysql for python"></a>mysql for python</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>数据库是一种按照数据结构来组织、存储和管理数据的仓库，一般数据库软件均为C/S架构，目前数据库软件分为两种，关系型数据库与非关系型数据，常见的关系型数据库有：mysql(mariadb),oracle,pgsql等，非关系型数据库有mongodb,redis(也是消息队列)。</p>
<p>mysql是目前互联网公司中最常用的关系型数据库之一。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>日常生活中文件格式有很多中，并且针对不同的文件格式会有对应不同存储方式和处理机制(txt,pdf,word,mp4…)</p>
<p>针对不同的数据应该有对应的不同的处理机制来存储</p>
<p>存储引擎就是不同的处理机制</p>
<p><strong>MySQL主要存储引擎</strong></p>
<ul>
<li><p>Innodb</p>
<p>  是MySQL5.5版本及之后默认的存储引擎</p>
<p>  存储数据更加的安全</p>
</li>
<li><p>myisam</p>
<p>  是MySQL5.5版本之前默认的存储引擎</p>
<p>  速度要比Innodb更快 但是我们更加注重的是数据的安全</p>
</li>
<li><p>memory</p>
<p>  内存引擎(数据全部存放在内存中) 断电数据丢失</p>
</li>
<li><p>blackhole</p>
<p>  无论存什么，都立刻消失(黑洞)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 查看所有的存储引擎</span></span><br><span class="line"><span class="string">show engines;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 不同的存储引擎在存储表的时候 异同点</span></span><br><span class="line"><span class="string">create table t1(id int) engine=innodb;</span></span><br><span class="line"><span class="string">create table t2(id int) engine=myisam;</span></span><br><span class="line"><span class="string">create table t3(id int) engine=blackhole;</span></span><br><span class="line"><span class="string">create table t4(id int) engine=memory;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 存数据</span></span><br><span class="line"><span class="string">insert into t1 values(1);</span></span><br><span class="line"><span class="string">insert into t2 values(1);</span></span><br><span class="line"><span class="string">insert into t3 values(1);</span></span><br><span class="line"><span class="string">insert into t4 values(1);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h3><p>DQL：数据查询语言，用于对数据进行查询，如select<br>        DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete<br>        TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback<br>        DCL：数据控制语言，进行授权与权限回收，如grant、revoke<br>        DDL：数据定义语言，进行数据库、表的管理等，如create、drop</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><ul>
<li><p>分类</p>
<p>  TINYINT SMALLINT MEDUIMINT INT BIGINT</p>
</li>
<li><p>作用</p>
<p>  存储年龄、等级、id、号码等等</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">以TINYINT </span></span><br><span class="line"><span class="string">	是否有符号</span></span><br><span class="line"><span class="string">		默认情况下是带符号的</span></span><br><span class="line"><span class="string">	超出会如何</span></span><br><span class="line"><span class="string">		超出限制只存最大可接受值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table t9(<span class="built_in">id</span> tinyint);</span><br><span class="line">insert into t9 values(-<span class="number">129</span>),(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 约束条件之unsigned 无符号</span></span><br><span class="line">create table t10(<span class="built_in">id</span> tinyint unsigned);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table t11(<span class="built_in">id</span> <span class="built_in">int</span>);</span><br><span class="line"><span class="comment"># int默认也是带符号的  </span></span><br><span class="line"><span class="comment"># 整型默认情况下都是带有符号的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对整型 括号内的宽度到底是干嘛的</span></span><br><span class="line">create table t12(<span class="built_in">id</span> <span class="built_in">int</span>(<span class="number">8</span>));</span><br><span class="line">insert into t12 values(<span class="number">123456789</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">特例:只有整型括号里面的数字不是表示限制位数</span></span><br><span class="line"><span class="string">id int(8)</span></span><br><span class="line"><span class="string">	如果数字没有超出8位 那么默认用空格填充至8位</span></span><br><span class="line"><span class="string">	如果数字超出了8位 那么有几位就存几位(但是还是要遵守最大范围)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table t13(<span class="built_in">id</span> <span class="built_in">int</span>(<span class="number">8</span>) unsigned zerofill);</span><br><span class="line"><span class="comment"># 用0填充至8位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结:</span></span><br><span class="line">针对整型字段 括号内无需指定宽度 因为它默认的宽度以及足够显示所有的数据了</span><br></pre></td></tr></table></figure>

<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul>
<li><p>分类</p>
<p>  FLOAT、DOUBLE、DECIMAL</p>
</li>
<li><p>作用</p>
<p>  身高、体重、薪资</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储限制</span></span><br><span class="line"><span class="built_in">float</span>(<span class="number">255</span>,<span class="number">30</span>)  <span class="comment"># 总共255位 小数部分占30位</span></span><br><span class="line">double(<span class="number">255</span>,<span class="number">30</span>)  <span class="comment"># 总共255位 小数部分占30位</span></span><br><span class="line">decimal(<span class="number">65</span>,<span class="number">30</span>)  <span class="comment"># 总共65位 小数部分占30位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确度验证</span></span><br><span class="line">create table t15(<span class="built_in">id</span> <span class="built_in">float</span>(<span class="number">255</span>,<span class="number">30</span>));</span><br><span class="line">create table t16(<span class="built_in">id</span> double(<span class="number">255</span>,<span class="number">30</span>));</span><br><span class="line">create table t17(<span class="built_in">id</span> decimal(<span class="number">65</span>,<span class="number">30</span>));</span><br><span class="line"><span class="string">&quot;&quot;&quot;你们在前期不要给我用反向键 所有的命令全部手敲！！！增加熟练度&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">insert into t15 values(<span class="number">1.111111111111111111111111111111</span>);</span><br><span class="line">insert into t16 values(<span class="number">1.111111111111111111111111111111</span>);</span><br><span class="line">insert into t17 values(<span class="number">1.111111111111111111111111111111</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> &lt; double &lt; decimal</span><br><span class="line"><span class="comment"># 要结合实际应用场景 三者都能使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul>
<li><p>分类</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">char</span></span><br><span class="line"><span class="string">	定长</span></span><br><span class="line"><span class="string">	char(4)	 数据超过四个字符直接报错 不够四个字符空格补全</span></span><br><span class="line"><span class="string">varchar</span></span><br><span class="line"><span class="string">	变长</span></span><br><span class="line"><span class="string">	varchar(4)  数据超过四个字符直接报错 不够有几个存几个</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table t18(name char(<span class="number">4</span>));</span><br><span class="line">create table t19(name varchar(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">insert into t18 values(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">insert into t19 values(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 介绍一个小方法 char_length统计字段长度</span></span><br><span class="line">select char_length(name) <span class="keyword">from</span> t18;</span><br><span class="line">select char_length(name) <span class="keyword">from</span> t19;</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">首先可以肯定的是 char硬盘上存的绝对是真正的数据 带有空格的</span></span><br><span class="line"><span class="string">但是在显示的时候MySQL会自动将多余的空格剔除</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次修改sql_mode 让MySQL不要做自动剔除操作</span></span><br><span class="line"><span class="built_in">set</span> <span class="keyword">global</span> sql_mode = <span class="string">&#x27;STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="char与varchar对比"><a href="#char与varchar对比" class="headerlink" title="char与varchar对比"></a>char与varchar对比</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">char</span></span><br><span class="line"><span class="string">	缺点:浪费空间</span></span><br><span class="line"><span class="string">	优点:存取都很简单</span></span><br><span class="line"><span class="string">		直接按照固定的字符存取数据即可</span></span><br><span class="line"><span class="string">		jason egon alex wusir tank </span></span><br><span class="line"><span class="string">		存按照五个字符存 取也直接按照五个字符取</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">varchar</span></span><br><span class="line"><span class="string">	优点:节省空间</span></span><br><span class="line"><span class="string">	缺点:存取较为麻烦</span></span><br><span class="line"><span class="string">		1bytes+jason 1bytes+egon 1bytes+alex 1bytes+tank </span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		存的时候需要制作报头</span></span><br><span class="line"><span class="string">		取的时候也需要先读取报头 之后才能读取真实数据</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">以前基本上都是用的char 其实现在用varchar的也挺多</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">补充:</span><br><span class="line">    进来公司之后你完全不需要考虑字段类型和字段名</span><br><span class="line">    因为产品经理给你发的邮件上已经全部指明了</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><ul>
<li><p>分类</p>
<p>  date:年月日 2020-5-4</p>
<p>  datetime:年月日时分秒  2020-5-4 11:11:11</p>
<p>  time:时分秒11:11:11</p>
<p>  Year:2020</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table student(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">    name varchar(<span class="number">16</span>),</span><br><span class="line">    born_year year,</span><br><span class="line">    birth date,</span><br><span class="line">    study_time time,</span><br><span class="line">    reg_time datetime</span><br><span class="line">);</span><br><span class="line">insert into student values(<span class="number">1</span>,<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;1880&#x27;</span>,<span class="string">&#x27;1880-11-11&#x27;</span>,<span class="string">&#x27;11:11:11&#x27;</span>,<span class="string">&#x27;2020-11-11 11:11:11&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="枚举与集合类型"><a href="#枚举与集合类型" class="headerlink" title="枚举与集合类型"></a>枚举与集合类型</h4><ul>
<li><p>分类</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">枚举(enum)  多选一</span></span><br><span class="line"><span class="string">集合(set)   多选多</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>具体使用</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">    name char(<span class="number">16</span>),</span><br><span class="line">    gender enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;others&#x27;</span>)</span><br><span class="line">);</span><br><span class="line">insert into user values(<span class="number">1</span>,<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;male&#x27;</span>);  正常</span><br><span class="line">insert into user values(<span class="number">2</span>,<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;xxxxooo&#x27;</span>);  报错</span><br><span class="line"><span class="comment"># 枚举字段 后期在存数据的时候只能从枚举里面选择一个存储 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table teacher(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">    name char(<span class="number">16</span>),</span><br><span class="line">    gender enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;others&#x27;</span>),</span><br><span class="line">    hobby <span class="built_in">set</span>(<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;DBJ&#x27;</span>,<span class="string">&#x27;hecha&#x27;</span>)</span><br><span class="line">);</span><br><span class="line">insert into teacher values(<span class="number">1</span>,<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;read&#x27;</span>);  正常</span><br><span class="line">insert into teacher values(<span class="number">2</span>,<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;DBJ,hecha&#x27;</span>);  正常</span><br><span class="line">insert into teacher values(<span class="number">3</span>,<span class="string">&#x27;tank&#x27;</span>,<span class="string">&#x27;others&#x27;</span>,<span class="string">&#x27;生蚝&#x27;</span>); 报错</span><br><span class="line"><span class="comment"># 集合可以只写一个  但是不能写没有列举的</span></span><br></pre></td></tr></table></figure>

<p>  <strong>总结</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字段类型</span></span><br><span class="line"><span class="string">严格模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">约束条件</span></span><br><span class="line"><span class="string">	not null</span></span><br><span class="line"><span class="string">	zerofill</span></span><br><span class="line"><span class="string">	unsigned</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><h4 id="default默认值"><a href="#default默认值" class="headerlink" title="default默认值"></a>default默认值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充知识点  插入数据的时候可以指定字段</span></span><br><span class="line">create table t1(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">    name char(<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line">insert into t1(name,<span class="built_in">id</span>) values(<span class="string">&#x27;jason&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">create table t2(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">    name char(<span class="number">16</span>),</span><br><span class="line">    gender enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;others&#x27;</span>) default <span class="string">&#x27;male&#x27;</span></span><br><span class="line">);</span><br><span class="line">insert into t2(<span class="built_in">id</span>,name) values(<span class="number">1</span>,<span class="string">&#x27;jason&#x27;</span>);</span><br><span class="line">insert into t2 values(<span class="number">2</span>,<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;female&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="unique唯一"><a href="#unique唯一" class="headerlink" title="unique唯一"></a>unique唯一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单列唯一</span></span><br><span class="line">create table t3(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> unique,</span><br><span class="line">    name char(<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line">insert into t3 values(<span class="number">1</span>,<span class="string">&#x27;jason&#x27;</span>),(<span class="number">1</span>,<span class="string">&#x27;egon&#x27;</span>);</span><br><span class="line">insert into t3 values(<span class="number">1</span>,<span class="string">&#x27;jason&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;egon&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 联合唯一</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ip和port</span></span><br><span class="line"><span class="string">单个都可以重复 但是加载一起必须是唯一的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table t4(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">    ip char(<span class="number">16</span>),</span><br><span class="line">    port <span class="built_in">int</span>,</span><br><span class="line">    unique(ip,port)</span><br><span class="line">);</span><br><span class="line">insert into t4 values(<span class="number">1</span>,<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>);</span><br><span class="line">insert into t4 values(<span class="number">2</span>,<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8081</span>);</span><br><span class="line">insert into t4 values(<span class="number">3</span>,<span class="string">&#x27;127.0.0.2&#x27;</span>,<span class="number">8080</span>);</span><br><span class="line">insert into t4 values(<span class="number">4</span>,<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>);  报错</span><br></pre></td></tr></table></figure>

<h4 id="primary-key主键"><a href="#primary-key主键" class="headerlink" title="primary key主键"></a>primary key主键</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.单单从约束效果上来看primary key等价于not null + unique</span></span><br><span class="line"><span class="string">非空且唯一！！！</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table t5(<span class="built_in">id</span> <span class="built_in">int</span> primary key);</span><br><span class="line">insert into t5 values(null);  报错</span><br><span class="line">insert into t5 values(<span class="number">1</span>),(<span class="number">1</span>);  报错</span><br><span class="line">insert into t5 values(<span class="number">1</span>),(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2.它除了有约束效果之外 它还是Innodb存储引擎组织数据的依据</span></span><br><span class="line"><span class="string">Innodb存储引擎在创建表的时候必须要有primary key</span></span><br><span class="line"><span class="string">因为它类似于书的目录 能够帮助提示查询效率并且也是建表的依据</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 1 一张表中有且只有一个主键 如果你没有设置主键 那么会从上往下搜索直到遇到一个非空且唯一的字段将它自动升级为主键</span></span><br><span class="line">create table t6(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">    name char(<span class="number">16</span>),</span><br><span class="line">    age <span class="built_in">int</span> <span class="keyword">not</span> null unique,</span><br><span class="line">    addr char(<span class="number">32</span>) <span class="keyword">not</span> null unique</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 如果表中没有主键也没有其他任何的非空且唯一字段 那么Innodb会采用自己内部提供的一个隐藏字段作为主键，隐藏意味着你无法使用到它 就无法提示查询速度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 一张表中通常都应该有一个主键字段 并且通常将id/uid/sid字段作为主键</span></span><br><span class="line"><span class="comment"># 单个字段主键</span></span><br><span class="line">create table t5(</span><br><span class="line">    <span class="built_in">id</span> <span class="built_in">int</span> primary key</span><br><span class="line">	name char(<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment"># 联合主键(多个字段联合起来作为表的主键 本质还是一个主键)</span></span><br><span class="line">create table t7(</span><br><span class="line">    ip char(<span class="number">16</span>),</span><br><span class="line">    port <span class="built_in">int</span>,</span><br><span class="line">    primary key(ip,port)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">也意味着 以后我们在创建表的时候id字段一定要加primary key</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="auto-increment自增"><a href="#auto-increment自增" class="headerlink" title="auto_increment自增"></a>auto_increment自增</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当编号特别多的时候 人为的去维护太麻烦</span></span><br><span class="line">create table t8(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    name char(<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line">insert into t8(name) values(<span class="string">&#x27;jason&#x27;</span>),(<span class="string">&#x27;egon&#x27;</span>),(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意auto_increment通常都是加在主键上的 不能给普通字段加</span></span><br><span class="line">create table t9(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    name char(<span class="number">16</span>),</span><br><span class="line">    cid <span class="built_in">int</span> auto_increment</span><br><span class="line">);</span><br><span class="line">ERROR <span class="number">1075</span> (<span class="number">42000</span>): Incorrect table definition; there can be only one auto column <span class="keyword">and</span> it must be defined <span class="keyword">as</span> a key</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">以后在创建表的id(数据的唯一标识id、uid、sid)字段的时候</span></span><br><span class="line"><span class="string">id int primary key auto_increment</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>补充</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> t1  删除表中数据后 主键的自增不会停止</span><br><span class="line"></span><br><span class="line">truncate t1  清空表数据并且重置主键</span><br></pre></td></tr></table></figure>

<h3 id="表与表之间建关系"><a href="#表与表之间建关系" class="headerlink" title="表与表之间建关系"></a>表与表之间建关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">定义一张员工表 表中有很多字段</span></span><br><span class="line"><span class="string">id name gender dep_name dep_desc</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 1 该表的组织结构不是很清晰(可忽视)</span></span><br><span class="line"><span class="comment"># 2 浪费硬盘空间(可忽视)</span></span><br><span class="line"><span class="comment"># 3 数据的扩展性极差(无法忽视的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何优化？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;上述问题就类似于你将所有的代码都写在了一个py文件中&quot;&quot;&quot;</span></span><br><span class="line">将员工表拆分  员工表和部门表</span><br></pre></td></tr></table></figure>

<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	外键就是用来帮助我们建立表与表之间关系的，对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性</span></span><br><span class="line"><span class="string">	添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);</span></span><br><span class="line"><span class="string">	删除外键约束: alter table 表名 drop foreign key 外键名;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">表与表之间最多只有四种关系</span></span><br><span class="line"><span class="string">	一对多关系</span></span><br><span class="line"><span class="string">		在MySQL的关系中没有多对一一说</span></span><br><span class="line"><span class="string">		一对多 多对一 都叫一对多！！！</span></span><br><span class="line"><span class="string">	多对多关系</span></span><br><span class="line"><span class="string">	一对一关系</span></span><br><span class="line"><span class="string">	没有关系</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">判断表与表之间关系的时候 前期不熟悉的情况下 一定要按照我给你的建议</span></span><br><span class="line"><span class="string">换位思考  分别站在两张表的角度考虑</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">员工表与部门表为例</span></span><br><span class="line"><span class="string">	先站在员工表</span></span><br><span class="line"><span class="string">		思考一个员工能否对应多个部门(一条员工数据能否对应多条部门数据)</span></span><br><span class="line"><span class="string">			不能！！！</span></span><br><span class="line"><span class="string">			(不能直接得出结论 一定要两张表都考虑完全)</span></span><br><span class="line"><span class="string">	再站在部门表</span></span><br><span class="line"><span class="string">		思考一个部门能否对应多个员工(一个部门数据能否对应多条员工数据)</span></span><br><span class="line"><span class="string">			能！！！</span></span><br><span class="line"><span class="string">	得出结论</span></span><br><span class="line"><span class="string">		员工表与部门表示单向的一对多</span></span><br><span class="line"><span class="string">		所以表关系就是一对多</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">foreign key</span><br><span class="line">	<span class="number">1</span> 一对多表关系   外键字段建在多的一方</span><br><span class="line">    <span class="number">2</span> 在创建表的时候 一定要先建被关联表 </span><br><span class="line">    <span class="number">3</span> 在录入数据的时候 也必须先录入被关联表</span><br><span class="line"><span class="comment"># SQL语句建立表关系</span></span><br><span class="line">create table dep(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    dep_name char(<span class="number">16</span>),</span><br><span class="line">    dep_desc char(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    name char(<span class="number">16</span>),</span><br><span class="line">    gender enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;others&#x27;</span>) default <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    dep_id <span class="built_in">int</span>,</span><br><span class="line">    foreign key(dep_id) references dep(<span class="built_in">id</span>)</span><br><span class="line">);</span><br><span class="line">insert into dep(dep_name,dep_desc) values(<span class="string">&#x27;sb教学部&#x27;</span>,<span class="string">&#x27;教书育人&#x27;</span>),(<span class="string">&#x27;外交部&#x27;</span>,<span class="string">&#x27;多人外交&#x27;</span>),(<span class="string">&#x27;nb技术部&#x27;</span>,<span class="string">&#x27;技术能力有限部门&#x27;</span>);</span><br><span class="line">insert into emp(name,dep_id) values(<span class="string">&#x27;jason&#x27;</span>,<span class="number">2</span>),(<span class="string">&#x27;egon&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;tank&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;kevin&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改dep表里面的id字段</span></span><br><span class="line">update dep <span class="built_in">set</span> <span class="built_in">id</span>=<span class="number">200</span> where <span class="built_in">id</span>=<span class="number">2</span>;  不行</span><br><span class="line"><span class="comment"># 删除dep表里面的数据</span></span><br><span class="line">delete <span class="keyword">from</span> dep;  不行</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 先删除教学部对应的员工数据 之后再删除部门</span></span><br><span class="line">	操作太过繁琐</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2 真正做到数据之间有关系</span></span><br><span class="line">	更新就同步更新</span><br><span class="line">    删除就同步删除</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">级联更新   &gt;&gt;&gt;   同步更新</span></span><br><span class="line"><span class="string">级联删除   &gt;&gt;&gt;   同步删除</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table dep(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    dep_name char(<span class="number">16</span>),</span><br><span class="line">    dep_desc char(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    name char(<span class="number">16</span>),</span><br><span class="line">    gender enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;others&#x27;</span>) default <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    dep_id <span class="built_in">int</span>,</span><br><span class="line">    foreign key(dep_id) references dep(<span class="built_in">id</span>) </span><br><span class="line">    on update cascade  <span class="comment"># 同步更新</span></span><br><span class="line">    on delete cascade  <span class="comment"># 同步删除</span></span><br><span class="line">);</span><br><span class="line">insert into dep(dep_name,dep_desc) values(<span class="string">&#x27;sb教学部&#x27;</span>,<span class="string">&#x27;教书育人&#x27;</span>),(<span class="string">&#x27;外交部&#x27;</span>,<span class="string">&#x27;多人外交&#x27;</span>),(<span class="string">&#x27;nb技术部&#x27;</span>,<span class="string">&#x27;技术能力有限部门&#x27;</span>);</span><br><span class="line">insert into emp(name,dep_id) values(<span class="string">&#x27;jason&#x27;</span>,<span class="number">2</span>),(<span class="string">&#x27;egon&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;tank&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;kevin&#x27;</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">图书表和作者表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table book(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    title varchar(<span class="number">32</span>),</span><br><span class="line">    price <span class="built_in">int</span>,</span><br><span class="line">    author_id <span class="built_in">int</span>,</span><br><span class="line">    foreign key(author_id) references author(<span class="built_in">id</span>) </span><br><span class="line">    on update cascade  <span class="comment"># 同步更新</span></span><br><span class="line">    on delete cascade  <span class="comment"># 同步删除</span></span><br><span class="line">);</span><br><span class="line">create table author(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    name varchar(<span class="number">32</span>),</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    book_id <span class="built_in">int</span>,</span><br><span class="line">    foreign key(book_id) references book(<span class="built_in">id</span>) </span><br><span class="line">    on update cascade  <span class="comment"># 同步更新</span></span><br><span class="line">    on delete cascade  <span class="comment"># 同步删除</span></span><br><span class="line">);</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">按照上述的方式创建 一个都别想成功！！！</span></span><br><span class="line"><span class="string">其实我们只是想记录书籍和作者的关系</span></span><br><span class="line"><span class="string">针对多对多字段表关系 不能在两张原有的表中创建外键</span></span><br><span class="line"><span class="string">需要你单独再开设一张 专门用来存储两张表数据之间的关系</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table book(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    title varchar(<span class="number">32</span>),</span><br><span class="line">    price <span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line">create table author(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    name varchar(<span class="number">32</span>),</span><br><span class="line">    age <span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line">create table book2author(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    author_id <span class="built_in">int</span>,</span><br><span class="line">    book_id <span class="built_in">int</span>,</span><br><span class="line">    foreign key(author_id) references author(<span class="built_in">id</span>) </span><br><span class="line">    on update cascade  <span class="comment"># 同步更新</span></span><br><span class="line">    on delete cascade,  <span class="comment"># 同步删除</span></span><br><span class="line">    foreign key(book_id) references book(<span class="built_in">id</span>) </span><br><span class="line">    on update cascade  <span class="comment"># 同步更新</span></span><br><span class="line">    on delete cascade  <span class="comment"># 同步删除</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">id name age addr phone hobby email........</span></span><br><span class="line"><span class="string">如果一个表的字段特别多 每次查询又不是所有的字段都能用得到</span></span><br><span class="line"><span class="string">将表一分为二  </span></span><br><span class="line"><span class="string">	用户表</span></span><br><span class="line"><span class="string">		用户表</span></span><br><span class="line"><span class="string">			id name age</span></span><br><span class="line"><span class="string">		用户详情表</span></span><br><span class="line"><span class="string">			id addr phone hobby email........</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	站在用户表</span></span><br><span class="line"><span class="string">		一个用户能否对应多个用户详情   不能！！！</span></span><br><span class="line"><span class="string">	站在详情表</span></span><br><span class="line"><span class="string">		一个详情能否属于多个用户      不能！！！</span></span><br><span class="line"><span class="string">	结论:单向的一对多都不成立 那么这个时候两者之间的表关系</span></span><br><span class="line"><span class="string">		就是一对一</span></span><br><span class="line"><span class="string">		或者没有关系(好判断)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">客户表和学生表</span></span><br><span class="line"><span class="string">	在你们报名之前你们是客户端</span></span><br><span class="line"><span class="string">	报名之后是学生(期间有一些客户不会报名)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">一对一 外键字段建在任意一方都可以 但是推荐你建在查询频率比较高的表中</span><br><span class="line">create table authordetail(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    phone <span class="built_in">int</span>,</span><br><span class="line">    addr varchar(<span class="number">64</span>)</span><br><span class="line">);</span><br><span class="line">create table author(</span><br><span class="line">	<span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    name varchar(<span class="number">32</span>),</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    authordetail_id <span class="built_in">int</span> unique,</span><br><span class="line">    foreign key(authordetail_id) references authordetail(<span class="built_in">id</span>) </span><br><span class="line">    on update cascade  <span class="comment"># 同步更新</span></span><br><span class="line">    on delete cascade  <span class="comment"># 同步删除</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">表关系的建立需要用到foreign key</span></span><br><span class="line"><span class="string">	一对多</span></span><br><span class="line"><span class="string">		外键字段建在多的一方</span></span><br><span class="line"><span class="string">	多对多</span></span><br><span class="line"><span class="string">		自己开设第三张存储</span></span><br><span class="line"><span class="string">	一对一</span></span><br><span class="line"><span class="string">		建在任意一方都可以 但是推荐你建在查询频率较高的表中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">判断表之间关系的方式</span></span><br><span class="line"><span class="string">	换位思考！！！</span></span><br><span class="line"><span class="string">		员工与部门</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">		图书与作者</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">		作者与作者详情</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">create table 表名(</span><br><span class="line">	字段名<span class="number">1</span> 类型(宽度) 约束条件,</span><br><span class="line">    字段名<span class="number">2</span> 类型(宽度) 约束条件,</span><br><span class="line">    字段名<span class="number">3</span> 类型(宽度) 约束条件</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意</span></span><br><span class="line"><span class="number">1</span> 在同一张表中字段名不能重复</span><br><span class="line"><span class="number">2</span> 宽度和约束条件是可选的(可写可不写) 而字段名和字段类型是必须的</span><br><span class="line">	约束条件写的话 也支持写多个</span><br><span class="line">    字段名<span class="number">1</span> 类型(宽度) 约束条件<span class="number">1</span> 约束条件<span class="number">2.</span>..,</span><br><span class="line">	create table t5(<span class="built_in">id</span>);  报错</span><br><span class="line"><span class="number">3</span> 最后一行不能有逗号</span><br><span class="line">	create table t6(</span><br><span class="line">        <span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">        name char,</span><br><span class="line">    );   报错</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;补充&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 宽度</span></span><br><span class="line">	一般情况下指的是对存储数据的限制</span><br><span class="line">	create table t7(name char);  默认宽度是<span class="number">1</span></span><br><span class="line">    insert into t7 values(<span class="string">&#x27;jason&#x27;</span>);</span><br><span class="line">    insert into t7 values(null);  关键字NULL</span><br><span class="line">    	针对不同的版本会出现不同的效果</span><br><span class="line">        	<span class="number">5.6</span>版本默认没有开启严格模式 规定只能存一个字符你给了多个字符，那么我会自动帮你截取</span><br><span class="line">            <span class="number">5.7</span>版本及以上或者开启了严格模式 那么规定只能存几个 就不能超，一旦超出范围立刻报错 Data too long <span class="keyword">for</span> ....</span><br><span class="line"><span class="string">&quot;&quot;&quot;严格模式到底开不开呢？&quot;&quot;&quot;</span></span><br><span class="line">MySQL5<span class="number">.7</span>之后的版本默认都是开启严格模式的</span><br><span class="line">使用数据库的准则:</span><br><span class="line">	能尽量少的让数据库干活就尽量少 不要给数据库增加额外的压力</span><br><span class="line"></span><br><span class="line"><span class="comment"># 约束条件 null  not null不能插入null</span></span><br><span class="line">create table t8(<span class="built_in">id</span> <span class="built_in">int</span>,name char <span class="keyword">not</span> null);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">宽度和约束条件到底是什么关系</span></span><br><span class="line"><span class="string">	宽度是用来限制数据的存储</span></span><br><span class="line"><span class="string">	约束条件是在宽度的基础之上增加的额外的约束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MySQL对大小写是不敏感的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1 修改表名</span></span><br><span class="line"><span class="string">	alter table 表名 rename 新表名;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2 增加字段</span></span><br><span class="line"><span class="string">	alter table 表名 add 字段名 字段类型(宽度)  约束条件;</span></span><br><span class="line"><span class="string">	alter table 表名 add 字段名 字段类型(宽度)  约束条件 first;</span></span><br><span class="line"><span class="string">	alter table 表名 add 字段名 字段类型(宽度)  约束条件 after 字段名;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3 删除字段</span></span><br><span class="line"><span class="string">	alter table 表名 drop 字段名;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4 修改字段</span></span><br><span class="line"><span class="string">	alter table 表名 modify 字段名 字段类型(宽度) 约束条件;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	alter table 表名 change 旧字段名 新字段名 字段类型(宽度) 约束条件;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们sql语句查询的结果其实也是一张虚拟表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">create table 表名 select * <span class="keyword">from</span> 旧表;  不能复制主键 外键 ...</span><br><span class="line"></span><br><span class="line">create table new_dep2 select * <span class="keyword">from</span> dep where <span class="built_in">id</span>&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<h3 id="表查询操作"><a href="#表查询操作" class="headerlink" title="表查询操作"></a>表查询操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">select 查询语句</span><br><span class="line">select 字段名 from 表名</span><br><span class="line">as :给字段名或表取别名,例如	</span><br><span class="line">	select * from studentu as a </span><br><span class="line">distinct:distinct可以去除重复数据行。</span><br><span class="line">	select distinct 列1,... from 表名;</span><br><span class="line">where:条件查询</span><br><span class="line">	select * from 表名 where 条件;</span><br><span class="line">order by : 排序</span><br><span class="line">	select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</span><br><span class="line">	例：</span><br><span class="line">		select * from students where gender=1 and is_delete=0 order by id desc;</span><br><span class="line">		asc 表示升序</span><br><span class="line">		desc 表示降序</span><br><span class="line">limit ：分页查询</span><br><span class="line">	select * from 表名 limit start,count</span><br><span class="line">	limit是分页查询关键字</span><br><span class="line">	start表示开始行索引，默认是0</span><br><span class="line">	count表示查询条数</span><br><span class="line">	例：查询前3行男生信息:</span><br><span class="line">		select * from students where gender=1 limit 0,3;</span><br><span class="line">		简写</span><br><span class="line">		select * from students where gender=1 limit 3;</span><br><span class="line">聚合函数:</span><br><span class="line">		count(col): 表示求指定列的总行数</span><br><span class="line">		max(col): 表示求指定列的最大值</span><br><span class="line">		min(col): 表示求指定列的最小值</span><br><span class="line">		sum(col): 表示求指定列的和</span><br><span class="line">		avg(col): 表示求指定列的平均值</span><br><span class="line">GROUP BY: 分组查询</span><br><span class="line">	GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]</span><br><span class="line">	列名: 是指按照指定字段的值进行分组。</span><br><span class="line">	HAVING 条件表达式: 用来过滤分组后的数据。</span><br><span class="line">	WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果</span><br><span class="line">	例：</span><br><span class="line">		-- 根据gender字段来分组</span><br><span class="line">		select gender from students group by gender;</span><br><span class="line">		-- 根据name和gender字段进行分组</span><br><span class="line">		select name, gender from students group by name, gender;</span><br><span class="line">	</span><br><span class="line">	group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割</span><br><span class="line">	例：</span><br><span class="line">		-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息</span><br><span class="line">		select gender,group_concat(name) from students group by gender;</span><br><span class="line">连接查询：</span><br><span class="line">	内连接查询：内连接根据连接查询条件取出两个表的 “交集”</span><br><span class="line">	左连接查询：左连接以左表为主根据条件查询右表数据，右表数据不存在使用null值填充。</span><br><span class="line">	右连接查询：右连接以右表为主根据条件查询左表数据，左表数据不存在使用null值填充。</span><br><span class="line">	自连接查询</span><br><span class="line">	</span><br><span class="line">	内连接查询语法格式:</span><br><span class="line">		select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2</span><br><span class="line">	左连接查询语法格式:</span><br><span class="line">		select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2</span><br><span class="line">	右连接查询语法格式:</span><br><span class="line">		select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2</span><br><span class="line">	自连接查询：</span><br><span class="line">		自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。</span><br><span class="line">		自连接就是一种特殊的连接方式，连接的表还是本身这张表</span><br><span class="line">		自连接查询必须对表起别名</span><br><span class="line">		自连接查询的用法:</span><br><span class="line">		select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = &#x27;山西省&#x27;;</span><br><span class="line">子查询：</span><br><span class="line">	在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询.</span><br><span class="line">	主查询和子查询的关系:</span><br><span class="line">	子查询是嵌入到主查询中</span><br><span class="line">	子查询是辅助主查询的,要么充当条件,要么充当数据源</span><br><span class="line">	子查询是可以独立存在的语句,是一条完整的 select 语句</span><br></pre></td></tr></table></figure>

<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如何查看严格模式</span></span><br><span class="line">show variables like <span class="string">&quot;%mode&quot;</span>;</span><br><span class="line"></span><br><span class="line">模糊匹配/查询</span><br><span class="line">	关键字 like</span><br><span class="line">		%:匹配任意多个字符</span><br><span class="line">        _:匹配任意单个字符</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改严格模式</span></span><br><span class="line">	<span class="built_in">set</span> session  只在当前窗口有效</span><br><span class="line">    <span class="built_in">set</span> <span class="keyword">global</span>   全局有效</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span> <span class="keyword">global</span> sql_mode = <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    修改完之后 重新进入服务端即可</span><br></pre></td></tr></table></figure>

<h4 id="前期表准备（实例）"><a href="#前期表准备（实例）" class="headerlink" title="前期表准备（实例）"></a>前期表准备（实例）</h4><p>（针对下面一直到正则的查询语句）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">  <span class="built_in">id</span> <span class="built_in">int</span> <span class="keyword">not</span> null unique auto_increment,</span><br><span class="line">  name varchar(<span class="number">20</span>) <span class="keyword">not</span> null,</span><br><span class="line">  sex enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>) <span class="keyword">not</span> null default <span class="string">&#x27;male&#x27;</span>, <span class="comment">#大部分是男的</span></span><br><span class="line">  age <span class="built_in">int</span>(<span class="number">3</span>) unsigned <span class="keyword">not</span> null default <span class="number">28</span>,</span><br><span class="line">  hire_date date <span class="keyword">not</span> null,</span><br><span class="line">  post varchar(<span class="number">50</span>),</span><br><span class="line">  post_comment varchar(<span class="number">100</span>),</span><br><span class="line">  salary double(<span class="number">15</span>,<span class="number">2</span>),</span><br><span class="line">  office <span class="built_in">int</span>, <span class="comment">#一个部门一个屋子</span></span><br><span class="line">  depart_id <span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入记录</span></span><br><span class="line"><span class="comment">#三个部门：教学，销售，运营</span></span><br><span class="line">insert into emp(name,sex,age,hire_date,post,salary,office,depart_id) values</span><br><span class="line">(<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;20170301&#x27;</span>,<span class="string">&#x27;张江第一帅形象代言&#x27;</span>,<span class="number">7300.33</span>,<span class="number">401</span>,<span class="number">1</span>), <span class="comment">#以下是教学部</span></span><br><span class="line">(<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">78</span>,<span class="string">&#x27;20150302&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="number">1000000.31</span>,<span class="number">401</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;kevin&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">81</span>,<span class="string">&#x27;20130305&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="number">8300</span>,<span class="number">401</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;tony&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">73</span>,<span class="string">&#x27;20140701&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="number">3500</span>,<span class="number">401</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;owen&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;20121101&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="number">2100</span>,<span class="number">401</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;20110211&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="number">9000</span>,<span class="number">401</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;jenny&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;19000301&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="number">30000</span>,<span class="number">401</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;sank&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">48</span>,<span class="string">&#x27;20101111&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="number">10000</span>,<span class="number">401</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;哈哈&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">48</span>,<span class="string">&#x27;20150311&#x27;</span>,<span class="string">&#x27;sale&#x27;</span>,<span class="number">3000.13</span>,<span class="number">402</span>,<span class="number">2</span>),<span class="comment">#以下是销售部门</span></span><br><span class="line">(<span class="string">&#x27;呵呵&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">38</span>,<span class="string">&#x27;20101101&#x27;</span>,<span class="string">&#x27;sale&#x27;</span>,<span class="number">2000.35</span>,<span class="number">402</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;西西&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;20110312&#x27;</span>,<span class="string">&#x27;sale&#x27;</span>,<span class="number">1000.37</span>,<span class="number">402</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;乐乐&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;20160513&#x27;</span>,<span class="string">&#x27;sale&#x27;</span>,<span class="number">3000.29</span>,<span class="number">402</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;拉拉&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;20170127&#x27;</span>,<span class="string">&#x27;sale&#x27;</span>,<span class="number">4000.33</span>,<span class="number">402</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;僧龙&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;20160311&#x27;</span>,<span class="string">&#x27;operation&#x27;</span>,<span class="number">10000.13</span>,<span class="number">403</span>,<span class="number">3</span>), <span class="comment">#以下是运营部门</span></span><br><span class="line">(<span class="string">&#x27;程咬金&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;19970312&#x27;</span>,<span class="string">&#x27;operation&#x27;</span>,<span class="number">20000</span>,<span class="number">403</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;程咬银&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;20130311&#x27;</span>,<span class="string">&#x27;operation&#x27;</span>,<span class="number">19000</span>,<span class="number">403</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;程咬铜&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;20150411&#x27;</span>,<span class="string">&#x27;operation&#x27;</span>,<span class="number">18000</span>,<span class="number">403</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;程咬铁&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;20140512&#x27;</span>,<span class="string">&#x27;operation&#x27;</span>,<span class="number">17000</span>,<span class="number">403</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当表字段特别多 展示的时候错乱 可以使用\G分行展示</span></span><br><span class="line">select * <span class="keyword">from</span> emp\G;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 个别同学的电脑在插入中文的时候还是会出现乱码或者空白的现象 你可以将字符编码统一设置成GBK</span></span><br></pre></td></tr></table></figure>

<h4 id="where筛选条件"><a href="#where筛选条件" class="headerlink" title="where筛选条件"></a>where筛选条件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作用:是对整体数据的一个筛选操作</span></span><br><span class="line"><span class="comment"># 1.查询id大于等于3小于等于6的数据</span></span><br><span class="line">select <span class="built_in">id</span>,name,age <span class="keyword">from</span> emp where <span class="built_in">id</span>&gt;=<span class="number">3</span> <span class="keyword">and</span> <span class="built_in">id</span>&lt;=<span class="number">6</span>;</span><br><span class="line">select <span class="built_in">id</span>,name <span class="keyword">from</span> emp where <span class="built_in">id</span> between <span class="number">3</span> <span class="keyword">and</span> <span class="number">6</span>;  两者等价</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查询薪资是20000或者18000或者17000的数据</span></span><br><span class="line">select * <span class="keyword">from</span> emp where salary=<span class="number">20000</span> <span class="keyword">or</span> salary=<span class="number">18000</span> <span class="keyword">or</span> salary=<span class="number">17000</span>;</span><br><span class="line">select * <span class="keyword">from</span> emp where salary <span class="keyword">in</span> (<span class="number">20000</span>,<span class="number">18000</span>,<span class="number">17000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查询员工姓名中包含字母o的员工的姓名和薪资</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">模糊查询</span></span><br><span class="line"><span class="string">	like</span></span><br><span class="line"><span class="string">		%  匹配任意多个字符</span></span><br><span class="line"><span class="string">		_  匹配任意单个字符</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">select name,salary <span class="keyword">from</span> emp where name like <span class="string">&#x27;%o%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查询员工姓名是由四个字符组成的 姓名和薪资  char_length()   _</span></span><br><span class="line">select name,salary <span class="keyword">from</span> emp where name like <span class="string">&#x27;____&#x27;</span>;</span><br><span class="line">select name,salary <span class="keyword">from</span> emp where char_length(name) = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查询id小于3或者id大于6的数据</span></span><br><span class="line">select * <span class="keyword">from</span> emp where <span class="built_in">id</span> <span class="keyword">not</span> between <span class="number">3</span> <span class="keyword">and</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查询薪资不在20000,18000,17000范围的数据</span></span><br><span class="line">select * <span class="keyword">from</span> emp where salary <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">20000</span>,<span class="number">18000</span>,<span class="number">17000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查询岗位描述为空的员工姓名和岗位名  针对null不用等号 用is</span></span><br><span class="line">select name,post <span class="keyword">from</span> emp where post_comment = NULL;</span><br><span class="line">select name,post <span class="keyword">from</span> emp where post_comment <span class="keyword">is</span> NULL;</span><br></pre></td></tr></table></figure>

<h4 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分组实际应用场景  分组应用场景非常的多</span></span><br><span class="line">	男女比例</span><br><span class="line">    部门平均薪资</span><br><span class="line">    部门秃头率</span><br><span class="line">    国家之间数据统计</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1	按照部门分组</span></span><br><span class="line">select * <span class="keyword">from</span> emp group by post;</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">分组之后 最小可操作单位应该是组 还不再是组内的单个数据</span></span><br><span class="line"><span class="string">	上述命令在你没有设置严格模式的时候是可正常执行的 返回的是分组之后 每个组的第一条数据 但是这不符合分组的规范:分组之后不应该考虑单个数据 而应该以组为操作单位(分组之后 没办法直接获取组内单个数据)</span></span><br><span class="line"><span class="string">	如果设置了严格模式 那么上述命令会直接报错 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">set</span> <span class="keyword">global</span> sql_mode = <span class="string">&#x27;strict_trans_tables,only_full_group_by&#x27;</span>;</span><br><span class="line"></span><br><span class="line">设置严格模式之后  分组 默认只能拿到分组的依据</span><br><span class="line">select post <span class="keyword">from</span> emp group by post;  </span><br><span class="line">按照什么分组就只能拿到分组 其他字段不能直接获取 需要借助于一些方法(聚合函数)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">什么时候需要分组啊？？？</span></span><br><span class="line"><span class="string">	关键字 </span></span><br><span class="line"><span class="string">		每个 平均 最高 最低 </span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	聚合函数</span></span><br><span class="line"><span class="string">		max</span></span><br><span class="line"><span class="string">		min</span></span><br><span class="line"><span class="string">		sum</span></span><br><span class="line"><span class="string">		count</span></span><br><span class="line"><span class="string">		avg</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 1.获取每个部门的最高薪资</span></span><br><span class="line">select post,<span class="built_in">max</span>(salary) <span class="keyword">from</span> emp group by post;</span><br><span class="line">select post <span class="keyword">as</span> <span class="string">&#x27;部门&#x27;</span>,<span class="built_in">max</span>(salary) <span class="keyword">as</span> <span class="string">&#x27;最高薪资&#x27;</span> <span class="keyword">from</span> emp group by post;</span><br><span class="line">select post <span class="string">&#x27;部门&#x27;</span>,<span class="built_in">max</span>(salary) <span class="string">&#x27;最高薪资&#x27;</span> <span class="keyword">from</span> emp group by post;</span><br><span class="line"><span class="comment"># as可以给字段起别名 也可以直接省略不写 但是不推荐 因为省略的话语意不明确 容易错乱</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取每个部门的最低薪资</span></span><br><span class="line">select post,<span class="built_in">min</span>(salary) <span class="keyword">from</span> emp group by post;</span><br><span class="line"><span class="comment"># 3.获取每个部门的平均薪资</span></span><br><span class="line">select post,avg(salary) <span class="keyword">from</span> emp group by post;</span><br><span class="line"><span class="comment"># 4.获取每个部门的工资总和</span></span><br><span class="line">select post,<span class="built_in">sum</span>(salary) <span class="keyword">from</span> emp group by post;</span><br><span class="line"><span class="comment"># 5.获取每个部门的人数</span></span><br><span class="line">select post,count(<span class="built_in">id</span>) <span class="keyword">from</span> emp group by post;  <span class="comment"># 常用 符合逻辑</span></span><br><span class="line">select post,count(salary) <span class="keyword">from</span> emp group by post;</span><br><span class="line">select post,count(age) <span class="keyword">from</span> emp group by post;</span><br><span class="line">select post,count(post_comment) <span class="keyword">from</span> emp group by post;  null不行</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查询分组之后的部门名称和每个部门下所有的员工姓名 </span></span><br><span class="line"><span class="comment"># group_concat不单单可以支持你获取分组之后的其他字段值 还支持拼接操作</span></span><br><span class="line">select post,group_concat(name) <span class="keyword">from</span> emp group by post;</span><br><span class="line">select post,group_concat(name,<span class="string">&#x27;_DSB&#x27;</span>) <span class="keyword">from</span> emp group by post;</span><br><span class="line">select post,group_concat(name,<span class="string">&#x27;:&#x27;</span>,salary) <span class="keyword">from</span> emp group by post;</span><br><span class="line"><span class="comment"># concat不分组的时候用 </span></span><br><span class="line">select concat(<span class="string">&#x27;NAME:&#x27;</span>,name),concat(<span class="string">&#x27;SAL:&#x27;</span>,salary) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充 as语法不单单可以给字段起别名 还可以给表临时起别名</span></span><br><span class="line">select emp.<span class="built_in">id</span>,emp.name <span class="keyword">from</span> emp;  </span><br><span class="line">select emp.<span class="built_in">id</span>,emp.name <span class="keyword">from</span> emp <span class="keyword">as</span> t1;   报错</span><br><span class="line">select t1.<span class="built_in">id</span>,t1.name <span class="keyword">from</span> emp <span class="keyword">as</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询每个人的年薪  12薪</span></span><br><span class="line">select name,salary*<span class="number">12</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h4 id="分组注意事项"><a href="#分组注意事项" class="headerlink" title="分组注意事项"></a>分组注意事项</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键字where和group by同时出现的时候group by必须在where的后面</span></span><br><span class="line">where先对整体数据进行过滤之后再分组操作</span><br><span class="line">where筛选条件不能使用聚合函数</span><br><span class="line">select <span class="built_in">id</span>,name,age <span class="keyword">from</span> emp where <span class="built_in">max</span>(salary) &gt; <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">select <span class="built_in">max</span>(salary) <span class="keyword">from</span> emp;  <span class="comment"># 不分组 默认整体就是一组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各部门年龄在30岁以上的员工平均薪资</span></span><br><span class="line">	<span class="number">1</span> 先求所有年龄大于<span class="number">30</span>岁的员工</span><br><span class="line">    	select * <span class="keyword">from</span> emp where age&gt;<span class="number">30</span>;</span><br><span class="line">    <span class="number">2</span> 再对结果进行分组</span><br><span class="line">     	select * <span class="keyword">from</span> emp where age&gt;<span class="number">30</span> group by post;</span><br><span class="line">    </span><br><span class="line">    select post,avg(salary) <span class="keyword">from</span> emp where age&gt;<span class="number">30</span> group by post;</span><br></pre></td></tr></table></figure>

<h4 id="having分组之后的筛选条件"><a href="#having分组之后的筛选条件" class="headerlink" title="having分组之后的筛选条件"></a>having分组之后的筛选条件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">having的语法根where是一致的</span></span><br><span class="line"><span class="string">只不过having是在分组之后进行的过滤操作</span></span><br><span class="line"><span class="string">即having是可以直接使用聚合函数的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 统计各部门年龄在30岁以上的员工平均工资并且保留平均薪资大于10000的部门</span></span><br><span class="line">select post,avg(salary) <span class="keyword">from</span> emp </span><br><span class="line">		where age&gt;<span class="number">30</span> </span><br><span class="line">    	group by post</span><br><span class="line">        having avg(salary) &gt; <span class="number">10000</span></span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<h4 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一定要注意 必须是完全一样的数据才可以去重！！！</span></span><br><span class="line"><span class="string">一定不要将逐渐忽视了 有逐渐存在的情况下 是不可能去重的</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;&#x27;id&#x27;:1,&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18&#125;,</span></span><br><span class="line"><span class="string">&#123;&#x27;id&#x27;:2,&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18&#125;,</span></span><br><span class="line"><span class="string">&#123;&#x27;id&#x27;:3,&#x27;name&#x27;:&#x27;egon&#x27;,&#x27;age&#x27;:18&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">ORM  对象关系映射   让不懂SQL语句的人也能够非常牛逼的操作数据库</span></span><br><span class="line"><span class="string">表								类</span></span><br><span class="line"><span class="string">一条条的数据						对象</span></span><br><span class="line"><span class="string">字段对应的值						对象的属性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">你再写类 就意味着在创建表</span></span><br><span class="line"><span class="string">用类生成对象 就意味着再创建数据</span></span><br><span class="line"><span class="string">对象点属性 就是在获取数据字段对应的值</span></span><br><span class="line"><span class="string">目的就是减轻python程序员的压力 只需要会python面向对象的知识点就可以操作MySQL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">select distinct <span class="built_in">id</span>,age <span class="keyword">from</span> emp;</span><br><span class="line">select distinct age <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h4 id="order-by排序"><a href="#order-by排序" class="headerlink" title="order by排序"></a>order by排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> emp order by salary;</span><br><span class="line">select * <span class="keyword">from</span> emp order by salary asc;</span><br><span class="line">select * <span class="keyword">from</span> emp order by salary desc;</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">order by默认是升序  asc 该asc可以省略不写</span></span><br><span class="line"><span class="string">也可以修改为降序     desc</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">select * <span class="keyword">from</span> emp order by age desc,salary asc;</span><br><span class="line"><span class="comment"># 先按照age降序排  如果碰到age相同 则再按照salary升序排</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各部门年龄在10岁以上的员工平均工资并且保留平均薪资大于1000的部门,然后对平均工资降序排序</span></span><br><span class="line">	select post,avg(salary) <span class="keyword">from</span> emp </span><br><span class="line">		where age&gt;<span class="number">10</span> </span><br><span class="line">    	group by post</span><br><span class="line">        having avg(salary) &gt; <span class="number">1000</span></span><br><span class="line">        order by avg(salary) desc</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<h4 id="limit限制展示条数"><a href="#limit限制展示条数" class="headerlink" title="limit限制展示条数"></a>limit限制展示条数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="string">&quot;&quot;&quot;针对数据过多的情况 我们通常都是做分页处理&quot;&quot;&quot;</span></span><br><span class="line">select * <span class="keyword">from</span> emp limit <span class="number">3</span>;  <span class="comment"># 只展示三条数据</span></span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> emp limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line">select * <span class="keyword">from</span> emp limit <span class="number">5</span>,<span class="number">5</span>;</span><br><span class="line">第一个参数是起始位置</span><br><span class="line">第二个参数是展示条数</span><br></pre></td></tr></table></figure>

<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> emp where name regexp <span class="string">&#x27;^j.*(n|y)$&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h4><p>前期表准备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建表</span></span><br><span class="line">create table dep(</span><br><span class="line"><span class="built_in">id</span> <span class="built_in">int</span>,</span><br><span class="line">name varchar(<span class="number">20</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line"><span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">name varchar(<span class="number">20</span>),</span><br><span class="line">sex enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>) <span class="keyword">not</span> null default <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">age <span class="built_in">int</span>,</span><br><span class="line">dep_id <span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入数据</span></span><br><span class="line">insert into dep values</span><br><span class="line">(<span class="number">200</span>,<span class="string">&#x27;技术&#x27;</span>),</span><br><span class="line">(<span class="number">201</span>,<span class="string">&#x27;人力资源&#x27;</span>),</span><br><span class="line">(<span class="number">202</span>,<span class="string">&#x27;销售&#x27;</span>),</span><br><span class="line">(<span class="number">203</span>,<span class="string">&#x27;运营&#x27;</span>);</span><br><span class="line"></span><br><span class="line">insert into emp(name,sex,age,dep_id) values</span><br><span class="line">(<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="number">200</span>),</span><br><span class="line">(<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">48</span>,<span class="number">201</span>),</span><br><span class="line">(<span class="string">&#x27;kevin&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="number">201</span>),</span><br><span class="line">(<span class="string">&#x27;nick&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">28</span>,<span class="number">202</span>),</span><br><span class="line">(<span class="string">&#x27;owen&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="number">203</span>),</span><br><span class="line">(<span class="string">&#x27;jerry&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">18</span>,<span class="number">204</span>);</span><br></pre></td></tr></table></figure>

<h4 id="表查询"><a href="#表查询" class="headerlink" title="表查询"></a>表查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> dep,emp;  <span class="comment"># 结果   笛卡尔积</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">了解即可 不知道也没关系</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> emp,dep where emp.dep_id = dep.<span class="built_in">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MySQL也知道 你在后面查询数据过程中 肯定会经常用到拼表操作 </span></span><br><span class="line"><span class="string">所以特地给你开设了对应的方法</span></span><br><span class="line"><span class="string">	inner join  内连接</span></span><br><span class="line"><span class="string">	left join   左连接</span></span><br><span class="line"><span class="string">	right join  右连接</span></span><br><span class="line"><span class="string">	union		全连接</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># inner join  内连接</span></span><br><span class="line">select * <span class="keyword">from</span> emp inner join dep on emp.dep_id = dep.<span class="built_in">id</span>;</span><br><span class="line"><span class="comment"># 只拼接两张表中公有的数据部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># left join   左连接</span></span><br><span class="line">select * <span class="keyword">from</span> emp left join dep on emp.dep_id = dep.<span class="built_in">id</span>;</span><br><span class="line"><span class="comment"># 左表所有的数据都展示出来 没有对应的项就用NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># right join  右连接</span></span><br><span class="line">select * <span class="keyword">from</span> emp right join dep on emp.dep_id = dep.<span class="built_in">id</span>;</span><br><span class="line"><span class="comment"># 右表所有的数据都展示出来 没有对应的项就用NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># union		全连接  左右两表所有的数据都展示出来</span></span><br><span class="line">select * <span class="keyword">from</span> emp left join dep on emp.dep_id = dep.<span class="built_in">id</span></span><br><span class="line">union</span><br><span class="line">select * <span class="keyword">from</span> emp right join dep on emp.dep_id = dep.<span class="built_in">id</span>;</span><br></pre></td></tr></table></figure>

<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">子查询就是我们平时解决问题的思路</span></span><br><span class="line"><span class="string">	分步骤解决问题</span></span><br><span class="line"><span class="string">		第一步</span></span><br><span class="line"><span class="string">		第二步</span></span><br><span class="line"><span class="string">		...</span></span><br><span class="line"><span class="string">将一个查询语句的结果当做另外一个查询语句的条件去用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 查询部门是技术或者人力资源的员工信息</span></span><br><span class="line">	<span class="number">1</span> 先获取部门的<span class="built_in">id</span>号</span><br><span class="line">    <span class="number">2</span> 再去员工表里面筛选出对应的员工</span><br><span class="line">    select <span class="built_in">id</span> <span class="keyword">from</span> dep where name=<span class="string">&#x27;技术&#x27;</span> <span class="keyword">or</span> name = <span class="string">&#x27;人力资源&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    select name <span class="keyword">from</span> emp where dep_id <span class="keyword">in</span> (<span class="number">200</span>,<span class="number">201</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    select * <span class="keyword">from</span> emp where dep_id <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> dep where name=<span class="string">&#x27;技术&#x27;</span> <span class="keyword">or</span> name = <span class="string">&#x27;人力资源&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">表的查询结果可以作为其他表的查询条件</span><br><span class="line">也可以通过起别名的方式把它作为一个张虚拟表根其他表关联</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多表查询就两种方式</span></span><br><span class="line"><span class="string">	先拼接表再查询</span></span><br><span class="line"><span class="string">	子查询 一步一步来</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="将查询结果插入到其它表中"><a href="#将查询结果插入到其它表中" class="headerlink" title="将查询结果插入到其它表中"></a>将查询结果插入到其它表中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">	-- 将查询结果插入到good_cates表中</span><br><span class="line">	insert into good_cates(name) select cate_name from goods group by cate_name;</span><br><span class="line"></span><br><span class="line">使用连接更新表中某个字段数据	</span><br><span class="line">	将goods表中的分类名称更改成商品分类表中对应的分类id</span><br><span class="line">	-- 查看goods表中的商品分类名称对应的商品分类id</span><br><span class="line">	select * from goods inner join good_cates on goods.cate_name = good_cates.name;</span><br><span class="line"></span><br><span class="line">-- 把该语句中from 后的语句理解为一张虚表  </span><br><span class="line">update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id;</span><br><span class="line"></span><br><span class="line">更改表字段名（修改表结构）</span><br><span class="line">	修改表结构可以使用: alter table 语句，多个修改字段之间使用逗号分隔</span><br><span class="line">	alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null;</span><br></pre></td></tr></table></figure>



<h2 id="pymsql"><a href="#pymsql" class="headerlink" title="pymsql"></a>pymsql</h2><h3 id="python调用mysql"><a href="#python调用mysql" class="headerlink" title="python调用mysql"></a>python调用mysql</h3><p>pip3 install pymysql(用pip安装pymysql模块)</p>
<p>python调用mysql接口分为六步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.导包</span><br><span class="line">2.创建连接对象</span><br><span class="line">3.获取游标，目的就是要执行sql语句</span><br><span class="line">4.执行sql语句</span><br><span class="line">5.关闭游标</span><br><span class="line">6.关闭连接</span><br><span class="line">对应代码：</span><br><span class="line">	导包</span><br><span class="line">		import pymysql</span><br><span class="line">	创建连接对象</span><br><span class="line">		pymysql.connect(参数列表)</span><br><span class="line">	获取游标对象</span><br><span class="line">		cursor =conn.cursor()</span><br><span class="line">	执行SQL语句</span><br><span class="line">		row_count = cursor.execute(sql)</span><br><span class="line">	获取查询结果集</span><br><span class="line">		result = cursor.fetchall()</span><br><span class="line">	将修改操作提交到数据库</span><br><span class="line">		conn.commit()</span><br><span class="line">	回滚数据</span><br><span class="line">		conn.rollback()</span><br><span class="line">	关闭游标</span><br><span class="line">		cursor.close()</span><br><span class="line">	关闭连接</span><br><span class="line">		conn.close()</span><br><span class="line">	导入 pymysql 包</span><br><span class="line">		import pymysql</span><br></pre></td></tr></table></figure>

<h3 id="创建连接对象"><a href="#创建连接对象" class="headerlink" title="创建连接对象"></a>创建连接对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">调用pymysql模块中的connect()函数来创建连接对象,代码如下:</span><br><span class="line">	 conn=connect(参数列表)</span><br><span class="line"></span><br><span class="line">	 * 参数host：连接的mysql主机，如果本机是&#x27;localhost&#x27;</span><br><span class="line">	 * 参数port：连接的mysql主机的端口，默认是3306</span><br><span class="line">	 * 参数user：连接的用户名</span><br><span class="line">	 * 参数password：连接的密码</span><br><span class="line">	 * 参数database：数据库的名称</span><br><span class="line">	 * 参数charset：通信采用的编码方式，推荐使用utf8</span><br><span class="line">	连接对象操作说明:</span><br><span class="line">		关闭连接 conn.close()</span><br><span class="line">		提交数据 conn.commit()</span><br><span class="line">		撤销数据 conn.rollback()</span><br><span class="line">获取游标对象：</span><br><span class="line">	获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下:</span><br><span class="line">	 # 调用连接对象的cursor()方法获取游标对象   </span><br><span class="line">	 cur =conn.cursor()</span><br><span class="line">	游标操作说明:</span><br><span class="line">		使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句</span><br><span class="line">		获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,&#x27;张三&#x27;)</span><br><span class="line">		获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,&#x27;张三&#x27;),(2,&#x27;李四&#x27;))</span><br><span class="line">		关闭游标: cur.close(),表示和数据库操作完成</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">	# 创建连接对象</span><br><span class="line">	conn = pymysql.connect(host=&#x27;localhost&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;mysql&#x27;,database=&#x27;python&#x27;, charset=&#x27;utf8&#x27;)</span><br><span class="line">	# 获取游标对象</span><br><span class="line">	cursor = conn.cursor()</span><br><span class="line">	# 查询 SQL 语句</span><br><span class="line">	sql = &quot;select * from students;&quot;</span><br><span class="line">	# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数</span><br><span class="line">	row_count = cursor.execute(sql)</span><br><span class="line">	print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)</span><br><span class="line">	# 取出结果集中一行数据,　例如:(1, &#x27;张三&#x27;)</span><br><span class="line">	# print(cursor.fetchone())</span><br><span class="line">	# 取出结果集中的所有数据, 例如:((1, &#x27;张三&#x27;), (2, &#x27;李四&#x27;), (3, &#x27;王五&#x27;))</span><br><span class="line">	for line in cursor.fetchall():</span><br><span class="line">		print(line)</span><br><span class="line">	# 关闭游标</span><br><span class="line">	cursor.close()</span><br><span class="line">	# 关闭连接</span><br><span class="line">	conn.close()</span><br><span class="line">添加（修改）sql数据:</span><br><span class="line">	import pymysql</span><br><span class="line">	conn=pymysql.connect(host=&quot;10.10.10.85&quot;,</span><br><span class="line">					port=3306,</span><br><span class="line">					user=&quot;root&quot;,</span><br><span class="line">					password=&quot;123456&quot;,</span><br><span class="line">					database=&quot;python&quot;,</span><br><span class="line">					charset=&quot;utf8&quot;)</span><br><span class="line">	cursor =conn.cursor()</span><br><span class="line">	sql = &quot;insert into students(name) values(&#x27;张三&#x27;);&quot;</span><br><span class="line">	try:</span><br><span class="line">		row_count=cursor.execute(sql)</span><br><span class="line">		print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)</span><br><span class="line">		conn.commit()</span><br><span class="line">	except Exception as e:</span><br><span class="line">		conn.rollback()</span><br><span class="line">	finally:</span><br><span class="line">		cursor.close()</span><br><span class="line">		conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	什么是SQL注入?</span><br><span class="line">​	用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。</span><br><span class="line">​	如何防止SQL注入?</span><br><span class="line">​	SQL语句参数化</span><br><span class="line">​	SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作</span><br><span class="line">​	将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="防止SQL注入的示例代码"><a href="#防止SQL注入的示例代码" class="headerlink" title="防止SQL注入的示例代码:"></a>防止SQL注入的示例代码:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">利用一些语法的特性 书写一些特点的语句实现固定的语法</span><br><span class="line">MySQL利用的是MySQL的注释语法</span><br><span class="line">select * from user where name=&#x27;jason&#x27; -- jhsadklsajdkla&#x27; and password=&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">select * from user where name=&#x27;xxx&#x27; or 1=1 -- sakjdkljakldjasl&#x27; and password=&#x27;&#x27;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#日常生活中很多软件在注册的时候都不能含有特殊符号</span><br><span class="line">#因为怕你构造出特定的语句入侵数据库 不安全</span><br><span class="line"></span><br><span class="line"># 敏感的数据不要自己做拼接 交给execute帮你拼接即可</span><br><span class="line"># 结合数据库完成一个用户的登录功能？</span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host = &#x27;127.0.0.1&#x27;,</span><br><span class="line">    port = 3306,</span><br><span class="line">    user = &#x27;root&#x27;,</span><br><span class="line">    password = &#x27;123456&#x27;,</span><br><span class="line">    database = &#x27;day48&#x27;,</span><br><span class="line">    charset = &#x27;utf8&#x27;  # 编码千万不要加-</span><br><span class="line">)  # 链接数据库</span><br><span class="line">cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">username = input(&#x27;&gt;&gt;&gt;:&#x27;)</span><br><span class="line">password = input(&#x27;&gt;&gt;&gt;:&#x27;)</span><br><span class="line">sql = &quot;select * from user where name=%s and password=%s&quot;</span><br><span class="line"># 不要手动拼接数据 先用%s占位 之后将需要拼接的数据直接交给execute方法即可</span><br><span class="line">print(sql)</span><br><span class="line">rows = cursor.execute(sql,(username,password))  # 自动识别sql里面的%s用后面元组里面的数据替换</span><br><span class="line">if rows:</span><br><span class="line">    print(&#x27;登录成功&#x27;)</span><br><span class="line">    print(cursor.fetchall())</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;用户名密码错误&#x27;)</span><br></pre></td></tr></table></figure>

<p>这里防止sql注入的主要方法是这句，rows = cursor.execute(sql,(username,password))  ，用execute自带的拼接方式来做防止注入。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/18/mysql%20for%20python_hexo/" data-id="ckxjra7p70016r0v19crdewzy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-socket_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/18/socket_hexo/" class="article-date">
  <time datetime="2021-11-18T09:24:46.000Z" itemprop="datePublished">2021-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/18/socket_hexo/">socket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SOCKET-："><a href="#SOCKET-：" class="headerlink" title="SOCKET ："></a>SOCKET ：</h1><p>socket本质上来说就是位于应用层与传输层之间的逻辑层，下图为tcp/ip四层，五层协议以及osi参考模型</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.socket/1036857-20161008145544426-736439132.png" alt="img"></p>
<p>一般现在用的就是五层模型，从两台计算机传输数据的角度来讲，物理层定义其计算机基本数据结构（0和1，也就是数据本身）。数据链路层定义了数据的传输（以mac地址为唯一标识），而这一层在局域网内通信方式也极其简单，就是通过广播发送到每一个局域网内的计算机上面，如非指定的接受者（mac地址），则丢弃。到网络层时就可以跨越其局域网的限制，通过网关设备的路由功能（通过ip地址进行路由），就可以找到互联网上的每一个设备进行传输通信，但其本质上还是数据链路层通信，网络层最主要是定位到互联网每一台主机（ARP协议最终将ip解析到mac地址）。到传输层时有两个协议（tcp和udp），tcp是稳定的传输协议，主要保证数据完整性，而udp是非稳定的传输协议，用于非重要数据传输，例如视频聊天，qq信息等。这里传输层定义了端口，可使用范围为1-65535。如果说网络层是用来定位到互联网中的某一台计算机的话，那么传输层则是定位到计算机中的某个应用且与其建立连接（三次握手，其建立连接本质上也是逻辑上的建立）。到应用层这里则是访问到应用中具体某个资源，例如/index.html。</p>
<p>应用程序位于其应用层，在应用程序发送数据时，需要将其封装打包成一段段的数据段送到传输层，然后传输层再封装成网络包，到链路层时又封装成数据帧，到物理层又封装成数据位（二进制，0和1）。到目标主机以后从物理层开始又一层一层的拆包往上传递，所以正常情况下程序员在编写程序时，应该把客户端和目标服务器五层的封装以及拆包写好，但是这个步骤太过于麻烦且重复性工作，所以有了socket。</p>
<p><u>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</u></p>
<p><u>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</u></p>
<p>有了socket接口以后程序员就只用关心程序本身，只要将C/S两边程序写好，直接调用已有的socket模块来帮程序员完成应用层以下真正实现传输的所有步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="socket流程："><a href="#socket流程：" class="headerlink" title="socket流程："></a>socket流程：</h2><p><img src="https://yinshiweiysw.github.io/images/assets.socket/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>图中每一个步骤就是socket的每一个提供函数（方法）。</p>
<p>客户端：</p>
<p>首先创建socket对象，连接服务器端，发送（请求）数据和接受数据，然后关闭套接字</p>
<p>服务器端：<br>        首先也需要创建socket对象，然后绑定端口（服务器需要固定的端口绑定，客户端使用随机ip和端口进行通信即可），监听，监听完毕后accept等待客户端连接（这里可以设置半连接池），然后连接完毕以后发送数据，接受数据（发送接受先后顺序不定，看程序需要），最后关闭连接（关闭这个客户端的连接），但一般不会关闭服务器套接字连接。</p>
<h2 id="socket-for-python"><a href="#socket-for-python" class="headerlink" title="socket for python:"></a>socket for python:</h2><h3 id="tcp流程"><a href="#tcp流程" class="headerlink" title="tcp流程"></a>tcp流程</h3><p>tcp客户端:<br>            创建客户端套接字对象<br>            和服务端套接字建立连接<br>            发送数据<br>            接收数据<br>            关闭客户端套接字<br>            socket() -&gt; connect() -&gt; send() -&gt; recv () -&gt;close()<br>      tcp服务器：<br>            创建服务端端套接字对象<br>            绑定端口号<br>            设置监听<br>            等待接受客户端的连接请求<br>            接收数据<br>            发送数据<br>            关闭套接字<br>            socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;recv()-send()-&gt;close() </p>
<p>tcp客户端开发：</p>
<p>需要导入socket模块，然后根据步骤调用每一个方法即可，实例代码如下</p>
<h3 id="tcp："><a href="#tcp：" class="headerlink" title="tcp："></a>tcp：</h3><p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">SOCKET=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">SOCKET.connect((&#x27;localhost&#x27;,8080))</span><br><span class="line"></span><br><span class="line">SOCKET.send(&#x27;你就是传说中的服务器吗？我是客户端&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">information=SOCKET.recv(1024)</span><br><span class="line">print(information.decode(&#x27;utf-8&#x27;))</span><br><span class="line">SOCKET.close()</span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">SOCKET=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">SOCKET.bind((&#x27;localhost&#x27;,8080))</span><br><span class="line"></span><br><span class="line">SOCKET.listen()</span><br><span class="line"></span><br><span class="line">user,user_addr=SOCKET.accept()</span><br><span class="line">print(&#x27;正在处理客户端消息，客户端ip为：&#x27;,user_addr)</span><br><span class="line">information=user.recv(1024)</span><br><span class="line">print(information.decode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">user.send(&#x27;给客户端发送消息&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">user.close()</span><br><span class="line"></span><br><span class="line">SOCKET.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="udp："><a href="#udp：" class="headerlink" title="udp："></a>udp：</h3><p>服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">server=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">server.bind((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line">while True:</span><br><span class="line">    data,ip_addr=server.recvfrom(1024)</span><br><span class="line">    print(data.decode(&#x27;utf-8&#x27;))</span><br><span class="line">    server.sendto(data,ip_addr)</span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;&gt;:&#x27;).strip()</span><br><span class="line">    server.sendto(msg.encode(&#x27;utf-8&#x27;),(&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line">    data, ip_addr = server.recvfrom(1024)</span><br><span class="line">    print(data.decode(&#x27;utf-8&#x27;))</span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure>

<h3 id="远程执行命令和粘包问题"><a href="#远程执行命令和粘包问题" class="headerlink" title="远程执行命令和粘包问题"></a>远程执行命令和粘包问题</h3><h4 id="粘包："><a href="#粘包：" class="headerlink" title="粘包："></a>粘包：</h4><p><img src="https://yinshiweiysw.github.io/images/assets.socket/image-20211104162346374.png" alt="image-20211104162346374"></p>
<p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流(stream)，一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢?可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。<br>        例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始,在何处结束<br>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。<br>        此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p>
<p>1.TCP (transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端〈客户端和服务器端）都要有—一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法(Nagle算法)，将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。<br>        2.UDP(user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，,由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头〈消息来源地址，端口等信息)，这样,对于接收端来说，就容易进行区分处理了。即面向消息的通信是有消息保护边界的。<br>        3.tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车)，那也不是空消息，udp协议会帮你封装上消息头.</p>
<p>例如客户端在使用recv(1024)方法接受数据时，其最大接受数据为1024个字节，但服务器端发送的数据远远大于这个值，于是客户端的缓存就会有很多数据没拿到，只有1024是真正被网卡取出缓存的，其他数据会在下一次再向客户端请求数据时拿到，第二次很明显无法拿到想要的数据，而是第一次没有读取完的数据。</p>
<p>客户端收数据没收干净，有残留，就会在下一次结果混淆在一起。</p>
<p>解决办法：</p>
<p>每次都将数据收完，不要让其残留在缓存里面。    </p>
<p>1.拿到数据的总大小total_size</p>
<p>2.recv_size=0,循环接收，每接收一次，recv_size+=接收的长度    </p>
<p>3.直到recv_size=total_size，结束循环</p>
<h4 id="python解决粘包（远程执行命令的代码）："><a href="#python解决粘包（远程执行命令的代码）：" class="headerlink" title="python解决粘包（远程执行命令的代码）："></a>python解决粘包（远程执行命令的代码）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.服务器端要传入其发送数据的具体字节大小到客户端（也就是头信息）</span><br><span class="line">2.客户端接收数据时要先接收头部信息（字节大小），再根据其字节大小接收具体的数据</span><br><span class="line">#subprocess为远程执行命令</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#服务器端</span><br><span class="line">#本代码为客户端调用命令远程执行服务器端的命令</span><br><span class="line">import subprocess</span><br><span class="line">from socket import *</span><br><span class="line">import struct</span><br><span class="line">server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">server.bind((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line">server.listen(5)</span><br><span class="line">while True:</span><br><span class="line">    conn,client_addr=server.accept()</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            res=conn.recv(1024)</span><br><span class="line">            if len(res) == 0:break #如果客户端输入的命令为空则推出</span><br><span class="line">            obj=subprocess.Popen(res.decode(&#x27;utf-8&#x27;),</span><br><span class="line">                             shell=True,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">           #subprocess.Popen执行命令，stdout和stderr为其正确输出以及错误输出</span><br><span class="line">            stdout=obj.stdout.read()</span><br><span class="line">            stderr=obj.stderr.read()</span><br><span class="line">            total_size=len(stdout)+len(stderr) #统计其输出代码的字节长度</span><br><span class="line">            #stdout为命令执行成功输出，stderr为执行错误的输出</span><br><span class="line">            header=struct.pack(&#x27;i&#x27;,total_size) #将其长度转换为字节bytes，struct.pack 中i的固定大小为4字节，表示其客户端在拿到头部信息时，先收取4字节并解码就可以得到其服务器端传输数据的大小</span><br><span class="line">            conn.send(header)</span><br><span class="line">            conn.send(stdout+stderr)</span><br><span class="line">        except Exception:</span><br><span class="line">            break</span><br><span class="line">    conn.close()	</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#客户端</span><br><span class="line">import struct</span><br><span class="line">from socket import *</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;请输入命令&#x27;).strip()</span><br><span class="line">    if len(msg) == 0:continue</span><br><span class="line">    client.send(msg.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    header=client.recv(4) #拿四个字节的数据大小</span><br><span class="line">    total_size=struct.unpack(&#x27;i&#x27;,header)[0] #拿到后解码</span><br><span class="line">    recv_size=0</span><br><span class="line">    cmd_res=b&#x27;&#x27;</span><br><span class="line">    while  recv_size &lt; total_size: #如果已拿到的数据大小recv_size小于服务器发送过来的总数据大小就继续拿数据。</span><br><span class="line">        data=client.recv(1024)</span><br><span class="line">        recv_size+=len(data)</span><br><span class="line">        cmd_res+=data</span><br><span class="line">        print(data.decode(&#x27;gbk&#x27;),end=&#x27;&#x27;) #windows编码gbk</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>strut转换参数：</p>
<p><img src="https://yinshiweiysw.github.io/images/assets.socket/image-20211104172547839.png" alt="image-20211104172547839"></p>
<h4 id="解决粘包代码终极版："><a href="#解决粘包代码终极版：" class="headerlink" title="解决粘包代码终极版："></a>解决粘包代码终极版：</h4><p>（将其封装成一个字典，将字典作为头信息传递过去）</p>
<p>服务器端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">@作者: egon老湿</span><br><span class="line">@微信:18611453110</span><br><span class="line">@专栏: https://zhuanlan.zhihu.com/c_1189883314197168128</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 服务端应该满足两个特点：</span><br><span class="line"># 1、一直对外提供服务</span><br><span class="line"># 2、并发地服务多个客户端</span><br><span class="line">import subprocess</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #就是它，在bind前加</span><br><span class="line">server.bind((&#x27;127.0.0.1&#x27;,8083))</span><br><span class="line">server.listen(5)</span><br><span class="line"></span><br><span class="line">#  服务端应该做两件事</span><br><span class="line"># 第一件事：循环地从板连接池中取出链接请求与其建立双向链接，拿到链接对象</span><br><span class="line">while True:</span><br><span class="line">    conn,client_addr=server.accept()</span><br><span class="line"></span><br><span class="line">    # 第二件事：拿到链接对象，与其进行通信循环</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            cmd=conn.recv(1024)</span><br><span class="line">            if len(cmd) == 0:break</span><br><span class="line">            obj=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),</span><br><span class="line">                             shell=True,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE</span><br><span class="line">                             )</span><br><span class="line"></span><br><span class="line">            stdout_res=obj.stdout.read()</span><br><span class="line">            stderr_res=obj.stderr.read()</span><br><span class="line">            total_size=len(stdout_res)+len(stderr_res)</span><br><span class="line"></span><br><span class="line">            # 1、制作头</span><br><span class="line">            header_dic=&#123;</span><br><span class="line">                &quot;filename&quot;:&quot;a.txt&quot;,</span><br><span class="line">                &quot;total_size&quot;:total_size,</span><br><span class="line">                &quot;md5&quot;:&quot;123123xi12ix12&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            json_str = json.dumps(header_dic)</span><br><span class="line">            json_str_bytes = json_str.encode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            # 2、先把头的长度发过去</span><br><span class="line">            x=struct.pack(&#x27;i&#x27;,len(json_str_bytes))</span><br><span class="line">            conn.send(x)</span><br><span class="line"></span><br><span class="line">            # 3、发头信息</span><br><span class="line">            conn.send(json_str_bytes)</span><br><span class="line">            # 4、再发真实的数据</span><br><span class="line">            conn.send(stdout_res)</span><br><span class="line">            conn.send(stderr_res)</span><br><span class="line"></span><br><span class="line">        except Exception:</span><br><span class="line">            break</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">@作者: egon老湿</span><br><span class="line">@微信:18611453110</span><br><span class="line">@专栏: https://zhuanlan.zhihu.com/c_1189883314197168128</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect((&#x27;127.0.0.1&#x27;,8083))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    cmd=input(&#x27;请输入命令&gt;&gt;：&#x27;).strip()</span><br><span class="line">    if len(cmd) == 0:continue</span><br><span class="line">    client.send(cmd.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">    # 接收端</span><br><span class="line">    # 1、先手4个字节，从中提取接下来要收的头的长度</span><br><span class="line">    x=client.recv(4)</span><br><span class="line">    header_len=struct.unpack(&#x27;i&#x27;,x)[0]</span><br><span class="line"></span><br><span class="line">    # 2、接收头，并解析</span><br><span class="line">    json_str_bytes=client.recv(header_len)</span><br><span class="line">    json_str=json_str_bytes.decode(&#x27;utf-8&#x27;)</span><br><span class="line">    header_dic=json.loads(json_str)</span><br><span class="line">    print(header_dic)</span><br><span class="line">    total_size=header_dic[&quot;total_size&quot;]</span><br><span class="line"></span><br><span class="line">    # 3、接收真实的数据</span><br><span class="line">    recv_size = 0</span><br><span class="line">    while recv_size &lt; total_size:</span><br><span class="line">        recv_data=client.recv(1024)</span><br><span class="line">        recv_size+=len(recv_data)</span><br><span class="line">        print(recv_data.decode(&#x27;utf-8&#x27;),end=&#x27;&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 粘包问题出现的原因</span><br><span class="line"># 1、tcp是流式协议，数据像水流一样粘在一起，没有任何边界区分</span><br><span class="line"># 2、收数据没收干净，有残留，就会下一次结果混淆在一起</span><br><span class="line"></span><br><span class="line"># 解决的核心法门就是：每次都收干净，不要任何残留</span><br></pre></td></tr></table></figure>

<h3 id="服务端为多个客户端提供服务"><a href="#服务端为多个客户端提供服务" class="headerlink" title="服务端为多个客户端提供服务"></a>服务端为多个客户端提供服务</h3><p>从上面的代码来说，当一个服务器端处于accept()等待连接的时候，一个客户端来了这个时候代码就会继续往下面走，此时如果再来一个客户端，在请求时就会堵塞住，因为服务器端的主线程已经用于服务第一个客户端去了，无法分身服务多个客户端</p>
<p>解决办法：</p>
<p>1.socketserver </p>
<p>2.多线程（多进程）</p>
<p>这两个模块都能解决单进程服务器端的问题，其实就是服务器端把处理客户端的服务交给其他进程或线程取处理，而自己只负责与客户端连接。类似于nginx，nginx一共两个进程，master和slave，master进程仅负责接收客户端的请求，而真正与客户端通信和返回数据的是slave端。 </p>
<h4 id="socketserver"><a href="#socketserver" class="headerlink" title="socketserver:"></a>socketserver:</h4><p>这里用了socketserver模块，直接省略accpet以及以上监听绑定步骤（服务器端），直接用class类继承socketserver.BaseRequestHandler，然后定义handle函数，在恢复和发送数据时调用self.request.(recv or send)即可。最后生成对象，传入要监听的端口ip以及创建好的类名再运行对象即可。</p>
<p><strong>这里只需要创建对象时传入bind的ip+port，已经通信时调用request方法。极其简单便捷。客户端无需改变，该如何通信还是一样，服务器端除了于客户端通信的那段代码其他均为固定格式</strong></p>
<p>服务器端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import socketserver</span><br><span class="line">import struct</span><br><span class="line">class MyRequestHandle(socketserver.BaseRequestHandler):</span><br><span class="line">    def handle(self):</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                res=self.request.recv(1024)</span><br><span class="line">                if len(res) == 0:break</span><br><span class="line">                obj=subprocess.Popen(res.decode(&#x27;utf-8&#x27;),</span><br><span class="line">                                 shell=True,</span><br><span class="line">                                 stdout=subprocess.PIPE,</span><br><span class="line">                                 stderr=subprocess.PIPE)</span><br><span class="line">                stdout=obj.stdout.read()</span><br><span class="line">                stderr=obj.stderr.read()</span><br><span class="line">                total_size=len(stdout)+len(stderr)</span><br><span class="line">                #stdout为命令执行成功输出，stderr为执行错误的输出</span><br><span class="line">                header=struct.pack(&#x27;i&#x27;,total_size)</span><br><span class="line">                self.request.send(header)</span><br><span class="line">                self.request.send(stdout+stderr)</span><br><span class="line">            except Exception:</span><br><span class="line">                break</span><br><span class="line">        self.request.close()</span><br><span class="line">s=socketserver.ThreadingTCPServer((&#x27;127.0.0.1&#x27;,8080),MyRequestHandle)</span><br><span class="line">s.serve_forever()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">from socket import *</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;请输入命令&#x27;).strip()</span><br><span class="line">    if len(msg) == 0:continue</span><br><span class="line">    client.send(msg.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    header=client.recv(4)</span><br><span class="line">    total_size=struct.unpack(&#x27;i&#x27;,header)[0]</span><br><span class="line">    recv_size=0</span><br><span class="line">    cmd_res=b&#x27;&#x27;</span><br><span class="line">    while  recv_size &lt; total_size:</span><br><span class="line">        data=client.recv(1024)</span><br><span class="line">        recv_size+=len(data)</span><br><span class="line">        cmd_res+=data</span><br><span class="line">        print(data.decode(&#x27;gbk&#x27;),end=&#x27;&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="服务器端代码模板："><a href="#服务器端代码模板：" class="headerlink" title="服务器端代码模板："></a>服务器端代码模板：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import socketserver</span><br><span class="line">import struct</span><br><span class="line">class MyRequestHandle(socketserver.BaseRequestHandler):</span><br><span class="line">    def handle(self):</span><br><span class="line">        while True:</span><br><span class="line">				主代码（于客户端通信的代码）</span><br><span class="line">        self.request.close() #（关闭套接字代码）</span><br><span class="line">s=socketserver.ThreadingTCPServer((&#x27;127.0.0.1&#x27;,8080),MyRequestHandle)</span><br><span class="line">s.serve_forever()</span><br></pre></td></tr></table></figure>

<h4 id="多线程实现："><a href="#多线程实现：" class="headerlink" title="多线程实现："></a>多线程实现：</h4><p>多线程与多进程都可以实现，这里导入多线程模块，把accpet接收到的客户端对象以下代码全部交与线程来做就可以了。（多进程也可以实现，但一般用多线程即可。）这里用threading模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line">import struct</span><br><span class="line">import subprocess</span><br><span class="line"># 处理客户端请求的任务</span><br><span class="line">def handle_client_request(ip_port, new_client):</span><br><span class="line">	print(&quot;客户端的ip和端口号为:&quot;, ip_port)</span><br><span class="line">	# 5. 接收客户端的数据</span><br><span class="line">	# 收发消息都使用返回的这个新的套接字</span><br><span class="line">	# 循环接收客户端的消息</span><br><span class="line">	while True:</span><br><span class="line">		recv_data = new_client.recv(1024)</span><br><span class="line">		if recv_data == &#x27;quit&#x27;:</span><br><span class="line">			new_client.close()</span><br><span class="line">			break</span><br><span class="line">		elif recv_data:</span><br><span class="line">			obj = subprocess.Popen(recv_data.decode(&#x27;utf-8&#x27;),</span><br><span class="line">								   shell=True,</span><br><span class="line">								   stdout=subprocess.PIPE,</span><br><span class="line">								   stderr=subprocess.PIPE)</span><br><span class="line">			stdout = obj.stdout.read()</span><br><span class="line">			stderr = obj.stderr.read()</span><br><span class="line">			total_size = len(stdout) + len(stderr)</span><br><span class="line">			total_size = struct.pack(&quot;i&quot;,total_size)</span><br><span class="line">			new_client.send(total_size)</span><br><span class="line">			new_client.send(stdout)</span><br><span class="line">			new_client.send(stderr)</span><br><span class="line">		else:</span><br><span class="line">			break</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">			# 1. 创建tcp服务端套接字</span><br><span class="line">			# AF_INET: ipv4 , AF_INET6: ipv6</span><br><span class="line">			tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">			# 设置端口号复用，表示意思： 服务端程序退出端口号立即释放</span><br><span class="line">			# 1. SOL_SOCKET: 表示当前套接字</span><br><span class="line">			# 2. SO_REUSEADDR： 表示复用端口号的选项</span><br><span class="line">			# 3. True： 确定复用</span><br><span class="line">			tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</span><br><span class="line">			# 2. 绑定端口号</span><br><span class="line">			# 第一个参数表示ip地址，一般不用指定，表示本机的任何一个ip即可</span><br><span class="line">			# 第二个参数表示端口号</span><br><span class="line">			tcp_server_socket.bind((&quot;&quot;, 8080))</span><br><span class="line">			# 3. 设置监听</span><br><span class="line">			# 128: 表示最大等待建立连接的个数</span><br><span class="line">			tcp_server_socket.listen(128)</span><br><span class="line">			# 4. 等待接受客户端的连接请求</span><br><span class="line">			# 注意点： 每次当客户端和服务端建立连接成功都会返回一个新的套接字</span><br><span class="line">			# tcp_server_socket只负责等待接收客户端的连接请求，收发消息不使用该套接字</span><br><span class="line">			# 循环等待接受客户端的连接请求</span><br><span class="line">			while True:</span><br><span class="line">				new_client, ip_port = tcp_server_socket.accept()</span><br><span class="line">				# 代码执行到此，说明客户端和服务端建立连接成功</span><br><span class="line">				# 当客户端和服务端建立连接成功，创建子线程，让子线程专门负责接收客户端的消息</span><br><span class="line">				sub_thread = threading.Thread(target=handle_client_request, args=(ip_port, new_client))</span><br><span class="line">				# 设置守护主线程，主线程退出子线程直接销毁</span><br><span class="line">				sub_thread.setDaemon(True)</span><br><span class="line">				# 启动子线程执行对应的任务</span><br><span class="line">				sub_thread.start()</span><br><span class="line">				# 7. 关闭服务端套接字， 表示服务端以后不再等待接受客户端的连接请求</span><br><span class="line">				# tcp_server_socket.close()  # 因为服务端的程序需要一直运行，所以关闭服务端套接字的代码可以省略不写</span><br></pre></td></tr></table></figure>

<p>上面为服务端代码，客户端不变，仅为实现服务端多线程</p>
<h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line">import struct</span><br><span class="line">import subprocess</span><br><span class="line">def handle_client_request(ip_port, new_client):</span><br><span class="line">	while True:</span><br><span class="line">		#主代码部分</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">			tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">			tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</span><br><span class="line">			tcp_server_socket.bind((&quot;&quot;, 8080))</span><br><span class="line">			tcp_server_socket.listen(128)</span><br><span class="line">			while True:</span><br><span class="line">				new_client, ip_port = tcp_server_socket.accept()</span><br><span class="line">				sub_thread = threading.Thread(target=handle_client_request, args=(ip_port, new_client))</span><br><span class="line">				sub_thread.setDaemon(True)</span><br><span class="line">				sub_thread.start()</span><br><span class="line">				# tcp_server_socket.close() </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/18/socket_hexo/" data-id="ckxjra7pe001ur0v15i3y83fu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python异常_hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/01/python%E5%BC%82%E5%B8%B8_hexo/" class="article-date">
  <time datetime="2021-11-01T08:34:18.000Z" itemprop="datePublished">2021-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/01/python%E5%BC%82%E5%B8%B8_hexo/">python异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h2><p>异常是程序发生错误的信号，程序一旦出错就会抛出异常，从而导致程序运行的终止。</p>
<p>异常处理：</p>
<p>捕捉其异常，使其在程序出错时执行某些操作或打印记录日志或反馈某些信息，而非直接终止运行。</p>
<p>异常处理的特征：</p>
<p>异常的追踪信息，异常的类型，异常的内容。</p>
<h2 id="异常问题以及其处理方式："><a href="#异常问题以及其处理方式：" class="headerlink" title="异常问题以及其处理方式："></a>异常问题以及其处理方式：</h2><p> 语法上的错误：“SyntaxError”,</p>
<p>处理方式:必须在程序运行前就改正</p>
<p>if 1&gt;3<br>                print( “run. . . “)</p>
<p>逻辑上的错误：</p>
<p>例如：dic={‘name’:’saf’}</p>
<p>​            dic[‘age’]</p>
<p>针对逻辑上的异常又分为两种处理方式</p>
<p>​    1.错误的发生可以预知：        </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age=input(&#x27;请输入年龄&#x27;).strip()</span><br><span class="line">age=int(age)</span><br><span class="line">if age &gt; 18:</span><br><span class="line">	print(&#x27;猜大了&#x27;)</span><br><span class="line">elif age &lt; 18:</span><br><span class="line">	print(&#x27;猜小了&#x27;)</span><br><span class="line">else:</span><br><span class="line">	print(&#x27;猜对了&#x27;)</span><br></pre></td></tr></table></figure>

<p>本代码中的逻辑漏洞在于，如果这里输入的不是数字而是字母或字符串，在进行数字大小比较时，就会出错，属于代码逻辑错误，可以预知。</p>
<p>2.无法预知的错误：</p>
<p>这时只能使用</p>
<p>try函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  # 主代码块</span><br><span class="line">  pass</span><br><span class="line">except KeyError,e:</span><br><span class="line">  # 异常时，执行该块</span><br><span class="line">  pass</span><br><span class="line">else:</span><br><span class="line">  # 主代码块执行完，执行该块</span><br><span class="line">  pass</span><br><span class="line">finally:</span><br><span class="line">  # 无论异常与否，最终执行该块</span><br><span class="line">  pass</span><br></pre></td></tr></table></figure>

<p>常见异常：</p>
<p>​    IndexError,NameError,KeyError 等</p>
<p>​    第一个对应集合索引名错误，第二个对应运行的命令名错误，第三个为字典错误。每一种错误</p>
<p>python所有的标准异常类：</p>
<table>
<thead>
<tr>
<th align="left">异常名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BaseException</td>
<td align="left">所有异常的基类</td>
</tr>
<tr>
<td align="left">SystemExit</td>
<td align="left">解释器请求退出</td>
</tr>
<tr>
<td align="left">KeyboardInterrupt</td>
<td align="left">用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td align="left">Exception</td>
<td align="left">常规错误的基类</td>
</tr>
<tr>
<td align="left">StopIteration</td>
<td align="left">迭代器没有更多的值</td>
</tr>
<tr>
<td align="left">GeneratorExit</td>
<td align="left">生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td align="left">SystemExit</td>
<td align="left">Python 解释器请求退出</td>
</tr>
<tr>
<td align="left">StandardError</td>
<td align="left">所有的内建标准异常的基类</td>
</tr>
<tr>
<td align="left">ArithmeticError</td>
<td align="left">所有数值计算错误的基类</td>
</tr>
<tr>
<td align="left">FloatingPointError</td>
<td align="left">浮点计算错误</td>
</tr>
<tr>
<td align="left">OverflowError</td>
<td align="left">数值运算超出最大限制</td>
</tr>
<tr>
<td align="left">ZeroDivisionError</td>
<td align="left">除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td align="left">AssertionError</td>
<td align="left">断言语句失败</td>
</tr>
<tr>
<td align="left">AttributeError</td>
<td align="left">对象没有这个属性</td>
</tr>
<tr>
<td align="left">EOFError</td>
<td align="left">没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td align="left">EnvironmentError</td>
<td align="left">操作系统错误的基类</td>
</tr>
<tr>
<td align="left">IOError</td>
<td align="left">输入/输出操作失败</td>
</tr>
<tr>
<td align="left">OSError</td>
<td align="left">操作系统错误</td>
</tr>
<tr>
<td align="left">WindowsError</td>
<td align="left">系统调用失败</td>
</tr>
<tr>
<td align="left">ImportError</td>
<td align="left">导入模块/对象失败</td>
</tr>
<tr>
<td align="left">KeyboardInterrupt</td>
<td align="left">用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td align="left">LookupError</td>
<td align="left">无效数据查询的基类</td>
</tr>
<tr>
<td align="left">IndexError</td>
<td align="left">序列中没有没有此索引(index)</td>
</tr>
<tr>
<td align="left">KeyError</td>
<td align="left">映射中没有这个键</td>
</tr>
<tr>
<td align="left">MemoryError</td>
<td align="left">内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td align="left">NameError</td>
<td align="left">未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td align="left">UnboundLocalError</td>
<td align="left">访问未初始化的本地变量</td>
</tr>
<tr>
<td align="left">ReferenceError</td>
<td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td align="left">RuntimeError</td>
<td align="left">一般的运行时错误</td>
</tr>
<tr>
<td align="left">NotImplementedError</td>
<td align="left">尚未实现的方法</td>
</tr>
<tr>
<td align="left">SyntaxError</td>
<td align="left">Python 语法错误</td>
</tr>
<tr>
<td align="left">IndentationError</td>
<td align="left">缩进错误</td>
</tr>
<tr>
<td align="left">TabError</td>
<td align="left">Tab 和空格混用</td>
</tr>
<tr>
<td align="left">SystemError</td>
<td align="left">一般的解释器系统错误</td>
</tr>
<tr>
<td align="left">TypeError</td>
<td align="left">对类型无效的操作</td>
</tr>
<tr>
<td align="left">ValueError</td>
<td align="left">传入无效的参数</td>
</tr>
<tr>
<td align="left">UnicodeError</td>
<td align="left">Unicode 相关的错误</td>
</tr>
<tr>
<td align="left">UnicodeDecodeError</td>
<td align="left">Unicode 解码时的错误</td>
</tr>
<tr>
<td align="left">UnicodeEncodeError</td>
<td align="left">Unicode 编码时错误</td>
</tr>
<tr>
<td align="left">UnicodeTranslateError</td>
<td align="left">Unicode 转换时错误</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">警告的基类</td>
</tr>
<tr>
<td align="left">DeprecationWarning</td>
<td align="left">关于被弃用的特征的警告</td>
</tr>
<tr>
<td align="left">FutureWarning</td>
<td align="left">关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td align="left">OverflowWarning</td>
<td align="left">旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td align="left">PendingDeprecationWarning</td>
<td align="left">关于特性将会被废弃的警告</td>
</tr>
<tr>
<td align="left">RuntimeWarning</td>
<td align="left">可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td align="left">SyntaxWarning</td>
<td align="left">可疑的语法的警告</td>
</tr>
<tr>
<td align="left">UserWarning</td>
<td align="left">用户代码生成的警告</td>
</tr>
</tbody></table>
<p>无法判断具体错误的情况可以使用捕捉所有异常：</p>
<p>Exception或BaseException</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/01/python%E5%BC%82%E5%B8%B8_hexo/" data-id="ckxjra7p8001ar0v1f1c00bjx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexoblog%E6%B7%BB%E5%8A%A0hexo%E6%A0%87%E7%AD%BE/">hexoblog添加hexo标签</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E4%BB%A3%E7%A0%81/">python代码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E4%BB%A3%E7%A0%81/" rel="tag">python代码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/python%E4%BB%A3%E7%A0%81/" style="font-size: 12.5px;">python代码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/23/Linux%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1_hexo/">Linux用户行为日志审计</a>
          </li>
        
          <li>
            <a href="/2021/12/23/HTTP_hexo/">HTTP</a>
          </li>
        
          <li>
            <a href="/2021/12/23/Zabbix_hexo/">Zabbix</a>
          </li>
        
          <li>
            <a href="/2021/12/23/NFS_hexo/">NFS</a>
          </li>
        
          <li>
            <a href="/2021/12/23/firewalld_hexo/">firewalld</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>